[{"title":"狼人杀新手进阶指南","date":"2017-10-05T04:16:07.000Z","path":"2017/10/05/2017-10-05-advanced-guide-to-werewolf-kill/","text":"大家好，我是未昊，之前答应过找完工作做一次狼人杀经验分享，录视频比较麻烦，所以就写一篇文章来向你展示一个 2.5 阶选手的狼人杀世界观。主要会从基本规则，基本/多重逻辑，心态视角等几个方面进行阐述。 写在前面 本文主要面向新手(打过几局，大致清楚规则) 本文主要偏介绍，旨在启发，没有过多探讨技巧性的东西 基本规则狼人杀是一个发言+逻辑游戏，常见的是 9 人局或者 12 人局，下面我主要以 12 人局为例进行介绍。 所有玩家分为狼人阵营和好人阵营。一般是 4+4+4 的板子，即 4 张狼人、4 张神牌和 4 张村民牌。狼人晚上可以杀死一名玩家，所有玩家白天发言交流，所有玩家发言完毕后一起投票，得票最多的人出局。最终狼人杀光所有神牌或者所有村民牌，则狼人胜利；好人投票处决/杀死所有狼人，则好人胜利。 所以这个游戏从结果上是一个 抢轮次 的游戏，即无论好人还是狼人，都是以最快干掉敌对阵营的人为目的。能够分清楚每一轮的出人顺序和形势优劣，是区分一个玩家是否入门的依据。 阵营介绍我一般玩两方阵营的，三方有点复杂，我玩的少。 狼人：四张狼人牌晚上是可以睁眼相互认识队友的，所以狼队可以晚上交流信息、安排战术 神牌：一般比较平衡，出镜率最高的四张神牌是：预言家，女巫，猎人，白痴 预言家：每晚可以知道一个玩家是好人还是狼人 女巫：有两瓶药(每瓶药整局游戏只能用一次，且同一晚不能同时用俩)，解药可以救一个人，毒药可以杀死一个人。（高端局为了游戏平衡，女巫只有第一天晚上可以救自己，甚至永远不能自救，游戏前需要沟通好） 猎人：被狼人杀死或者被投票死可以开枪打死一人，被毒死不能开枪 白痴：被投票出局不会死，可以继续发言，但不能投票了。 村民：晚上全程闭眼，白天可以发言投票，没有特殊功能。 以上就是常见的“预女猎白”的板子，根据偏好不同，白痴可换成守卫，即“预女猎守”，有守卫的话，一只普通狼人可以换成白狼王。 很多人拿狼人就很虚，仿佛自己是罪人一样，其实这是不对的，这个游戏叫“狼人杀”，不是“好人杀”，狼人赢是不可耻的，心态一定要摆正。 术语介绍一般玩多了，为了使发言简练（装逼），会有一些术语和行话，这里简单介绍一些。 焊跳：狼人冒充预言家，称为“焊跳” 金水：预言家验出的好人。焊跳狼发的金水是“假金水” 查杀：预言家验出的狼人叫做“查杀” 银水：女巫夜里使用解药救起来的人 轮次：出人的顺序，本轮该出谁。例如“今天是 2 号的轮次，不是 3 号的轮次” 自刀：狼人杀人称之为“刀”，自刀就是狼人自杀 穿衣服：冒充别的角色。例如“穿女巫衣服”、“不要穿我衣服” 冲锋：狼人站队自己狼队友 倒钩：狼人冒充好人，混到好人队伍里帮好人玩 抗推：好人在白天被票出局 警徽：投票时多 1 票或者 0.5 票，拥有警徽的人即为警长 警长：好人玩家投票选举出来的领导者，可以指定发言顺序，警长 夜里 死后可以把警徽移交其他玩家 撕警徽：投票处决警长，白天被票死不可移交警徽，故称“撕警徽” 警徽流：一般都是预言家拿警徽，警徽流表示预言家打算验人的顺序，警徽流可以让好人多一轮验人信息。 这里主要想说一下警徽流。假如没有警徽，狼人杀死预言家，预言家是没有遗言的（第二天开始，夜里死的人没有遗言），那预言家昨晚的验人就报不出来。所以有警徽流的话，验出好人，把警徽给他；验出狼人，把警徽给你之前验的好人或者撕掉。而为了防止狼人两连爆（比如，自曝刀预言家，被女巫救起来，再自曝一个继续刀，这样就会有两轮验人），一般会留两轮警徽流，示例发言：“警徽流先 3 后 5”或者“先验 3，再验 5”。验出一个好人一个狼人，警徽给那个好人；验出两个狼人，警徽外置位随便给（因为已经有两个狼人了，外置位好人多，狼人少，给到好人概率大）；如果验出两个好人，警徽撕掉（因为已经两个好人被验出，外置位狼多好人少）。所以预言家一定要尊重自己的警徽流，不要擅自修改。 逻辑狼人杀是一个有一定逻辑分析的游戏，里面有各式各样的逻辑，正逻辑、反逻辑、一重逻辑、多重逻辑，等等。有些是铁逻辑，有些则是“伪逻辑”。 基本逻辑这个游戏只有一个逻辑是铁逻辑：真预言家 验出的金水，一定是好人，查杀一定是狼人。其他的东西都是可以正反解读的。所以游戏的关键，在于找准真的预言家，并以此为你的逻辑基点进行分析，一旦预言家找错了，后面的分析都是错的。 身份的高低：A 发 B 金水，那 B 的身份一定比 A 高，要出 B 之前一定要先出 A，理由很简单，觉得 B 是狼人的话，那 A 发的是假金水，则 A 一定焊跳狼而非预言家，得死在 B 前面。但 A 发 B 查杀，就不一定了，因为狼和预言家都可以发查杀。 正反逻辑新手常犯的错误就是把“伪逻辑”当作“铁逻辑”，比如 A 查杀了 B，B 自曝，那 A 一定是好人？不一定，因为 A 是预言家可以查杀 B，A 是狼人也可以查杀自己狼队友 B，做好自己身份。但相反，A 跳预言家且从未脱衣服，发 B 金水，结果 B 自爆，那 A 一定是狼人。 再比如：你是女巫，A、B 都跳了预言家 ，狼人 C 跳了一个女巫站队 A，你就觉得 B 是真预言家，A 是假的。一定吗？不一定，这只是正逻辑，还有反逻辑。因为 C 是不是狼、站队谁，和 A、B 谁是预言家一点关系都没有，C 完全可以故意站队真预言家 A，使你这个真女巫站到狼人 B 的队伍，这样他的目的就达到了。这招通常叫做“阴阳倒钩”。 类似的例子还有很多，新手往往只盘一层逻辑/正逻辑，而不盘反逻辑，比如 A 把 B 聊爆了，A 就是好人；另一种新手是只盘反逻辑，不盘正逻辑，比如总喜欢盘狼自刀（正逻辑就是夜里被刀的是好人）。这两种都是不对的，一个高手，应该正反逻辑都盘，综合判断后做出决策 。 下面聊聊 多重逻辑。其实狼人杀只有两层逻辑，正和反。反逻辑再进一层，就是所谓的三重逻辑，其实就是正逻辑了。比如，上文的“阴阳倒钩”，打多了的话，再有狼人 C 站队 A，你就会觉得 A 是预言家，狼人C 故意站队 A 来让你站错队（盘的反逻辑），那狼人可以反其道而行之，就明目张胆站队自己狼队友 A，打冲锋，在思维层级上属于第三层了，但从结果上看，就回到了新人都知道的最简单的正逻辑：C 是坏人，站队 A，那么 A 是坏人。当然这个推理并不是铁逻辑，因为 A、C 的身份是独立事件。 所以狼人杀的逻辑，无论往上怎么叠加，化简之后，就是两层：正逻辑和反逻辑，看你信哪个罢了。高手的厉害之处就在于，能够洞悉在场每位玩家的思维层级，然后用高你一级的思维层级来发言，让你站错队、投错票。 心态视角既然逻辑有正有反，那怎么才能去伪存真呢？主要就是看心态和视角。 轮次首先，简单说一说“轮次”的问题，由于游戏结束条件极端情况下最快是“死 4 个人”，比如第一夜狼人杀了真预言家，白天把猎人投票出局，开枪带走女巫，第二天夜里再杀死白痴，游戏就结束了，这就是好人雪崩的对局。所以一般正常的进度都是狼人晚上杀“神牌”，好人白天投出去“狼人牌”。如果没有神牌没有毒药或者开枪等技能的话，就会杀一个神牌(或者村民)，投一个狼人…如此循环四次，总是先死好人，再死狼人，直至狼人杀死最后一个神牌(或者村民)，狼人一定赢。为了提高好人胜率，所以才有了毒药/开枪 等帮助好人抢轮次的功能。特别是女巫，可以追两个轮次（救一个人，毒一个人，各是一个轮次）。 狼人的游戏目的就是找出所有的神牌，杀死他们就赢了；好人的目的是找出所有狼人，投票/开枪打死/毒死，好人就赢了。一般优先杀 4 个神而不是 4 个村民，因为通常预言家必死，所以至少有一刀要用在预言家身上，如果刀民，就需要 5 刀，刀神只用 4 刀，不过特殊情况下也会刀民，比如女巫和猎人都弄死的是村民，或者刀神轮次不够，需要狼人混在民坑里，这时狼人可选择找民刀。 所以，很多新人打到最后都不清楚还剩几只狼人，觉得谁发言不好就投谁，处于懵逼状态，很容易被狼人蒙混过关。一旦算清楚轮次的话，把铁狼和疑似狼人出局的 X 身份算清楚，看看场上最好和最差情况分别是几只活狼，有助于对局势的把握；同理，狼人一旦发现狼人比好人多，或者最后的神牌已经确定的话，也没必要装了，直接绑票或者爆刀就行了。 一般的轮次顺序是：有查杀优先走查杀，对跳的神牌下轮再说，优先票明狼，再票冲票狼，最后是倒钩狼。如果搞不清轮次，可能会被狼人绑票投出好人。比如 A、B 跳预言家分别发 C、D 查杀，E、F 都跳白痴，且明显 E 像假白痴。这时肯定是 C、D 的轮次，要么信 A 出 C,要么信 B 出 D，F 是真白痴也不要投 E 分票。同理，如果 A、B 跳预言家分别发 C、D 金水，那么就是 A、B 的轮次，因为金水身份高于发他金水的预言家，这时就不要什么“两个预言家分不清，我们都留一轮，外置位投”了，就是拉开阵型站边搏杀了。 状态最简单的是看预言家发言的状态，一般真预言家发言更轻松，焊跳狼则会紧张，这属于比较明显的心态对比。再比如一个人拿了神牌往往底气比较足，一副老子很牛逼的态度，想 carry 好人，各种指点江山，这个角度仅供参考。还有，一个神牌被别人穿了自己的衣服，往往是很抵触的，会去关注和质疑那个人。 可能有些人比较看状态，但状态这个东西可以演，更有所谓的“情绪式发言”，所以我不太看，我更看一个人发言的逻辑和视角。 视角视角这个东西，模仿起来难度比较高，需要你换位思考，身临其境地模拟别人，看看你在他那个位置，会发出什么样的言，如果他的发言和你出入过大，那可能有问题。这就需要你首先对各种角色都玩过，能够再现自己拿那个牌时在那个情景下的心态和心路历程。 比如一个预言家第一轮就在站边自己的人里盘倒钩狼，不敢打和自己作对的人，大概率是狼人焊跳，怕打到好人让好人产生逆反心理导致树敌太多，于是打站边自己的狼队友。比如狼人会默认吃刀的人是好人，不敢打（女巫可以知道，当然，狼人也故意猛打银水来装自己不知道夜里刀形，就涉及正反逻辑的判断了）。比如一个被查杀的人跳女巫，是拿毒威胁，疯狂踩全场，连银水都不报；还是万念俱灰，全程劝好人回头，讲清楚自己救人的心路历程。 狼人由于夜里吃信息，所以发言时会不自觉的透露一些闭眼村民不知道的信息。比如不小心透露出刀形，像一夜双死，不知道谁被刀谁被毒，他却知道；或者明显的谁被刀谁被毒，可以分析出来的，却闭口不谈，担心暴露自己，等等。 还有就是整个游戏的连贯性和故事性。不是逮着谁发言最差就投谁出去，而是要结合整个游戏的进程，弄清楚各个玩家之间的关系，因为好人可以发言很差，狼人可以发言很好，每次都需要联系前几轮 每个人的发言的关联 以及 每个人每一轮发言的差别 综合判断。例如明显场上还剩最后两狼一神了，这时有个前几轮发言很低调划水的人突然说自己是最后一神，要带票投 xx，你觉得他是挡刀概率大，还是找神刀的概率大？再比如一个人发言巨烂，被全场踩，他是一个要被抗推的好人，还是连狼队友都不要他的弃狼？ 这个东西更多靠实战领悟，简单举例也不太好讲清楚，所以只是抛出这个角度供大家思考。 结语狼人杀是一个老少咸宜的游戏，虽然本文通篇都是介绍狼人杀的“规矩”和“套路”，但我觉得游戏不按固定章法去玩也是别样的体验。希望高阶玩家可以对新人可以友好一点，大家玩的开心就好，不要因为新人没有“遵循规矩”而嫌弃或者喷人。当然，竞技向的话，狼人杀其实还涉及很多技巧，比如位置学、心理学、微表情、洗脑传销式发言等等，我还没有特别深入的钻研，以后有机会会慢慢学习，不断进步。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://brianway.github.io/tags/随笔/"}]},{"title":"如何准备校招技术面试","date":"2017-09-28T21:16:07.000Z","path":"2017/09/29/2017-09-29-how-to-prepare-a-technical-interview /","text":"2017 年互联网校招已近尾声，作为一个非 CS 专业的应届生，零 ACM 经验、零期刊论文发表，我通过自己的努力和准备，从找实习到校招一路运气不错，面试全部通过，谨以此文记录我的校招感悟。 写在前面写作动机 记录自己的经历、反思与总结 在互联网上看到了很多前人的经验帖，作为回馈，也分享自己的经验 赚一点打赏(可扫描我个人网站里的二维码 http://brianway.github.io/about/) 你可以从这篇文章获取哪些信息 如何看待校招面试 以 后台研发 为例，校招技术面试的考核范围和难度 如何提升自己的技术内功(长期) 如何有针对性地做面试准备(短期) 面试交谈中的一些技巧 一线互联网公司的校招面试流程 这篇文章不能带给你什么 本文并不是速成宝典/突击手册 本文不会罗列面试原题和题解 我的面试经历春招找实习，投了三家（阿里，腾讯，美团），全部拿到实习 Offer，去了阿里。 阿里：菜鸟网络；3 面技术电面 + 1 面 HR 视频面。二面布置了一个工程小作业，做了两天 腾讯：投的后台开发(事业群无意向)，被转到 SNG 运营开发；简历评级 S，2 面电话面试 + 线路现场面试 2 面技术 + 1 面 HR 美团：美团餐饮平台；2 面电话面试 + HR 直接通知 offer。历时一周多，最效率 秋招为了稳妥地转正，拿一个好的评级，在专心准备转正面试，错过了提前批，正式批投了五家，面了三家（阿里，腾讯，网易），基本都是 special offer： 阿里：菜鸟网络；成功转正，评级不错 腾讯：投的微信 Web 开发，被调到 IEG 后台开发(不知道为什么多了一个阿里实习，我的简历评级反而从 S 变成了 A+)；在线笔试 + 现场 2 技术面 + 1 HR面。HR 面时我期望薪资提的 sp 的价格，offer 报批中。 网易：跨境电商(考拉海购)；在线笔试 + 现场 2 技术面 + 1 HR 面。HR 说技术面评价不错，问题不大。结合身边同学，我应该是 sp。网易面试体验最好，面试官(尤其一面那位)很专业，很佩服 头条(放弃面试)：来校园宣讲，免笔试直接面试，没去 网易游戏(放弃面试)：计费应用系统开发；电话通知笔试过了，手里有 3 个 offer 了，就主动告知不面了。 如何看待校招面试招聘，对公司而言，是寻找劳动力；对员工而言，是寻找未来的同事。所以考核的东西肯定有如下几点： 技术能力：招你进来是干活的，公司不是慈善机构，不养闲人，所以你需要 证明你能胜任这项工作 学习能力/潜力：要能干活的走社招就行了，应届的优势就是潜力，你得 向公司证明值得培养你 软技能：招你进来是和其他人共事的，所以为人处事、沟通能力、是否合群、三观等等， 你的“调性”要和公司/组里的吻合 所以很多人挂的原因就很明显了：技术能力不佳，挂；看不到学习的悟性，只会已有技能，挂；聊天思路不清晰，沟通障碍，挂………… 当然，招聘本来就是一个双向选择的过程，公司在选择你的同时，你也在选择公司，比如工作要拼还是要 balance，这种事见仁见智。 技术面试考核的技术范围虽然面试考核的东西很多，但技术面试最主要的还是考核技术能力，记得学长告诉过我：“技术基础和项目经历，至少得有一个拿得出手”，所以下面谈谈所谓的“技术基础”。 我投的所有岗位都是 Java 研发，所以就以 Java 研发为例，以文字的形式写出大致的知识图谱/思维导图。很多我就只点到为止，不可能面面俱到。 算法和数据结构基础 数据结构：数组，链表，哈希表，堆，队列，栈，二叉树，B树/B+树，红黑树，图(研发问图不多) 常见的排序算法(冒泡，插入，快排，堆排，归并排序…) 简单的动态规划问题(背包，上楼梯) 各种时间空间复杂度分析 Java 基础 最基本的语言基础：语法，关键字含义，面向对象…. 集合类(ArrayList, HashMap, ConcurrentHashmap…等等) 多线程(锁，CAS，线程池，concurrent 包下的类) 语言特性：反射，动态代理，泛型，Java 8 新特性 IO (装饰器模式，NIO) JVM：内存模型，垃圾回收，类加载机制 Java Web Tomcat，Servlet，JSP，Cookie/Session 等基本概念 框架使用和原理：Spring(AOP，IoC)，MyBatis 等 数据库(主要是 MySQL) 基本 SQL 语句，索引优化 存储引擎(InnoDB，MyISAM)，索引原理 事务 ACID，隔离级别 分库分表，主从复制，读写分离 计算机网络 OSI 7 层模型和 TCP 4 层模型 传输层：TCP/IP 相关知识，和 UDP 比较 HTTP 协议：报文结构，POST/GET 方法 网络编程 (socket, NIO, select 等) 操作系统 基本 Linux 的操作指令 进程/线程比较，进程间通信方式，P/V 操作 磁盘调度，虚拟内存 死锁，中断 1.这么多东西，从哪学起呢？ 我自己的学习路线规划：技能的主线是 Java 语言基础 -&gt; Spring 框架开发业务 -&gt; 分布式系统解决高并发，基础方面 算法，网络协议，操作系统 带着学 2.学到什么程度呢？ 概念性的程度：了解是啥，能够口述含义 使用的程度：可以熟练使用，比如调用 API，写 SQL 查询 原理的程度：能够讲清楚底层实现 提出见解的程度：从任意技术可以引申出相关技术，并能够分析联系和区别，提出自己的见解和体会 以上四种程度逐层加深，当然越深越好，通常前两种程度只能称之为“了解”；而写上简历迎接考核的，至少需要掌握到「原理」的程度。 比如，Java 你至少得看过常用类的 JDK 源码；数据库只会增删改查肯定不够，起码得把底层索引结构讲清楚；常见算法起码能讲清楚关键步骤，分析时间空间复杂度，并且 bug free 地写出来。 技术储备是一切的基础，如果基础都不会，那后面的简历撰写，临场引导面试官等技巧根本无从下手，只有被虐的份 如何提升自己的技术内功“冰冻三尺非一日之寒”，功夫在平时，与其背面经寄希望于碰原题，不如扎实学习，以不变应万变。 可以通过 看书＋记笔记 的形式来学习，书上的代码可以对着敲一敲，学习笔记和代码可以发到 GitHub 上，用来展示自己的学习热情。 下面是我这一年多来看过的书，每一本我读之前都做了充分的调研和筛选，豆瓣评分一般都在 7~9 分： 《算法》（第四版）图以前章节 《剑指 Offer》 《Java 编程思想》 《Java多线程编程核心技术》(高洪岩 著) 《Java 并发编程实战》 《深入理解 Java 虚拟机》 《Java 8 实战》 《鸟哥的 Linux 私房菜》 《MySQL 必知必会》 《Maven 实战》 《图解 HTTP》 《敏捷软件开发》 《架构探险－从零开始写 Java Web 框架》 《Spring 3.x 企业应用开发实战》 《Head First 设计模式》 《大型网站技术架构》（李智慧 著） 《大型网站系统与 Java 中间件实践》 少看了一本《深入理解计算机系统》，所以被问到系统相关问题就很虚。 附上买书的截图 书1 书2 我整理了一些学习笔记和源码： Java 语言基础的学习笔记可以参考我的 GitHub 仓库：java-learning 算法主要就是刷普林斯顿的算法公开课(偏重数据结构)和牛客网的课程《算法面试精品课》，我整理的博客和每一题成功提交的源码：algorithms-learning。后来才发现，70% 以上都和《剑指Offer》重复。 框架主要就是看视频，整理的学习笔记：springmvc+mybatis学习笔记(汇总) 如何有针对性地做面试准备首先 最重要的就是写简历，找工作就像相亲，简历就是颜值，在这个看脸的社会，只有长得过关，别人才愿意深入发掘你。从我面试的感受来说，通过与否，简历可以占到 50% 以上。 建议尽早的开始准备简历，因为写简历时才会发现自己的简历没什么东西可写，才会有一种危机感。如果等到校招才开始写，就晚了。 怎么写一个好的简历网上很多帖子，就不赘述了，这里简单说几点： 亮点：名校本硕，专业排名，大赛获奖，名企实习。（如果一个没有只能自求多福） 技能：这些可能是面试官的提问点，不熟别写 项目：技术栈，难点，贡献/产出 事实：一万句“我学习能力很强”不如一句“我专业排名第一”，一万句“我爱打游戏”不如一句“我王者农药打了 1000 多盘，每天投入 4 小时以上” 项目经历的提炼可以从以下几个方面着手准备，这些问题都可以事先想好，多口述演练，以免临场紧张出错 基本问题 项目简介 项目详解 项目用到的技术 开放问题 遇到的困难及解决 项目的优缺点及改进 收获 没有项目经历可以自己找找开源的项目做，或者找一些自己感兴趣的方向做一些玩具项目，世上无难事，只怕有心人。 面试技巧面试本质是信息沟通，是你向面试官展示你能胜任这个岗位，而不是一问一答。你应该尽量主导面试，引导面试官，而不是被动答题。即便同一个众人皆知的问题，也不应止步于答出来即可，要争取尽量回答的和别人不一样，展现出自己独到的研究和体会。 所以很多人疑惑：为什么我每一问都答上来了，为啥还挂了？多半就是自我感觉良好，其实答的不咋样，或者就是被面试官牵着鼻子走，给人一种是在背面经的感觉。其实很多问题没有标准答案，面试官看的是你解决问题的思路，思考问题的方式，而不是这个问题答案是什么 我从自己被问过的问题和反思中简单说几点： 1.不止步于问题，多展示自己会的 比如最经典一个问题：输入一个网址到看到页面，经历了哪些过程。如果只是回答 DNS，OSI 的几层协议，那格局未免太小，同时会把面试官引导往网络协议提问，接踵而至的可能就是 TCP/IP(三次握手，TIME_WAIT，滑动窗口)，HTTP(keep-alive，HTTPS)等一系列协议细节，就把自己的展示机会限制在很小的范围了。 而这个问题其实可以从网站架构的层面先宏观描述，如 DNS，负载均衡，静态页面/动态页面，数据库访问，缓存，甚至前端的浏览器渲染等等，这样你可以聊得东西就很多，同时证明你有实际的项目经验，知道业界是如何做的，然后再回头把网络层面的东西简单提一提。 再比如被问到有哪些 hash 方法？因为一般都是问哈希冲突解决方法，很多人会说开放地址法，链表法等等。至于 hash 方法，真的有点懵逼，凭下意识说了一个取模(取余数)，答到这肯定不够，于是我把 Java 几个基本类型的包装类 Integer, Boolean, String 的 hashcode 方法的实现说了一遍，一方面作为例子填充回答，另一方面，表示我研究过 JDK 源码 2.结合例子，不要背书 譬如，被问到 AOP，IoC 这些概念时，不要官方的解释背一遍，最好结合自己的使用经验，把使用场景和感受到的好处说一下，会比较生动。 3.从更高的层面去总结和阐释问题 之前被问到“倒排索引”的问题时，我只是举了个例子把这个概念讲清楚了，后来觉得并不是太好，只是停留在解释的层面，如果能首先提纲挈领的来一句“一般的索引，是文档到单词的映射；而倒排索引，是单词到文档的映射”，整个回答的高度就不一样了。 再比如“二叉树搜索和哈希查找的区别”，如果能答出搜索二叉树是基于比较的排序，所以时间复杂度为 O(log n)，哈希查找是一个函数映射，所以能做到 O(1)，说明你不是背面经的。 4.不会的先把丑话说在前面 面试中难免会遇到不会的，这时千万不要不懂装懂，如果觉得有想法、能说一点，可以先坦诚承认自己不会，但愿意尝试回答一下，这样即使说错了，也不会被怼，因为你已经把场子捡开了。 比如当问到“JVM 如何标记要回收的内存”，我其实记不得了，就说不清楚，但标记无非就那么几种方法，所以提了两种：要么在每块内存留一点标识位(比如一个字节)来标识，要么另外用一个调度表之类的存储结构来统一记录和管理。这样还可以和面试官进一步交流学习。 5.复盘反思 每一场面完都要反思总结，看看哪里答得不好。如果是知识性的缺陷，就赶快补起来；知道答案但答得不好的，就重新组织措辞和表达方式；即使是回答上来的，也可以反思一下如何答得更好。 当然，所有技巧的前提，是认真踏实的基础准备 一线互联网公司的校招面试流程 笔试 我觉得很多公司的笔试是过场，主要还是根据简历刷人。因为我笔试从来没全部 AC 过，但都通过笔试了，认识的一些朋友三题 AC，却没过笔试。 电话面试 有的大公司会全程电话面试(如阿里)，有的是先电话面试筛选简历，然后通知现场面(如网易)。电话面试的好处就是不用手写代码，缺点就是语言很多时候传递的信息是不够的，很多面部反馈、手势和图例都无法展示。 现场面试 大多数公司还是会安排现场面试，要么安排你去公司面试（大公司会报销路费），要么安排公司员工到你学校来，通常就是 2 面技术面＋1 面 HR 面 。每个公司风格不同，比如腾讯一般是一天一面，战线有三天，而网易是一天面完。 另外，其实校招的战线已经从每年的 9 月份提前到了 3 月份，尤其是阿里，实习生留用会占很大一个比例。所以希望认清紧迫的形式，越早准备越好。3 月能不能找到一个好的实习，对找工作影响还是挺大的，毕竟，如果没实习经历，那面试只能全程怼基础了，而基础是个无底洞。而且，手里是否有一个保底的转正 offer，你面试的心态是不一样的。 一些建议 简历越早投越好：就像《中国好声音》导师转椅子一样，刚开始觉得不错的就啪啪啪四转，后来坑不够了，越来越纠结 只投一种岗位：我全程只投了“Java 研发岗/服务器端开发”，这样可以统一准备，避免战线过长 分梯度精投几个公司：不要海投，这样会疲于奔命，劳民伤财还没有时间准备。可以根据自己的能力，投几个不同档次的公司（如：高于自己水平的，希望比较大的，很有把握的，这几档），争取拿到保底的，冲刺心仪的，而不是看到一个公司招人就去面试。 最后祝各位找工作顺利，这篇文章主要是写给学弟学妹的，希望尽早重视起来，开始准备。如果读完觉得有收获的话，欢迎给我打赏(http://brianway.github.io/about/)","tags":[{"name":"随笔","slug":"随笔","permalink":"https://brianway.github.io/tags/随笔/"}]},{"title":"常见算法基础题思路简析(六)-字符串篇","date":"2017-09-28T05:46:07.000Z","path":"2017/09/28/2017-09-28-algorithms-common-6-string/","text":"本文对和 字符串 有关的常见算法基础题思路分类进行分析和总结，并以 Java 为例，适当指出需要注意的编程细节 相关题目和代码在 GitHub: https://github.com/brianway/algorithms-learning 题目见 com.brianway.learning.algorithms.lectures.string包 最长无重复字符子串题目见 DistinctSubstring 思路：对于每个字符，向左延伸找无重复子串，要知道该字符(记为 s[i])上次在哪个位置出现过，还要知道之前其他字符中出现过重复且最近一次出现重复的那个位置 pre，则以 s[i] 结尾的向左最长无重复的长度为: s[i] 上次出现位置和 pre 中较大者到现在 s[i] 的距离。 1234567891011121314151617//例子1i:0 1 2 3 4 5s:b a c b a di=4 =&gt; s[4] = a, pre = 0(b 重复了),map[a] = 1(a 上次出现在 i=1) =&gt; cur = 4-1 = 3, 即 cbai=5 =&gt; s[5] = d, pre = 1(a 重复了), map[d] = -1 =&gt; cur = 5-1 =4, 即 cbad//例子2i:0 1 2 3 4 5s:a b c b a di=4 =&gt; s[4] = a, pre = 1(b 重复了), map[a] = 0(a 上次出现在 i=0) =&gt; cur = 4-1 = 3, 即 cbai=5 =&gt; s[5] = d, pre = 1(b 重复了), map[d] = -1 =&gt; cur = 5-1 =4, 即 cbad 使用一个哈希表 map[256] 来记录每种字符之前最新出现过的位置。 使用一个整型变量 pre 来记录以 s[i-1] 结尾的字符串向左延伸且无重复字符时的最左下标(不包括该下标)。 对字符串中每个字符 s[i] 进行如下操作： 对字符串中每个字符，找出 pre 和 map[s[i]] 中的较大值并更新为 pre 以当前字符 s[i] 结尾向左无重复的长度则为 cur = i - pre 根据这个 cur 和历史最大长度比较，更新最大长度 更新 map[s[i]] 为 i 注意： map 中每个元素和 pre 均初始值为 -1 有个现象：当未出现过某字符且字符均未出现过重复时，pre 和 map[s[i]] 均为 -1, cur = i+1，cur 随 i 递增 拓扑结构相同子树题目见 IdenticalTree 思路： 使用特殊格式打印的二叉树中序遍历结果时唯一的，打印两个树的中序遍历字符串 使用 KMP 算法进行子串匹配，能匹配则 注意： 中序遍历时，空节点也要打印，所有值要以特殊字符结尾以免歧义 KMP 的原理、实现以及小优化 字符串匹配的KMP算法 从头到尾彻底理解KMP 合法括号序列题目见 Parenthesis 思路：每个右括号出现时必已有一个左括号与之对应，计数即可，正负抵消。对每个元素进行如下操作： 遇到非括号字符返回 false 遇到左括号则计数器加一 遇到右括号则计数器减一，计数器为负值则返回 false 循环结束计数器值为零则 true，否则 false 拼接最小字典序题目见 Prior 思路：排序不是以单个字符串来比较，而是把待比较的两个字符串(记为 sa 和 sb)拼接起来进行比较，即比较 sa+sb 和 sb+sa 的字典序 注意： 由于两个串无论什么顺序拼接，拼接后字符串长度相同，所以无论谁在前，拼接后的串对其他字符串影响是一致的 空格替换题目见 Replacement 思路： 先统计下空格数量，分配空间 直接逐个字符复制，遇到空格就替换即可 注意： 新的字符串长度为 length + 2 * count，length 为原字符串长度， count 为空格个数，%20比空格多了两个字符 句子逆序题目见 Reverse 思路： 先对整个字符串反转 再对以空格分隔的每个单词反转 注意： 能做到 in place 反转，无需额外空间，有点像“负负得正” 每个单词反转是以其末尾的空格触发的，所以对最后一个单词，需要单独判断处理 两串旋转题目见 Rotation 思路： 判断两串是否长度相等 将原串与自身拼接，看另一字符串是否是拼接串的子串即可 词语变形题目见 Transform 思路： 判断两串长度是否相等 遍历 A 串，统计 A 串中每种字符出现的次数（计数累加） 遍历 B 串，做 2 中的统计结果做减法，若 B 中出现了 A 中未出现的字符或者 B 中某种字符出现次数比 A 多（表现形式为：减 1 前 counts[b[i]] == 0），返回 false，否则 true 注意： 遍历 B 串不是计数累加而是利用 A 的结果 字符串移位问题题目见 Translation 思路：以移位长度为分界点，分别将各部分对其中轴线做镜像反转，再对整个字符串以其中轴线做镜像反转。 将下标 0 ~ len-1 的字符反转 将下标 len ~ n-1 的字符反转 将整个字符串 0 ~ n-1 反转 注意： 无需申请额外空间 各部分做了两次镜像反转，所以内部保持相对顺序不变","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brianway.github.io/tags/数据结构/"}]},{"title":"常见算法基础题思路简析(五)-队列和栈篇","date":"2017-09-28T05:45:07.000Z","path":"2017/09/28/2017-09-28-algorithms-common-5-stack-and-queue/","text":"本文对和 队列和栈 有关的常见算法基础题思路分类进行分析和总结，并以 Java 为例，适当指出需要注意的编程细节 相关题目和代码在 GitHub: https://github.com/brianway/algorithms-learning 题目见 com.brianway.learning.algorithms.lectures.stack包 构造 MaxTree题目见 MaxTree 思路：使用一个栈来储存某个元素左边比它大的元素的下标，该栈满足这样的特性：栈中每个元素 m 以及 m 出栈后的栈顶元素 peek，总有对应的数组值 arr[peek] 为 arr[m] 向左数第一个比它大的数组值。下面的 1～3 步只是为了使栈保持这个特性。 对数组中每个元素，执行如下操作： 将当前元素与栈顶元素对应的数组值进行比较。如果栈非空且栈顶元素对应的数组值小于当前数组值，则出栈，并根据当前数组值与出栈后栈顶元素对应的数组值相对大小来赋值结果数组。一直执行该操作直到循环结束 将当前元素下标对应的结果数组赋值 栈为空则赋值为 -1 栈非空则赋值为栈顶元素 将当前元素下标入栈 注意： 第 1，2 步中，比较时注意岀栈后栈为空的情况 滑动窗口题目见 SlideWindow 思路：使用一个双向队列来存储当前窗口里可能称为最大值的备选元素的下标。每次从头部取最大值，从尾部删除非备选项。 对数组中每个元素，循环进行以下操作： 从双向队列尾部依次删除对应数组值小于当前数组值的元素，并将当前元素下标加入队列尾部 判断队列头部下标是否已经不在窗口内，若过期则删除 此时的队列头部元素对应的数组值即为滑动窗口内的最大值 注意： 尾部的为最新的值，头部的为较老的值 删除时注意队列为空的情况 得到栈最小元素题目见 StackMin 思路：使用两个栈，一个数据栈，一个最小栈，每次入栈和岀栈时，同时更新两个栈即可。 注意： 入栈：最小栈为空或者新元素 小于等于 其栈顶元素时才入栈 岀栈：最小栈栈顶元素等于数据栈栈顶元素时才出栈 栈的反转题目见 StackReverse 思路：利用递归函数和栈本身的 pop 操作来实现反转，分三步 取出栈底元素 弹出栈顶元素 current 若此时栈为空，说明已是栈底元素，则返回 current 若此时栈不为空，则取剩下的栈的栈底元素 last，并将 current 压入栈中，返回 last 反转剩下的栈 将底部元素压入栈顶 注意： 反转栈和取出栈底元素这两个操作都是个递归调用 双栈实现队列题目见 TwoStack 思路：使用一个数据栈，一个辅助栈。两次“后进先出”的最终结果就是“先进先出” 先将数组元素按顺序压入数据栈 再将数据栈中的数据全部依次弹出并压入辅助栈 从辅助栈中依次弹出栈顶数据即可 注意： 数据需要在两个栈中全部腾挪一遍 因为先进先出，无论什么时候出队，结果一样，所以无需按输入顺序一个一个出队，只用统计出队次数，一次性出队即可 双栈排序题目见 TwoStacks 思路：使用一个辅助栈，该辅助栈中的元素永远保持升序排列（即大的元素在栈顶）。简单来说就是每次将数据栈中的元素压入辅助栈，使得该元素位于辅助栈栈顶且最大，所以辅助栈若已有更大的元素，则回压给数据栈即可。进行如下的操作来是辅助栈保持这个特性，有点类似“插入排序” 每次从数据栈弹出栈顶元素 m，依次和辅助栈的每个栈顶元素比较大小，若辅助栈栈顶元素较大，则将辅助栈栈顶元素压入数据栈，直到辅助栈为空或者 m 大于辅助栈栈顶元素为止 将该元素 m 压入辅助栈中","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brianway.github.io/tags/数据结构/"}]},{"title":"常见算法基础题思路简析(四)-二分搜索篇","date":"2017-09-28T05:44:07.000Z","path":"2017/09/28/2017-09-28-algorithms-common-4-binarysearch/","text":"本文对和 二分搜素 有关的常见算法基础题思路分类进行分析和总结，并以 Java 为例，适当指出需要注意的编程细节 相关题目和代码在 GitHub: https://github.com/brianway/algorithms-learning 题目见 com.brianway.learning.algorithms.lectures.binarysearch包 求完全二叉树的节点个数题目见 CountNodes 思路： 计算根节点到最左节点的高度 h 同理，计算根节点到其右孩子的最左节点的高度 hr 如果 h &gt; hr，则节点个数为：根节点右子树的节点数+1(根节点)+根节点左子树的节点数 如果 h &lt;= hr，则节点个数为 根节点左子树的节点数+1(根节点)+根节点右子树的节点数 注意： 计算 hr 时，current = root.right, 初始值为 1（代表根节点） h &gt; hr，说明右子树为满二叉树，高度为 h-2，根节点右子树的节点数+1 可直接计算,为2^(h-2) 同理，h &lt;= hr，说明左子树为满二叉树，高度为 h-1 最左原位题目见 Find 思路：类似二分搜索，当 a[i]=i时终止，有序数组且元素各不相等，所有 a[i] 每次的增量是要大于下标 i 每次的增量 1 的。 判断边界条件 lo = 0, hi = n-1，开始二分搜索 若 a[i] &gt; i，则 任意 j &gt; i，有 a[j] &gt; j，所以只可能出现在左半部分，故 hi = mid - 1 若 a[i] &lt; i，则 任意 j &lt; i，有 a[j] &lt; j，所以只可能出现在右半部分，故 lo = mid + 1 注意： 边界条件：arr[0] &gt; n - 1 || arr[n - 1] &lt; 0 时无解，直接返回 最后求得 arr[mid] ＝ mid -&gt; res ＝ arr[mid] 后，记得赋值 hi = mid - 1 ，且不能跳出循环，因为要找 最左原位，所以需要继续循环下去。 元素最左出现题目见 LeftMostAppearance 思路：这里就是一个简单的二分查找，唯一不同的是，当 arr[mid] ＝ num 时，不是在 res ＝ mid 后直接退出循环，而是需要赋值 hi = mid - 1 继续循环 局部最小值位置题目见 LocalMin 思路： 判断两端边界情况，满足条件（arr[0]&lt;arr[1] 或者 arr[n-2]&gt;arr[n-1]）则直接返回结果 判断 arr[mid] 和 arr[mid - 1] 的大小，若 arr[mid] 大，则一定有个局部最小出现在左边 否则，判断 arr[mid] 和 arr[mid + 1] 的大小，若 arr[mid] 大，则一定有个局部最小出现在右边 若都不满足，则局部最小为 arr[mid] 注意： 注意数组为空，长度为 1，以及其他边界情况 思路中 2，3 步的依据就是，先有 1 中段边界判断，所以一定有两端元素大于其紧邻元素（arr[0]&gt;arr[1] 且 arr[n-1]&gt;arr[n-2]）。数组要么一直递减到边界的紧邻元素从而结束循环，要么在这个过程中遇到某个局部最小，所以一定是有解的。 循环有序数组最小值题目见 MinValue 思路：循环有序数组截出一个连续的子数组还是循环有序的。在每次循环中进行一下判断： 若 arr[lo] &lt; arr[hi]，说明子数组已经升序，直接返回 arr[lo]。 否则，说明数组不升序，进行下面的步骤 若 arr[lo] &gt; arr[mid]，最小值出现在左半部分 若 arr[lo] &lt; arr[mid]，最小值出现在右半部分（因为说明 arr[lo] ~ arr[mid] 是升序的） 若 arr[lo] ＝ arr[mid]，最小值为第一个小于 arr[lo] 或者就是 arr[lo]本身 注意： 注意可能有重复元素的问题，所以在遇到 arr[lo] = arr[mid] 时，需要遍历 lo ~ hi 之间的元素来找到最小值 这里的左右指针更新需要注意，hi = mid 和 lo = mid,而不是 mid-1 和 mid+1,因为不能漏掉元素 快速N次方题目见 QuickPower 思路：求出 k 的 1，2，4，8….次方作为中间值 tmp，减少相乘的次数 每次把 N 右移一位，若该位为 1，则将结果乘以中间值 tmp 每次令中间值 tmp 等于自己的平方（对应于第一步中的位移操作） 注意： 注意越界问题，按题目要求，求 mod 某个数后的结果","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brianway.github.io/tags/数据结构/"}]},{"title":"常见算法基础题思路简析(三)-二叉树篇","date":"2017-09-28T05:43:07.000Z","path":"2017/09/28/2017-09-28-algorithms-common-3-binarytree/","text":"本文对和 二叉树 有关的常见算法基础题思路分类进行分析和总结，并以 Java 为例，适当指出需要注意的编程细节 相关题目和代码在 GitHub: https://github.com/brianway/algorithms-learning 题目见 com.brianway.learning.algorithms.lectures.binarytree包 判断是否为平衡二叉树题目见 CheckBalance 思路： 判断左子树是否为平衡二叉树，是则返回高度，不是返回 -1 判断右子树是否为平衡二叉树，是则返回高度，不是返回 -1 若左右子树均时平衡二叉树，则看两者高度差是否大于 1。是则返回 -1，不是则取两者中大的再加上 1 注意： 这里对返回值意义复用了，非负数则表示高度，负数表示不是平衡二叉树 判断是否为完全二叉树题目见 CheckCompletion 思路： 使用队列，按层遍历二叉树，分以下几种情况依次判断： 如果只有右孩子，返回 false 如果已经遍历过最后一个非叶子节点，当前节点还是非叶子节点，返回 false 如果左孩子非空，入队 如果右孩子非空，入队；如果右孩子空，表示该节点应为最后一个非叶子节点 若遍历完，则是完全二叉树 找出搜索二叉树中换位的两个节点题目见 FindErrorNode 思路： 中序遍历二叉树，找到出现降序的节点。第一次出现降序的较大值为换位的两个节点中的较大值，最后一次降序的较小值为换位节点中的较小值 注意： 可能出现一次降序，可能出现两次降序。 若出现一次降序，则这两个值就是换位节点； 若出现两次降序，则第一次降序的较大值和第二次降序的较小值为换位节点 可以用非递归方式中序遍历二叉搜索树来实现 打印纸的折痕题目见 FoldPaper 思路： 使用一个队列才存结果 每个 fold 里，先递归调用 fold，再将当前折痕方向入队，再递归调用 fold 从队列依次取出折痕即可 注意： 每个 fold 里的前后两次调用，方向相反，一上一下，和折纸方向有关 二叉树整棵树上节点间最大距离题目见 LongestDistance 思路： 递归的调用 find,每步迭代更新这两个值(当前子树的节点最大距离，到当前子树根结点的最大长度)：(MaxLength,MaxToRoot)，并将其返回 当前的 MaxToRoot = max(左子树的 MaxToRoot,右子树的 MaxToRoot) + 1 当前的 MaxLength ＝ max(一边的最大距离，两边的最大距离) 一边的最大距离 ＝ max(左子树的 MaxLength,右子树的 MaxLength) 两边的最大距离 ＝ 左子树的 MaxToRoot + 右子树的 MaxToRoot + 1 注意： 需要返回两个值，所以用数组当返回类型 分类/划分标准和思路理清了，代码很简单 找到含有节点最多的搜索二叉子树题目见 MaxSubtree 思路： 需要记录满足条件搜索二叉树的最大值，最小值，节点个数，记为数组 info[]，并返回该搜索二叉树的根节点 每一步递归对左孩子和右孩子调用，然后分情况讨论 左孩子的调用结果是左孩子，右孩子的的调用结果是右孩子，且左右孩子和根节点满足大小关系，更新上述 info[]，返回根节点 不满足上面的条件则从左右调用结果中选择节点个数大的结果（题目要求），更新上述 info[]，返回调用结果 左右节点个数相等，选择根结点值大的，更新上述 info[]，返回调用结果 注意： 空节点判断，数组初始化(最大值，最小值，个数0) 更新 info[] 时，尤其对情况一，需要判断左右孩子是否为空的情况 按层打印二叉树并换行题目见 TreePrinter 思路： 使用队列，先将根节点入队 使用两个指针 last 和 nlast 分别代表当前行的最后一个节点和下一行的最后一个节点，初始值均为 root 每次从队列取出一个节点，并将其左右节点入队，每入队一个，更新 nlast 为入队的节点 判断当前取出的节点是否为 last，若是，则说明这时此行最后一个，故更新 last = nlast 注意： 每出队一个节点，入队其左右孩子，这里 每次 都需要更新 nlast，因为不知道下一行在何时开始没新节点加入 结尾条件需要注意，只有当前节点为 last 且此时队列还非空时，才进行 last 的更新，同时换行，非空这个需要判断，否则会多出一个空行 递归方式实现二叉树的先序、中序和后序的遍历一定是先左后右，先序、中序和后序指的是根节点遍历的先后 题目见 TreeToSequence 思路： 递归调用即可，终止条件是该节点为 null 不为 null，则将二叉树的“左”，“根”，“右”按遍历顺序的要求打印 注意： 没啥注意的，三四行代码就完了 非递归方式实现二叉树的先序、中序和后序的遍历题目见 TreeToSequence2 都是使用 栈 来实现的 先序遍历思路：有点像深度优先遍历 使用一个栈，先将根节点压栈，当栈非空时进行以下步骤 每次出栈一个节点，并先将其右孩子压栈，再将其左孩子压栈 注意： 利用栈“后进先出”的特性，使得右孩子会在左孩子之后出栈 中序遍历思路： 使用栈，先将根节点入栈，当栈非空时进行以下步骤 当当前节点和其左孩子均不为空时，将其左孩子入栈，当前节点指向左孩子 当当前节点为空或者左孩子为空时，从栈顶取出一个，并将当前节点指向右孩子(可能为空)。若该取出的节点有右孩子，则将右孩子入栈。 注意： “当前节点左孩子为空则出栈”用于触发左子树到顶的情况 “当前节点为空则出栈”用于触发右孩子为空的回退 后序遍历思路：核心在于使用最近访问节点 last 来标记是从左孩子还是右孩子遍历完返回的，从而确定是入栈还是出栈 使用栈，先将根节点入栈，当栈非空时进行以下步骤 每次查看栈顶节点(但不出栈)，根据栈顶节点的情况分类判断： 左孩子非空且上次访问既不为左孩子也不为右孩子，则左孩子入栈 否则，若右孩子非空且上次访问不为右孩子，则右孩子入栈 否则，表示此时左右孩子均为空或均访问过，栈顶出栈，并记为最近访问节点 last 注意： 按上面的逻辑左孩子出栈后，右孩子才会入栈，所以是先左后右的顺序 右孩子是上次访问的节点时，前两条都不满足，所以一定会是孩子的根结点出栈","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brianway.github.io/tags/数据结构/"}]},{"title":"常见算法基础题思路简析(二)-链表篇","date":"2017-09-28T05:41:00.000Z","path":"2017/09/28/2017-09-28-algorithms-common-2-linkedlist/","text":"本文对和 链表 有关的常见算法基础题思路分类进行分析和总结，并以 Java 为例，适当指出需要注意的编程细节 相关题目和代码在 GitHub: https://github.com/brianway/algorithms-learning 题目见 com.brianway.learning.algorithms.lectures.linkedlist包 记号约定：链表未特殊说明则未单链表 判断一个单链表是否有环题目见 ChkLoop 思路： 判断环：使用快慢两个指针遍历链表，快指针一次移动两个节点，慢指针一次移动一个节点。终止条件为遍历到链表结尾或者快指针和慢指针相遇 找入环第一个节点：假如快慢指针相遇，则此时将慢指针指向头节点，然后均以每次一个节点的速度同步移动快慢指针，再次相遇点即为入环点 注意： 快指针移动时需要判断 next 和 next.next 均不为空才行 第二步的证明可以参考 http://blog.csdn.net/wuzhekai1985/article/details/6725263 http://blog.sina.com.cn/s/blog_6a0e04380101a9o2.html 判断两无环单链表是否相交题目见 CheckIntersect 思路： 分别遍历两个链表，得到长度 l1 和 l2 将较长的链表先遍历 |l1-l2| 个节点，再对两个链表同步遍历 若在遍历完前有相同节点，则相交，否则不相交 注意： 用新的变量指向链表，不要影响原链表结构 判断两有环单链表是否相交题目见 ChkIntersection 思路： 先判断两链表是否均有环，有一个无环则不相交 若入环节点一样，则相交 若入环节点不一样，则从一个入环点往后遍历，若能和另一个链表的入环点相遇则相交，若遍历回自己的入环点还没相遇，则不相交 注意： 第 3 步里从一个入环点往后遍历，注意起始条件 判断两单链表是否相交题目见 ChkIntersection2 思路：为前面几题的整合 先判断两链表是否均有环 若均无环，按照“判断两无环单链表是否相交”来解 若均有环，按照“判断两有环单链表是否相交”来解 若一个有环，一个无环，则不相交 删除特定值的节点题目见 ClearValue 思路： 找到第一个不为特定值的节点作为新的头节点 使用双指针 pre 和 current，current 用于依次遍历，pre 用于跳过为特定值的节点，只依次经过满足条件的其余节点 注意： 一定要循环跳过头节点里为特定值的节点，第二步必须以非特定值节点或者空节点开始 pre 和 current 的初始化以及移动赋值细节要留意 打印两个升序链表公共部分题目见 Common 思路： 新建一个数组用于容纳公共部分，同时遍历两个链表，根据当前的节点值分情况进行处理： 一个链表当前节点值大于另一个链表当前节点值，则较小值的链表节点向后移动一步 两个链表当前值相等，将公共部分存入数组，两个链表均向后移动一步 复制复杂链表题目见 CopyList 思路： 在每个节点的后面插入该节点的直接拷贝 对每个 copy 节点，更新其 random 指针为 random 指向节点的下一个节点(即指向其对应 copy 节点) 将 copy 节点从中分离出来即可 注意： 该题的难点主要在于每个节点的随机指针不是简单的直接拷贝就行了（那样会指向原链表中的节点），而需要在复制的链表里指向对应的复制节点 无论是插入拷贝还是分离节点，都要注意空指针判断和更新指针操作 链表partition题目见 Divide 思路： 使用两个链表分别收集大于阈值和小于等于阈值的节点 每次取出当前节点，归入其中一个链表，原链表向后移动一个 将两个链表首尾相连即可 注意： 两个链表的首尾节点都要记录 大于/小于等于的划分要全覆盖 取出的节点记得“断尾”，即 next 置为 null 有序环链表中插入值题目见 InsertValue 思路： 以一个节点(head)开始，用两个指针指向前后相邻的节点依次向后遍历，满足 pre.val &lt;= val &lt; after.val 则插入并停止遍历 若遍历完(after == head)，说明还没插入，此时应插入在 head 前 若 val 比 head.val 小，则更新头节点 注意： 注意空链表时该节点自己组环 插入节点时判断条件，前后的开闭要注意，[pre,after) 还是 (pre,after] 注意特殊情况，此时不满足 pre.val&lt;=val&lt;after.val（例如环全等，插入值是最小/最大等），这时需要插入在头节点之前及更新头节点 链表K逆序题目见 KInverse 思路： 用 kHead 指向每次 k 个节点的头节点（初始值为头节点） 遍每计数到 k 时，逆序这部分并返回逆序后的头节点 若新的头节点为空，则初始化新的头节点 否则，将该返回的头节点接在上次逆序完的尾节点 lastTail 后 更新 lastTail 指向该次逆序完的尾节点(即逆序前的 kHead) 更新 kHead 指向下一个节点继续重复上述步骤直到遍历结束 逆序部分： 使用 pre, current, next 分别指向当前节点及其前后节点 每次先用 pre 保存 newHead，用 next 保存 current.next；再更新 newhead 为 current，更新 newHead.next 指向 pre；最后移动 current 指向 next 即可 进一步优化，其实只需要 pre 和 current 两个指针就够了 1234567891011121314//普通反转整个链表public ListNode reverse(ListNode head) &#123; ListNode newHead = null; ListNode current = head; ListNode pre = null; while(current != null)&#123; pre = newHead; newHead = current; current = current.next; newHead.next = pre; &#125; return newHead;&#125; 注意： 逆序前需要用 next 指针保留好下一个节点，这样才能正确更新 kHead 注意循环中计数和清零的位置 逆序部分，需要把之前的头的 next 置为原末尾的 next，衔接起来 检查链表是否回文题目见 Palindrome 思路： 通过快慢指针得到链表中点 将后一半链表逆序 分别从头尾向中间遍历链表依次比较值，不等则停止，看能否在中点相遇 将逆序链表还原 注意： 注意逆序需要根据链表总节点数的分单双讨论 单数(quick.next = null)则 slow 指向正中间的节点，所以设置 mid = slow 双数时 slow 指向前一半的最后一个节点，所以设置 mid = slow.next 双数时从两头遍历前需要将 slow.next 置为 null，否则两边遍历终止条件不同 删除单节点题目见 Remove 思路： 若该节点为空或者为最后一个节点，返回 false 否则将下一个节点的 val 和 next 赋值给当前节点，达到“删除”的效果","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brianway.github.io/tags/数据结构/"}]},{"title":"常见算法基础题思路简析(一)-排序篇","date":"2017-09-28T05:16:07.000Z","path":"2017/09/28/2017-09-28-algorithms-common-1-sort/","text":"本文对和 排序 有关的常见算法基础题思路进行分析和总结，并以 Java 为例，适当指出需要注意的编程细节 相关题目和代码在 GitHub: https://github.com/brianway/algorithms-learning 题目见 com.brianway.learning.algorithms.lectures.sort包 记号约定：按升序排，数组 A 大小记为 n 冒泡排序思路： 依次交换相邻两个数，使大的在后，每趟在末尾确定一个最大值 外循环 n 趟依次确定最大值，次大值，….，确定排序 注意： 内循环的相邻元素下标写法和内循环下标起始 计数排序思路： 找到数组最大值 max 和最小值 min，以差值(max-min)作为桶数组的长度 遍历数组入桶计数 遍历桶，写回原数组 注意： 入桶时，对应桶下标为 A[i]-min 写回数组时下标依次递增， A[i++] = j + min; 堆排序思路： 初始化成大根堆 将堆顶元素(即最大值)和末尾元素交换，并下沉该换上来的末尾元素 将堆的长度减1，重复第二步 注意： 下标从 1 开始较方便，子节点下标就对应为 2*i 和 2*i+1 初始化时从一半位置依次递减下标使用下沉操作 下沉操作挑子节点中较大值与父节点交换，直至 满足父节点大于两个子节点 123456789private static void sink(Comparable[] pq, int k, int N) &#123; while (2 * k &lt;= N) &#123; int j = 2 * k; if (j &lt; N &amp;&amp; less(pq, j, j + 1)) j++; if (!less(pq, k, j)) break; exch(pq, k, j); k = j; &#125;&#125; 插入排序思路： 将数组前一部作为一个“有序数组”，该“有序数组”长度逐步扩大 每趟循环将当前元素依次和前一个元素比对，插入到“有序数组”中的相应位置 注意： 注意下标起始，外循环 n-1 次，内循环下标递减 插入效果可以使用两两相邻交换来实现 归并排序这里使用非递归的 bottom-up 的实现方式 思路： 每次合并的单位长度为 size ， size 依次取 1，2，… ，直到 size&gt;=n 对于每个 size，从前往后按照步长为 2*size 依次合并 归并的内部逻辑是，先从原数组拷贝一份到辅助数组，再按序填回原数组 注意： 需要分配一个辅助数组用于合并 每次合并需要传递五个参数：原数组，辅助数组以及合并的起止下标和中点下标 归并的截止下标需要取小避免越界 Math.min(n, i + 2 * size); 内循环的终止条件是 i + size &lt; n，步长是 2*size 快速排序思路： shuffle(可选):先把原数组随机打乱 partition:随机选一个数作为参考值，比其小的放左边，大的放右边 递归地排序上述结果的左半部分和右半部分 注意： 一般参考值就取第一个元素，对后面的元素进行划分 划分时注意循环终止条件，大于小于带不带等号，都要注意 选择排序思路： 每次遍历一趟挑取最小元素，将该元素与起始元素交换 起始元素下标依次为0，1，…，n-1 注意： 比较的是值，记录的是下标 基数排序以元素小于等于 2000 为例，位数为 4 思路： 准备一个 10*n 的桶数组(10 代表 0～9 的数字，n代表某个数字下最多容纳的个数，这里为原数组大小 n) 由低位到高位，将3，4步执行位数次循环 遍历数组，按照某一位的数字将元素入桶 从大数字到小数字，依次将桶内元素从后往前写回原数组 注意： 需要两个辅助数组，一个用于存放元素，一个用于记录每个数字桶的元素个数 入桶时一定要先低位，再高位，这样才能保证最高位影响最大 取桶内元素返到数组时一定要倒着取，这样才能保证之前排序的顺序 希尔排序思路： 对数组进行步长为1，4，13,…,（3*前一个步长+1）的插入排序，步长由大到小 注意： 最外层先计算好最大步长，每次除以三 插入排序的外层起始下标为 h，每次下标递增 1 插入排序的内层递减步长为 h 合并两个有序数组题目:Merge 思路： 从两个数组末端取值，每次取较大者，从后往前填空 当数组 B 的元素分配完时结束 判断数组中是否有重复值题目见 Checker 时间最快 O(n)，遍历一遍使用哈希表即可。 若要保证额外空间复杂度为O(1)，则使用排序，再遍历，看相邻是否有重值 行列排序矩阵找值题目见 lectures.sort.Finder 思路：由于行列分别有序（升序），从矩阵右上/左下开始找均可在 O(行数＋列数) 时间复杂度找到。以右上为例，当前数大于待找数，则同行往前找，否则同列往下找。 排序后相邻两数的最大差值题目见 Gap 直接排序做最快是 O(n*log n)的时间复杂度，这里讨论的是 O(n) 的时间复杂度 思路：来源于桶排序 找到数组的最大值和最小值，准备 n+1 个桶（n为数组元素个数） 最大值放在第 n+1 个桶中，其它桶以 (max-min)/n 的间隔均匀分布（所以最小值一定落在第一个第一个桶中） 将数组中元素依次落入桶中，找出空桶前的桶内元素的最大值和空桶后的桶内元素的最小值，求差即可 注意： n+1 个桶放 n 个元素，一定会有空桶，同一桶内元素的差值一定小于桶区间，所以来自不同桶之间的相邻元素差值更大。 分别使用 hasNum[n+1], maxs[n+1], mins[n+1] 来表示桶是否为空以及桶内元素的最大最小值 计算需要排序的最短子数组的长度题目见 Subsequence 思路： 从左到右遍历，记录元素值比该元素左边的最大值要小的最右下标 right 从右往左遍历，记录元素值比该元素右边的最小值要大的最左下标 left 如果 right &gt; left，则需要排序的长度为 right-left +1 注意： right 的初始值为 0，left 的初始值为 n-1 遍历的每一步，要么满足递增（减），更新最大（小）值；要么更新下标 荷兰旗问题题目见 ThreeColor 思路一：计数排序，先入桶再出桶即可。 思路二：类似三路快排，下标[0,lo]，(lo,mid]，(mid,n-1] 之间的元素各表示一个数值区间 注意： lo, hi, mid 的起始值要注意 交换时的增减顺序要注意，参考示例： 12345678910111213int lo = -1;int hi = n;int mid = 0;while (mid &lt; hi) &#123; if (A[mid] &lt; 1) &#123; swap(A, ++lo, mid++); &#125; else if (A[mid] &gt; 1) &#123; swap(A, --hi, mid); &#125; else &#123; mid++; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brianway.github.io/tags/数据结构/"}]},{"title":"CSS 布局经典问题初步整理","date":"2017-05-18T06:51:07.000Z","path":"2017/05/18/2017-05-18-css-layout-classical-problems/","text":"本文主要对 CSS 布局中常见的经典问题进行简单说明，并提供相关解决方案的参考链接，涉及到三栏式布局，负 margin，清除浮动，居中布局，响应式设计，Flexbox 布局，等等。 CSS 基础知识下面几个入门教程不错： 幕课网 - HTML+CSS基础课程：偏基础，可以在线练习和预览 MDN - CSS入门教程: MDN 的官方文档 学习 CSS 布局：排版和配色特别舒服，简短但不深入，适合概览入门 CSS 定位问题主要就是经典的绝对定位，相对定位问题。 10个文档学布局：通过十个例子讲解布局，主要涉及相对布局，绝对布局，浮动。 百度前端学院笔记 - 理解绝对定位：文章本身一般，几篇参考文献比较详细 HTML和CSS高级指南之二——定位详解（译文）：介绍浮动的使用，详细介绍定位的技巧，包括如何准确的给元素在 X 轴、Y 轴和 Z 轴定位 三栏式布局涉及浮动和清除浮动，主要讲解“圣杯”和“双飞翼”两种解决方法。这两种方法实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想。 圣杯布局圣杯：父盒子包含三个子盒子（左，中，右） 中间盒子的宽度设置为 width: 100%; 独占一行； 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行； .left {margin-left:-100%;} 把左边的盒子拉上去 .right {margin-left：-右边盒子宽度px;} 把右边的盒子拉上去 父盒子设置左右的 padding 来为左右盒子留位置； 对左右盒子使用相对布局来占据 padding 的空白，避免中间盒子的内容被左右盒子覆盖； 1234567&lt;!-- 圣杯的 HTML 结构 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 中间的 div 必须写在最前面 --&gt; &lt;div class=\"middle\"&gt;中间弹性区&lt;/div&gt; &lt;div class=\"left\"&gt;左边栏&lt;/div&gt; &lt;div class=\"right\"&gt;右边栏&lt;/div&gt;&lt;/div&gt; 双飞翼布局双飞翼：父盒子包含三个子盒子（左，中，右），中间的子盒子里再加一个子盒子。 中间盒子的宽度设置为 width: 100%; 独占一行； 使用负边距(均是 margin-left)把左右两边的盒子都拉上去和中间盒子同一行； 在中间盒子里面再添加一个 div，然后对这个 div 设置 margin-left 和 margin-right来为左右盒子留位置； 123456789&lt;!-- 双飞翼的 HTML 结构 --&gt;&lt;div class=\"container\"&gt; &lt;!-- 中间的 div 必须写在最前面 --&gt; &lt;div class=\"middle\"&gt; &lt;div class=\"middle-inner\"&gt;中间弹性区&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;左边栏&lt;/div&gt; &lt;div class=\"right\"&gt;右边栏&lt;/div&gt;&lt;/div&gt; 圣杯和双飞翼异同圣杯布局和双飞翼布局解决的问题是一样的，都是两边定宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。 两种方法基本思路都相同：三栏全部 float 浮动。首先让中间盒子 100% 宽度占满同一高度的空间，在左右两个盒子被挤出中间盒子所在区域时，使用 margin-left 的负值将左右两个盒子拉回与中间盒子同一高度的空间。接下来进行一些调整避免中间盒子的内容被左右盒子遮挡。 主要区别在于 如何使中间盒子的内容不被左右盒子遮挡： 圣杯布局的方法：设置父盒子的 padding 值为左右盒子留出空位，再利用相对布局对左右盒子调整位置占据 padding 出来的空位； 双飞翼布局的方法：在中间盒子里再增加一个子盒子，直接设置这个子盒子的 margin 值来让出空位，而不用再调整左右盒子。 简单说起来就是双飞翼布局比圣杯布局多创建了一个 div，但不用相对布局了，少设置几个属性。 利用浮动实现我自己使用浮动也实现了三栏式布局：左边盒子左浮动，右边盒子右浮动，中间盒子利用 margin-left 和 margin-right 来为左右盒子留位置，同时父盒子设置 overflow: auto; 来避免子盒子溢出。 1234567&lt;!-- 浮动实现的 HTML 结构 --&gt;&lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;左边栏&lt;/div&gt; &lt;div class=\"right\"&gt;右边栏&lt;/div&gt; &lt;!-- 中间的 div 必须写在最后面 --&gt; &lt;div class=\"middle\"&gt;中间弹性区&lt;/div&gt;&lt;/div&gt; 三栏式布局参考下面几个链接: CSS三栏布局——中间固定两边自适应宽度： w3cplus 的文章，使用了双飞翼和浮动实现两侧定宽、中间自适应，也实现了两侧自适应、中间定宽 简书 - 圣杯布局和双飞翼布局（前端面试必看）：只讲了圣杯，不过特别详细 In Search of the Holy Grail：圣杯布局的来源 百度前端学院笔记 - 三栏式布局之双飞翼与圣杯：百度前端学院学员的前端学习笔记 三栏式布局涉及到负 magin 和 清除浮动的问题。 负 magin这里引出了“负 margin”的问题： 负margin用法权威指南：The Definitive Guide to Using Negative Margins 的译文,介绍了负 magin 的一些性质和很多实用技巧 简书 - margin为负值产生的影响和常见布局应用：包括对自身的影响，对文档流的影响，以及一些在布局中的应用技巧(比如去除列表右边框，负边距+定位实现水平垂直居中，去除列表最后一个 li 元素的 border-bottom，多列等高) 博客园 - CSS布局奇淫巧计之-强大的负边距：和上文内容差不多 简单总结几点： 不使用 float 的话，负 margin 元素是不会破坏页面的文档流。所以如果你使用负 margin 上移一个元素，所有跟随的元素都会被上移(而 relative 定位的元素则不同，会保留原位置，影响文档流)。 当 static 元素的 margin-top/margin-left 被赋予负值时，元素将被拉进指定的方向。 如果你设置 margin-bottom/right 为负数，元素并不会如你所想的那样向下/右移动，而是将后续的元素拖拉进来，覆盖本来的元素。 当元素不存在 width 属性或者 width: auto 的时候，负 margin 会增加元素的宽度. margin-top 为负值不会增加高度，只会产生向上位移;margin-bottom 为负值不会产生位移，会减少自身的供 CSS 读取的高度，影响下方的元素位置；上下相邻的元素两者均为负时，效果不叠加，取负值更多的那个效果。 清除浮动清除浮动主要是为了解决高度塌陷问题。而简单的 clear: both 并不能解决这个问题，所以引出了许多解决方案。 StackOverflow - What methods of ‘clearfix’ can I use?：清除浮动黑科技完整解读 那些年我们一起清除过的浮动：神文，把“清除浮动”定义为“闭合浮动”，把问题由来和解决方案都讲清楚了，并且分析了各种解决方案的优劣。 各种解决方案在上面的链接里有很详细的说明了，这里就不赘述了。大体分为两类： 其一，通过在浮动元素的末尾添加一个空元素，设置 clear: both 属性，after 伪元素其实也是通过 content 在元素的后面生成了内容为一个点的块级元素； 其二，通过设置父元素 overflow 或者 display: table 属性来闭合浮动 顺便补充一句，clear float(例如 clear: left) 是对某个元素设置，以避免其某一边有浮动元素，即对当前元素产生约束，约束的边界为其他的浮动元素。对于已经浮动的元素，设置 clear float 是无效的。 居中布局 Centering in CSS: A Complete Guide：非常全面的居中定位博客，包括各种情况下的水平居中，垂直居中和水平垂直居中方案。有展示示例及相应的 HTML 和 CSS 代码 文章大致结构： 水平居中 对于行内元素(inline)：text-align: center; 对于块级元素(block)：设置宽度且 marigin-left 和 margin-right 是设成 auto 对于多个块级元素：对父元素设置 text-align: center;，对子元素设置 display: inline-block;；或者使用 flex 布局 垂直居中 对于行内元素(inline) 单行：设置上下 pandding 相等；或者设置 line-height 和 height 相等 多行：设置上下 pandding 相等；或者设置 display: table-cell; 和 vertical-align: middle;；或者使用 flex 布局；或者使用伪元素 对于块级元素(block)：下面前两种方案，父元素需使用相对布局 已知高度：子元素使用绝对布局 top: 50%;，再用负的 margin-top 把子元素往上拉一半的高度 未知高度：子元素使用绝对布局 position: absolute; top: 50%; transform: translateY(-50%); 使用 Flexbox：选择方向，justify-content: center; 水平垂直居中 定高定宽：先用绝对布局 top: 50%; left: 50%;，再用和宽高的一半相等的负 margin 把子元素回拉 高度和宽度未知：先用绝对布局 top: 50%; left: 50%;，再设置 transform: translate(-50%, -50%); 使用 Flexbox：justify-content: center; align-items: center; 响应式设计“响应式设计（Responsive Design)” 是一种让网站针对不同的浏览器和设备“呈现”不同显示效果的策略。 媒体查询(Media Queries)是做此事所需的最强大的工具。 注： Responsive Web Design ＝ RWD，Adaptive Web Design ＝ AWD RWD： 采用 CSS 的 media query 技术 流体布局（fluid grids） 自适应的图片/视频等资源素材 （为小、中、大屏幕做一些优化，目的是让任何尺寸的屏幕空间都能得到充分利用） AWD： CSS media query 技术（仅针对有限几种预设的屏幕尺寸设计） 用 JavaScript 来操作 HTML 内容 在服务器端操作 HTML 内容（比如为移动端减少内容，为桌面端提供更多内容） 以上 RWD 和 AWD 解释引自 知乎 @屹峰 可以参考 Bootstrap 的网格系统：http://getbootstrap.com/css/#grid-less The Bootstrap 3 grid system has four tiers of classes: xs (phones), sm (tablets), md (desktops), and lg (larger desktops). 自己实现网格系统： Creating Your Own CSS Grid System Flexbox 布局Flexbox 布局参考下面几篇文章就可以了，几篇文章大同小异，看一两篇就知道大概了，讲的挺详细的，在此不赘述 w3cplus - 一个完整的Flexbox指南：A Complete Guide to Flexbox 的译文 SegmentFault - Flexbox详解 w3cplus - 图解CSS3 Flexbox属性 w3cplus - Flexbox——快速布局神器","tags":[{"name":"前端","slug":"前端","permalink":"https://brianway.github.io/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"https://brianway.github.io/tags/CSS/"}]},{"title":"前端学习笔记(3)-DOM 基础","date":"2017-05-18T06:27:07.000Z","path":"2017/05/18/2017-05-18-front-end-notes-3-DOM-basics/","text":"本文主要介绍 HTML DOM。第一部分 “DOM 概述” 主要参考 MDN，第二部分 “HTML DOM” 主要参考 W3School。 DOM 概述 文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。 所有操作和创建web页面的属性，方法和事件都会被组织成对象的形式（例如， document 对象表示文档本身， table 对象实现了特定的 HTMLTableElement DOM 接口来访问HTML 表格等）。 引自 MDN - DOM 概述 JavaScript 可以访问和操作存储在 DOM 中的内容: API (web 或 XML 页面) = DOM + JS (脚本语言) 一些重要的数据类型： document 每个载入浏览器的 HTML 文档都会成为 Document 对象。MDN - document element element 是指由 DOM API 中成员返回的类型为 element 的一个元素或节点。 nodeList nodeList 是一个元素的数组 attribute DOM 中的属性也是节点，就像元素一样 namedNodeMap namedNodeMap 和数组类似，但是条目是由 name 或 index 访问的 HTML DOM下面用一张树状图图来介绍 HTML DOM。 文档对象模型 DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将 HTML 文档呈现为带有元素、属性和文本的树结构（节点树） HTML DOM 树 HTML 文档可以说由节点构成的集合,常见的 DOM 节点: 元素节点：上图中&lt;html&gt;、&lt;body&gt;、&lt;p&gt;等都是元素节点，即标签 文本节点：向用户展示的内容，如 &lt;li&gt;...&lt;/li&gt;中的 JavaScript、DOM、CSS 等文本。 属性节点：元素属性，如 &lt;a&gt; 标签的链接属性 href=&quot;http://www.imooc.com&quot; 几个简单的 DOM 操作： innerHTML 属性用于获取或替换 HTML 元素的内容，Object.innerHTML 改变 HTML 样式，Object.style.property=new style; 隐藏和显示 Object.style.display = value，value 可取 none 或者 block 参考 慕课网 - JavaScript 入门篇(第三章) HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。换言之，HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准。 参考 W3School - HTML DOM 教程 方法和属性所有 HTML 元素被定义为对象，而编程接口则是 对象方法 和 对象属性。 方法是您能够执行的动作（比如添加或修改元素）。 属性是您能够获取或设置的值（比如节点的名称或内容） 一些常用的 HTML DOM 方法： getElementById(id) - 获取带有指定 id 的节点（元素） appendChild(node) - 插入新的子节点（元素） removeChild(node) - 删除子节点（元素） 一些常用的 HTML DOM 属性： innerHTML - 节点（元素）的文本值 parentNode - 节点（元素）的父节点 childNodes - 节点（元素）的子节点 attributes - 节点（元素）的属性节点 nodeName - nodeName 属性规定节点的名称。 nodeName 是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 与属性名相同 文本节点的 nodeName 始终是 #text 文档节点的 nodeName 始终是 #document nodeValue - 性规定节点的值。 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 nodeType - 返回节点的类型。nodeType 是只读的。 DOM 根节点有两个特殊的属性，可以访问全部文档： document.documentElement - 全部文档 document.body - 文档的主体 访问和修改访问 HTML 元素等同于访问节点,能够以不同的方式来访问 HTML 元素： getElementById() 方法 getElementsByTagName() 方法 getElementsByClassName() 方法 修改 HTML DOM 意味着许多不同的方面： 改变 HTML 内容 改变 CSS 样式 改变 HTML 属性 创建新的 HTML 元素 删除已有的 HTML 元素 改变事件（处理程序） 事件HTML 事件的例子： 当用户点击鼠标时，onmousedown、onmouseup 以及 onclick 事件 当网页已加载时，onload 和 onunload 事件 当图片已加载时 当鼠标移动到元素上时，onmouseover 和 onmouseout 事件 当输入字段被改变时，onchange 事件 当 HTML 表单被提交时 当用户触发按键时 参考资料 W3School - HTML DOM 教程 W3School - HTML DOM Document 对象 MDN - Document Object Model (DOM)","tags":[{"name":"前端","slug":"前端","permalink":"https://brianway.github.io/tags/前端/"}]},{"title":"前端学习笔记(2)-CSS 基础","date":"2017-05-18T05:55:07.000Z","path":"2017/05/18/2017-05-18-front-end-notes-2-CSS-basics/","text":"本文主要对 CSS 相关基础知识进行介绍 基础知识CSS 样式由选择符和声明组成，而声明又由属性和值组成。 选择符：又称选择器，指明网页中要应用样式规则的元素。 声明：在英文大括号{}中的的就是声明，属性和值之间用英文冒号{}分隔。当有多条声明时，中间可以英文分号;分隔。 123选择器&#123; 样式;&#125; 从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式、嵌入式和外部式三种。优先级遵循就近原则，一般来说，内联式 &gt; 嵌入式 &gt; 外部式。 内联式 例子 &lt;p style=&quot;color:red;font-size:12px&quot;&gt;这里文字是红色。&lt;/p&gt; 嵌入式 12345&lt;style type=\"text/css\"&gt; span&#123; color:red; &#125;&lt;/style&gt; 外部式 例子：&lt;link href=&quot;base.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; CSS 选择器常见的类选择器类型有如下几种： 标签选择器，.标签选择器名称{css样式代码;} 类选择器，.类选器名称{css样式代码;} ID 选择器，＃类选器名称{css样式代码;} 子选择器，即大于符号(&gt;),用于选择指定标签元素的第一代子元素 包含选择器，即加入空格,用于选择指定标签元素下的后辈元素 通用选择器，匹配html中所有标签元素，* {css样式代码;} 类选择器和ID选择器都可以应用于任何元素，但 ID 选择器只能在文档中使用一次，可以使用类选择器词列表方法为一个元素同时设置多个样式，ID 选择器是不可以的。 子选择器和包含选择器区别：&gt;作用于元素的第一代后代，空格作用于元素的所有后代。 另外还有两种选择符： 伪类选择符，允许给 HTML 不存在的标签（标签的某种状态）设置样式。常用的有 a:hover{color:red;} 分组选择符，为 HTML 中多个标签元素设置同一个样式时，可以使用分组选择符,。例如 h1,span{color:red;} CSS 的继承、层叠和特殊性 CSS 的某些样式是具有继承性的，继承是一种规则，它允许样式不仅应用于某个特定 HTML 标签元素，而且应用于其后代。 特殊性：不同选择器具有不同权值，标签的权值为 1，类选择符的权值为 10，ID选择符的权值最高为 100。 层叠 就是在 HTML 文件中对于同一个元素可以有多个 CSS 样式存在，当有相同权重的样式存在时，会根据这些 CSS 样式的前后顺序来决定，处于最后面的 CSS 样式会被应用。 CSS 格式化排版文字排版 字体，body{font-family:&quot;Microsoft Yahei&quot;;} 字号、颜色，body{font-size:12px;color:#666} 粗体，body{font-weight:bold;} 斜体，body{font-style:italic;} 下划线，body{font-style:italic;} 删除线，body{text-decoration:line-through;} 段落排版 缩进，p{text-indent:2em;} 行间距（行高），p{line-height:1.5em;} 中文字间距、字母间距，letter-spacing:50px;和word-spacing:50px; 对齐，div{text-align:center;} CSS 盒模型元素分类在 CSS 中，HTML 中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。 常用的块状元素有： 1&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt; 块级元素特点： 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的 100%（和父元素的宽度一致），除非设定一个宽度。 设置 display:block 就是将元素显示为块级元素，从而使元素具有块状元素特点。 注：img 标签与 div 层之间会有空隙的解决方法是：使用 display:block 就可以消除间隙。 常用的内联元素有： 1&lt;a&gt;、&lt;span&gt;、&lt;br&gt;、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt; 内联元素特点： 和其他元素都在一行上； 元素的高度、宽度及顶部和底部边距不可设置； 元素的宽度就是它包含的文字或图片的宽度，不可改变。 块状元素也可以通过代码 display:inline 将元素设置为内联元素。 常用的内联块状元素有： 1&lt;img&gt;、&lt;input&gt; inline-block 元素特点： 和其他元素都在一行上； 元素的高度、宽度、行高以及顶和底边距都可设置。 内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码 display:inline-block 就是将元素设置为内联块状元素。 盒模型 边框 盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。 12345678910div&#123; border:2px solid red;&#125;div&#123; border-width:2px; border-style:solid; border-color:red;&#125; 单独设置下边框的例子 div{border-bottom:1px solid red;} 宽度和高度 CSS 内定义的宽（width）和高（height），指的是 填充以里的内容范围。一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 W3C 的标准 Box Model: 123456/*外盒尺寸计算（元素空间尺寸）*/Element空间高度 = content height + padding + border + marginElement 空间宽度 = content width + padding + border + margin/*内盒尺寸计算（元素大小）*/Element Height = content height + padding + border （Height为内容高度）Element Width = content width + padding + border （Width为内容宽度） 所以有时会设置 box-sizing: border-box; 来避免计算内部元素大小 参考 CSS3 Box-sizing 填充(padding) 元素内容与边框之间是可以设置距离的，称之为“填充”。填充也可分为上、右、下、左(顺时针)。 例子： 123456789101112/*上、右、下、左(顺时针)，顺序不要搞混*/div&#123;padding:20px 10px 15px 30px;&#125;div&#123; padding-top:20px; padding-right:10px; padding-bottom:15px; padding-left:30px;&#125;/*上、右、下、左的填充都为10px;*/div&#123;padding:10px;&#125;/*上下填充一样为10px，左右一样为20px*/div&#123;padding:10px 20px;&#125; 边界(margin) 元素与其它元素之间的距离可以使用边界（margin）来设置，顺序和填充一样是上，右，下，左。padding 在边框里，margin 在边框外。 CSS 布局模型CSS 包含 3 种基本的布局模型，用英文概括为：Flow、Layer 和 Float。在网页中，元素有三种布局模型： 流动模型（Flow） 浮动模型 (Float) 层模型（Layer） 流动模型流动模型，流动（Flow）是默认的网页布局模式。 流动布局模型具有2个比较典型的特征： 块状元素 都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为 100%。实际上，块状元素都会以行的形式占据位置。 在流动模型下，内联元素 都会在所处的包含元素内从左到右水平分布显示。 浮动模型任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动。例子：#div1{float:left;} 层模型CSS 定义了一组定位（positioning）属性来支持层布局模型。 层模型有三种形式： 绝对定位(position: absolute) 相对定位(position: relative) 固定定位(position: fixed) 可参考这篇文章辅助理解 《css绝对定位、相对定位和文档流的那些事》 官方文档: MDN - position 绝对定位(position: absolute) 如果想为元素设置层模型中的绝对定位，需要设置 position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用 left、right、top、bottom 属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于 body 元素，即相对于浏览器窗口。 相对定位(position: relative) 如果想为元素设置层模型中的相对定位，需要设置 position:relative（表示相对定位），它通过 left、right、top、bottom 属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按 static(float) 方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 简单来说，就是相对元素原来的位置进行移动，元素本身所占的位置会保留。 固定定位(position: fixed) 设置 position:fixed;。fixed：表示固定定位，与 absolute 定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与 background-attachment:fixed; 属性功能相同。 Relative 与 Absolute 组合使用,必须遵守下面规范： 参照定位的元素必须是相对定位元素的前辈元素 参照定位的元素必须加入 position:relative; 定位元素加入 position:absolute，便可以使用 top、bottom、left、right 来进行偏移定位了 例子(HTML 和 CSS 代码分别为)： 123&lt;div id=\"box1\"&gt;&lt;!--参照定位的元素--&gt; &lt;div id=\"box2\"&gt;相对参照元素进行定位&lt;/div&gt;&lt;!--相对定位元素--&gt;&lt;/div&gt; 1234567891011#box1&#123; width:200px; height:200px; position:relative; /*参照定位的元素必须加入position:relative;*/ &#125;#box2&#123; position:absolute; top:20px; left:30px;/*定位元素加入position:absolute*/ &#125; 颜色和长度设置颜色的方法也有很多种： 英文命令颜色，p{color:red;} RGB颜色，p{color:rgb(133,45,200);} 和 p{color:rgb(20%,33%,25%);} 十六进制颜色，这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。p{color:#00ffff;}(当你设置的颜色是 16 进制的色彩值时，如果每两位的值相同，可以缩写一半，#0ff) RGB 配色表参考 RGB颜色对照表 - 在线工具 - 开源中国 或者 RGB 配色表 长度单位总结一下，目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。 像素 em，就是本元素给定字体的 font-size 值 % 百分比 设置小技巧水平居中设置 行内元素。如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。 定宽块状元素(块状元素的宽度 width 为固定值)。满足定宽和块状两个条件的元素是可以通过设置“左右 margin”值为 auto 来实现居中的。 不定宽块状元素。 加入 table 标签(包括 &lt;tbody&gt;、&lt;tr&gt;、&lt;td&gt;)，为这个 table 设置“左右 margin 居中” 设置 display: inline 方法：与第一种类似，显示类型设为 行内元素，然后使用 text-align:center 来实现居中效果，进行不定宽元素的属性设置。 给父元素设置 float 和 position:relative; left:50%，子元素设置 position:relative 和 left: -50% 来实现水平居中。 垂直居中设置 父元素高度确定的单行文本。通过设置父元素的 height 和 line-height 高度一致来实现的。(height: 该元素的高度；line-height: 顾名思义，行高（行间距），指在文本中，行与行之间的 基线间的距离 )。 父元素高度确定的多行文本。使用插入 table (包括 tbody、tr、td)标签，同时设置 vertical-align：middle。 另外，为元素设置以下两个属性之一会隐形改变 display 类型，元素的display显示类型就会自动变为以 display:inline-block（块状元素）的方式显示，当然就可以设置元素的 width 和 height 了，且默认宽度不占满父元素。 position: absolute float: left 或 float:right 更详细的居中布局技巧可以参考我另外一篇文章：CSS 布局经典问题初步整理 参考资料 MDN CSS入门教程 慕课HTML+CSS基础教程视频 css绝对定位、相对定位和文档流的那些事 W3School - CSS 参考手册 学习CSS布局","tags":[{"name":"前端","slug":"前端","permalink":"https://brianway.github.io/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"https://brianway.github.io/tags/CSS/"}]},{"title":"前端学习笔记(1)-HTML","date":"2017-05-18T05:34:07.000Z","path":"2017/05/18/2017-05-18-front-end-notes-1-HTML/","text":"本文主要对 HTML 标签进行介绍和归纳 基本概念 HTML 是网页内容的载体。内容就是网页制作者放在页面上想要让用户浏览的信息，可以包含文字、图片、视频等。 CSS 样式是表现。比如，标题字体、颜色变化，或为标题加入背景图片、边框等，所有这些用来改变内容外观的东西称之为表现。 JavaScript 是用来实现网页上的特效效果。如：鼠标滑过弹出下拉菜单，或鼠标滑过表格的背景颜色改变，还有焦点新闻（新闻图片）的轮换。有动画的，有交互的一般都是用 JavaScript 来实现的。 常用标签主要需要留意，标签的用途、标签在浏览器中的默认样式 注：现在一般使用 xhtml1.0 的版本（其它标签也是），这种版本比较规范 强调语气：&lt;em&gt;是斜体，&lt;strong&gt;是加粗 引用：&lt;q&gt;短文本引用，&lt;blockquote&gt;长文本引用 换行 &lt;br /&gt; 水平横线 &lt;hr /&gt; 空格 &amp;nbsp; 表格 &lt;table&gt; &lt;tbody&gt; 加上后表格内容全部下载完才会显示 行 &lt;tr&gt; 列 &lt;td&gt; 表格表头 &lt;th&gt; 标题 &lt;caption&gt; 超链 &lt;a&gt; 例子：&lt;a href=&quot;目标网址&quot; title=&quot;鼠标滑过显示的文本&quot;&gt;链接显示的文本&lt;/a&gt; 新标签打开：target=&quot;_blank&quot; 图片 &lt;img&gt;，图像可以是 GIF，PNG，JPEG 格式的图像文件 例子：&lt;img src=&quot;图片地址&quot; alt=&quot;下载失败时的替换文本&quot; title = &quot;提示文本&quot;&gt; 表单 &lt;form&gt; 文本域 &lt;textarea&gt; 例子 &lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot;&gt;文本&lt;/textarea&gt; cols 多行输入域的列数；rows 多行输入域的行数。这两个属性可用 CSS 样式的 width 和 height 来代替：col 用 width、row 用 height 来代替 输入框 &lt;input type=&quot;text/password&quot; name=&quot;名称&quot; value=&quot;文本&quot; /&gt; 当 type=”text” 时，输入框为文本输入框 当 type=”password” 时, 输入框为密码输入框 单/复选框 &lt;input type=&quot;radio/checkbox&quot; value=&quot;值&quot; name=&quot;名称&quot; checked=&quot;checked&quot;/&gt; 当 type=”radio” 时，控件为单选框，同一组单选框 name 命名要一致 当 type=”checkbox” 时，控件为复选框 提交按钮 &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; 重置按钮 &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; 下拉列表框 &lt;select&gt;&lt;option value=&quot;看书&quot;&gt;看书&lt;/option&gt;&lt;/select&gt; value &lt;option value=&quot;提交值&quot;&gt;选项&lt;/option&gt; 选中 selected=&quot;selected&quot; 多选 multiple=&quot;multiple&quot; 标签 &lt;label for=&quot;控件id名称&quot;&gt;，标签的 for 属性中的值应当与相关控件的 id 属性 值一定要相同","tags":[{"name":"HTML","slug":"HTML","permalink":"https://brianway.github.io/tags/HTML/"},{"name":"前端","slug":"前端","permalink":"https://brianway.github.io/tags/前端/"}]},{"title":"The Structure of jQuery","date":"2017-05-18T05:20:07.000Z","path":"2017/05/18/2017-05-18-the-structure-of-jQuery/","text":"We examine famous frameworks and libraries,such as jQuery,to experience the open source education.This article mainly analyses the structure of jQuery. Course link: JavaScript: Understanding the Weird Parts (Section 8: Examining Famous Frameworks and Libraries) jQuery IntroductionjQuery is just a JavaScript library.What jQuery does essentially is let you manipulate the DOM.It handles the browser quirks but doesn’t add any features to the browser or to JavaScript itself. the jQuery function isn’t a function constructor.It’s just a function that returns an object,a function that returns a call to function constructor. 123456// Define a local copy of jQueryjQuery = function( selector, context ) &#123; // The jQuery object is actually just the init constructor 'enhanced' // Need init if jQuery is called (just allow error to be thrown if not included) return new jQuery.fn.init( selector, context );&#125; jQuery.fn is just an alias of jQuery.prototype which is just hanging out(just an empty object at fisrt) and is overwritten with a new object. jQuery.extend and jQuery.fn.extend are the some function.This function takes properties and methods of one object and adds them to another. jQuery extends itself with many useful functions,such as map,each,type,isArray,makeArray,and so on. SizzleSizzle(http://sizzlejs.com/) is a whole other engine inside of jQuery. A pure-JavaScript CSS selector engine designed to be easily dropped in to a host library. The jQuery.extend invocation is inside an IIFE,and the property Sizzle is returned by another IIFE that returns a Sizzle object.That is to say,one IIFE can be inside another. jQuery is using that Sizzle library. 1234567jQuery.find = Sizzle;jQuery.expr = Sizzle.selectors;jQuery.expr[\":\"] = jQuery.expr.pseudos;jQuery.unique = Sizzle.uniqueSort;jQuery.text = Sizzle.getText;jQuery.isXMLDoc = Sizzle.isXML;jQuery.contains = Sizzle.contains; init and jQuery prototypejQuery.fn.init is the function constructor.At the end of the function constructor,it’s returning a value,still giving back the empty object that was created with the new operator,but doing some stuff to it first. 1234init = jQuery.fn.init = function( selector, context ) &#123; //elide some codes return jQuery.makeArray( selector, this );&#125; As for any new object created with the init function constructor, its prototype is the same memory spot as jQuery.prototype–the prototype of the jQuery object itself. 123//reminder: jQuery.fn = jQuery.prototype// Give the init function the jQuery prototype for later instantiationinit.prototype = jQuery.fn; The neat trick: you don’t hava to call the new operator when you use jQuery.Instead this calls a function that then calls a function constructor,creating a new object.But that new object has access to all the properties and methods in jQuery.fn. And instead of always in this jQuery code typing in jQuery.fn.init.something,it’s just the prototype of the jQuery object itself. Method Chainingmethod chaining: calling one method after another,and each method affects the parent object. When you execute a method or call a method,and it’s found down the prototype chain,the this variable points at the originating object,the object that actually made the call. e.g. Just see the return value of addClass function: 1234addClass: function( value ) &#123; //elide some codes here return this;&#125; Expose GloballyExpose jQuery or $ globally: 123456// Expose jQuery and $ identifiers, even in// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)// and CommonJS for browser emulators (#13566)if ( typeof noGlobal === strundefined ) &#123; window.jQuery = window.$ = jQuery;&#125; Both of window.jQuery and window.$ are pointing at the same spot in memory as the jQuery object created inside this function that had all these properties and methods attached to it.","tags":[{"name":"前端","slug":"前端","permalink":"https://brianway.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://brianway.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://brianway.github.io/tags/jQuery/"}]},{"title":"将项目发布到 Maven 中央仓库踩过的坑","date":"2017-05-16T18:39:07.000Z","path":"2017/05/17/2017-05-17-release-to-maven-central-repo/","text":"记录第一次将项目发布到 Maven 中央仓库踩过的坑和解决方案。 大致步骤 注册 Sonatype 的账户。地址：https://issues.sonatype.org/secure/Signup!default.jspa 提交发布申请。创建 Issue 地址：https://issues.sonatype.org/secure/CreateIssue.jspa?issuetype=21&amp;pid=10134 项目类型是 Community Support - Open Source Project Repository Hosting groupId 对应的域名你需要有所有权 使用 GPG 生成密钥对。下载地址：https://www.gnupg.org/download/。用得到的指令有如下几条： gpg --version 检查安装成功没 gpg --gen-key 生成密钥对 gpg --list-keys 查看公钥 gpg --keyserver hkp://pool.sks-keyservers.net --send-keys 公钥ID 将公钥发布到 PGP 密钥服务器 gpg --keyserver hkp://pool.sks-keyservers.net --recv-keys 公钥ID 查询公钥是否发布成功 配置 Maven。需要修改的 Maven 配置文件包括：setting.xml（全局级别）与 pom.xml（项目级别） setting.xml：在其中加入 server 信息，包含 Sonatype 账号的用户名与密码 pom.xml：在其中配置 profile,包括插件和 distributionManagement，。snapshotRepository 与 repository 中的 id 一定要与 setting.xml 中 server 的 id 保持一致。 上传构件到 OSS 中。mvn clean deploy -P release 在 OSS 中发布构件。进入 https://oss.sonatype.org/，点击”Staging Repositories” -&gt; 在搜索栏输入你的 groupId -&gt; 勾选你的构件并点击 close -&gt; 点击 tab 栏的 release。 通知 Sonatype 的工作人员关闭 issue。 等待审批通过后，就可以在中央仓库中搜索到自己发布的构件了！下面是我在 Maven 中央仓库的构件： webporter 发布到 maven 中央仓库 搜索地址： https://search.maven.org/ 中央仓库地址：http://mvnrepository.com/ 我发布的构件地址：http://mvnrepository.com/artifact/com.github.brianway 图文教程参考主要参考如下三个链接： 将 Smart 构件发布到 Maven 中央仓库 by 黄勇 发布Maven构件到中央仓库 by 阿信sxq 将项目发布到Maven中央库 by 路小磊 (截图详细) 遇到的问题在这个过程中遇到许多奇奇怪怪的问题，下面依次说明 插件没找到在 IntelliJ IDEA 中，pom.xml 里的插件找不到并报红，如下图： maven 依赖不识别 自己使用 mvn 指令构建的话，会提示 12Plugin &apos;&apos;&apos;org.apache.maven.plugins:maven-gpg-plugin:1.6&apos;&apos;&apos; not foundInspects a Maven model for resolution problems. 两种解决方法： 方案一：手动下载 1mvn dependency:get -DrepoUrl=http://repo.maven.apache.org/maven2/ -Dartifact=org.apache.maven.plugins:maven-gpg-plugin:1.6 方案二：在 IntelliJ IDEA 中更新 Indexed Maven Repositories 步骤： IntelliJ IDEA -&gt; Preferences -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Maven -&gt; Repositories -&gt; Remote URL -&gt; Update 这个过程耗时视网速而定，大概 5～10 分钟。 maven 依赖不识别解决方案 方案一是参考下面第二个链接；方案二是我自己提出并验证是有效的。 IntelliJ IDEA shows plugin not found Maven plugins can not be found in IntelliJ GPG 版本问题我用的是 mac,下载的是二进制发行包 GnuPG for OS X，然后发现是在 terminal 输入的指令是 gpg2 而不是 gpg。比如，公钥显示如下： 12345678$ gpg2 --list-keys /Users/brian/.gnupg/pubring.kbx-------------------------------pub rsa2048 2017-05-10 [SC] [expires: 2019-05-10] DBD686EC6F4E34C4096C427506755FE5978EC644 DBD686EC6F4E34C4096C427506755FE5978EC644uid brianway &lt;weichuyang@163.com&gt;sub rsa2048 2017-05-10 [E] [expires: 2019-05-10] 但 Maven 里面的 maven-gpg-plugin 插件默认是使用 gpg 指令，不是 gpg2，所以需要配置 setting.xml 的 profile 123456789101112&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;gpg&lt;/id&gt; &lt;properties&gt; &lt;gpg.executable&gt;gpg2&lt;/gpg.executable&gt; &lt;gpg.passphrase&gt;mypassphrase&lt;/gpg.passphrase&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;activeProfiles&gt; &lt;activeProfile&gt;gpg&lt;/activeProfile&gt;&lt;/activeProfiles&gt; 参考：http://stackoverflow.com/questions/14114528/avoid-gpg-signing-prompt-when-using-maven-release-plugin 发布出问题输入 mvn clean deploy -P release 后，报错如下： 123456789101112131415161718192021222324[INFO] ------------------------------------------------------------------------[INFO] Reactor Summary:[INFO] [INFO] webporter-parent ................................... SUCCESS [ 11.690 s][INFO] webporter-core ..................................... SUCCESS [ 5.208 s][INFO] webporter-data-elasticsearch ....................... SUCCESS [ 2.769 s][INFO] webporter-collector-zhihu .......................... FAILURE [ 7.889 s][INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 28.069 s[INFO] Finished at: 2017-05-11T18:11:44+08:00[INFO] Final Memory: 45M/723M[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal org.sonatype.plugins:nexus-staging-maven-plugin:1.6.7:deploy (injected-nexus-deploy) on project webporter-collector-zhihu: Failed to deploy artifacts: Could not transfer artifact com.github.brianway:webporter-data-elasticsearch:jar:javadoc:1.0-20170511.101142-1 from/to sonatype-nexus-snapshots (https://oss.sonatype.org/content/repositories/snapshots/): Failed to transfer file: https://oss.sonatype.org/content/repositories/snapshots/com/github/brianway/webporter-data-elasticsearch/1.0-SNAPSHOT/webporter-data-elasticsearch-1.0-20170511.101142-1-javadoc.jar. Return code is: 401, ReasonPhrase: Unauthorized. -&gt; [Help 1][ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.[ERROR] Re-run Maven using the -X switch to enable full debug logging.[ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException[ERROR] [ERROR] After correcting the problems, you can resume the build with the command[ERROR] mvn &lt;goals&gt; -rf :webporter-collector-zhihu 搞了几个小时，最后发现是 pom.xml 的 distributionManagement 中 snapshotRepository 与 repository 中的 id 与 setting.xml 中 server 的 id 不一致 导致的。因为我的 pom.xml 是模仿的 webmagic 的 pom.xml，而 settings.xml 的 server 配置却是复制的《将 Smart 构件发布到 Maven 中央仓库》 by 黄勇 中的，结果导致不一样。 我主要从下面这篇文章中找到的灵感 Maven2部署构件到Nexus时出现的Failed to transfer file错误 github 上 release在项目的 pom.xml 中配置 release 的插件 123456789 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;plugin.release.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;tagNameFormat&gt;v@&#123;project.version&#125;&lt;/tagNameFormat&gt; &lt;autoVersionSubmodules&gt;true&lt;/autoVersionSubmodules&gt; &lt;/configuration&gt;&lt;/plugin&gt; 使用下面的指令即可直接在 github 远程仓库生成发行版本 123mvn cleanmvn release:preparemvn release:perform 我实验的结果是，执行 mvn release:prepare 并不会对远程仓库造成影响，再执行 mvn release:perform 才会在 git 远程仓库多出两个 commit 和一个 release 版本，查看提交日志 git log --pretty=oneline，内容如下： 122619dfaafca7a82f70e938f5b6efd6d9f4110554 [maven-release-plugin] prepare for next development iteration01795a07b793930b74dc0cb5e6ce2b43ee3a5434 [maven-release-plugin] prepare release v1.0 参考： maven scm 配置git 用上面的方法，不另外配置的话，commit message 是由 Maven 插件自动生成的。也可以不使用插件发布，自己 commit 上去，然后在 github 上发布。 参考： Creating Releases 创建发布包 构件没有出现在 Staging Repositories按照教程里的步骤，上传构件到 OSS 中后，应该先在 https://oss.sonatype.org/ 中，点击”Staging Repositories” -&gt; 在搜索栏输入你的 groupId -&gt; 勾选你的构件并点击 close -&gt; 点击 tab 栏的 release。 然而我却没有这个步骤，即我上传构件成功后，在 Staging Repositories 中并没有找到自己的构件，但在左边侧栏的 Artifact Search 框输入自己的 groupId 却能搜到我的构件，百思不得其解。最后还是求助 Sonatype 的工作人员才弄清楚，原来是我使用了插件 nexus-staging-maven-plugin 并且默认 autoReleaseAfterClose 是 true 导致的，直接越过了手工 close 的步骤。 Sonatype 工作人员的答复： It sounds like you have the nexus-staging-maven-plugin in your build (assuming you’re using Maven, but what I’m going to say might also apply to other tools) configured to autoReleaseAfterClose. If this is the case, oss.sonatype.org will automatically release your staging repository after it has been successfully closed. oss.sonatype.org is also configured, by default, to drop released staging repositories. Once your artifacts have been released, they will appear in the Releases repository on oss.sonatype.org, and from there they will sync to Maven Central.You shouldn’t expect to see staging repositories if everything worked and if all your components passed the ruleset validations. The fact that you can search for your artifacts on search.maven.org is a good sign. 具体可以参看我提的 issue: OSSRH-31186 参考链接 将 Smart 构件发布到 Maven 中央仓库 by 黄勇 发布Maven构件到中央仓库 by 阿信sxq 将项目发布到Maven中央库 by 路小磊 (截图详细) GPG入门教程 GnuPG的使用入门（gpg2） Working with PGP Signatures Creating Releases 创建发布包 Sonatype OSSRH-31186","tags":[{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"},{"name":"IntelliJ-IDEA","slug":"IntelliJ-IDEA","permalink":"https://brianway.github.io/tags/IntelliJ-IDEA/"},{"name":"Maven","slug":"Maven","permalink":"https://brianway.github.io/tags/Maven/"}]},{"title":"Learning Notes - Understanding the Weird Parts of JavaScript","date":"2017-05-04T06:05:07.000Z","path":"2017/05/04/2017-05-04-Learning-Notes-Understanding-the-Weird-Parts-of-JavaScript/","text":"The learning notes of the MOOC “JavaScript: Understanding the Weird Parts” on Udemy,including most important parts of JavaScript. Course link: JavaScript: Understanding the Weird Parts My Certification: UC-CWVEBCC5 Basic conceptConceptual AsideConceptual Aside: Syntax Parser: a program that reads your code and determines what it does and if its grammer is valid Lexical Environment: where something sits physically in the code you write Execution Context: a wapper to help manage the code that is running Name/Value Pair: a name which maps to a unique value Object: A collection of Name/Value pairs undefined: a special value/a special keyword that JavaScript has within it internally that means that the value hasn’s been set.It means that this is the value that was initially set by JavaScript. single threaded: one command is being executed at a time.It may not be under the hood of the browser. synchronous: one at a time and in order. dynamic typing: you don’t tell the engine what type of data a variable holds,it figures it out while your code is running. operator: a special function that is syntatically (written) differently. coercion: converting a value from one type to another. by value vs. by reference: all primitive types are by value and all objects are by reference. array: collections of anything. inheritance: one object gets access to the properties and methods of another object. built-in function constructors: objects created by them have all the properties and methods on the functions’ prototype property and what’s boxed inside of it is the primitive value itself.The built-in function constructors look like you’re creating primitives but you’re not,you are creating objects that contain primitives with a whole bunch of features. Framework AsideFramework Aside: default value: e.g. window.libName = window.libName || &quot;lib 1&quot; namespace: a container for variables and functions. function overloading: JavaScript doesn’t have it.There are other appoaches to deal with it. whitespace: invisible characters that create literal “space” in your written code,like carriage returns,tabs, or spaces. IIFEs and safe code: by wrapping code in an immediately invoked function, does not interfere with crash into,or be interfered by any other code that might be included in your application. function factory: a function that returns or makes other things for you. Dangerous AsideDangerous Aside: automatic semicolon insertion: if you’re going to return an object from a function,you need to type the { right after return rather than in a new line. new and functions: don’t forget the key word new in front of the function constructors,or you’ll probably get undefined returned and cause in trouble.You’d better always have a capital letter as the name of the constructor. built-in function constructors: strange things can happen during comparison with operator and coercion.In general,it’s better not to use them.Use literals. arrays and for..in: in the case of arrays,don’t use for..in because arrays are objects in JavaScrip and their items are added properties. Execution Context and Lexical EnvironmentExecution ContextExecution Context(Global) was created at global level by the JavaScrip engine, and two things were also created for you: Global Object A special valiable called this When you open the file inside your browser, this object is the window object,which refers to the browser window.That is to say:this object equals window object at global level in this case. Global means “Not Inside a Funciton”. Global variables and functions get attached to the global object. Execution Context hoisting: variables and functions are to some degree available even though they’re written later in the code. The phenomenon is because the exection context is created in two phases. creation phase: global object and this set up in memory,an outer environment, also set up memory space for variables and functions(this step called hoisting). execution phase: runs the code you’ve written line by line,interpreting it,covering it,compling it,executing it. creation phase All variables in JavaScript are initally set to undefined,and functions are sitting in memory in their entirety. Function Invocationinvocation: running a function.In JavaScrip,by using parenthesis(). Execution Stack: top execution context in the stack is the currently executing function.A new execution context is created and put on top of the stack for the function invoked,and popped off the stack when the function finished. Variable Environment: where the variables live.And how they relate to each other in memory. Every execution context has a reference to its outer environment.(that is to say,to its lexical environment) execution context vs. outer environment reference: execution context is created when you invoke a function. outer environment reference is created for the execution context and it looks at where the code is physically written in the JavaScrip file.(A different way of thinking about it: the outer reference is to the execution context in which the function was created.) Here is an example: 12345678910111213141516171819202122function c()&#123; console.log(myVar);//1 (4th line)&#125;function b() &#123; var myVar; console.log(myVar);//undefined (3rd line)&#125;function a() &#123; var myVar = 2; console.log(myVar);//2 (2nd line) b(); c();&#125;var myVar = 1;console.log(myVar);//1 (1st line)a();console.log(myVar);//1 (5th line)// result is (five lines): 1 2 undefined 1 1 Scope Chain:those links of outer environment references where you can access variables. Scope Chain scope: where a variable is available in your code. asynchronous: more than one at a time.(Asynchronous part is about what’s happening outside the JavaScrip engine rather than inside it.) asynchronous Any events that happen outside of the engine get placed into the event queue,an if the execution stack is empty,if JavaScrip isn’t working on anything else currently,it’ll process those events in the order they happend via the event loop synchronously. Types and OperatorsThere are six primitive types in JavaScrip. primitive type: a type of data that represents a single value.That is,not an object. undefined: represents lack of existence null: represents lack of existence boolean: true or false number: floating point number.There’s only one ‘number’ type. string: a sequence of characters.Both &#39; and &quot; can be used. symbol: used in ES6 precedence and associativity: operator precedence: which operator function gets called first. associativity: what order operator functions get called in: left-to-right or right-to-left. Reference: Operator precedence == vs. === == will try to coerce the values if the two values are not the same type. === doesn’t try to coerce the values.It’s strict equality. Reference: Equality comparisons and sameness The example below shows the usage of coercion to check for existence and is used in a lot of really great frameworks and libraries. 123456var a;//goes to internet and look for a valueif(a)&#123; console.log(\"Something is there\");&#125; or opertator ||: if you passed it two values that can be coerced to true and false,it will return the first one that coerces to true. Objects and FunctionsObject have properties and methods: Primitive “property” Object “property” Function “method” Object Both [] and . can find the property on the object and give you the value. 123var person = new Object();person[\"firstname\"] = \"Brian\";//use brackets []person.lastname = \"Way\";//use dot . Object literal vs. JSON string The object literal syntax uses the curly braces to define name and value pairs separated by colons. JSON stands for JavaScript Object Notation.It looks like object literal syntax except for some differences.For example,property names have to be wrapped in quotes.JSON is technically a subset of the object literal syntax. JSON.stringify({firstname : &quot;Brian&quot;, student: true}) JSON.parse(&#39;{&quot;firstname&quot;:&quot;Brian&quot;,&quot;student&quot;:true}&#39;); First class functions: everything you can do with other types, you can do with functions.(Assign them to variables,pass them around,create them on the fly.) In JavaScrip,functions are objects.The function is an object with other properties,that is to say, a function is a special type of object.Two main other properties: it has a hidden optional name property which can be anonymous then if you don’t have a name. we have code property that contains the code and that code property is invocable so we can run the code. function expression: a unit of code that results in a value. Statement just does work and an expression results in a value. mutate: to change something. The keyword this points to what? Let’s see an example. 12345678910111213141516var c = &#123; name: 'The c object', log: function() &#123; this.name = 'Updated c object'; //this points to c object console.log(this); var setname = function(newname) &#123; this.name = newname; //this points to the global object &#125; setname('Updated again! The c object'); console.log(this); //this points to c object &#125;&#125;c.log(); In the example above,the internal function setname when its execution context was created,the this keyword points to the global object,even though it’s sitting kind of inside an object that I created.To avoid this case,just use var self = this;(set equal to by reference) as the very first line of your object method. An array can be created in the following formmat: var arr = new Array(); var arr = [1, 2, 3]; Array in JavaScript is zero based and dynamically typed,it figures out what type of things are on the fly. arguments: the parameters you pass to a function.JavaScript gives you a keyword of the same name which contains them all.Although arguments doesn’t contain the names of arguments,just the values,you could use it like an array.A new thing is called a spread parameter....other means take everything else and wrap it into an array of this name “other”. IIFEsIIFEs - an immediately invoked function expressions 1234// using an Immediately Invoked Function Expression (IIFE)var greeting = function(name) &#123; return 'Hello ' + name;&#125;('John'); To wrap your function in parentheses.This is when you want a function expression instead of normal function statement. 123456789101112//valid syntax but output nothing(function (name) &#123; console.log(\"Hello \" + name);&#125;);// IIFE(function (name) &#123; console.log(\"Hello \" + name);&#125;(\"Brian\"));//also OK(function (name) &#123; console.log(\"Hello \" + name);&#125;)(\"Brian\"); understanding closuresEven though the outer function ended/finished,any functions created inside of it when they are called will still have a reference to that outer function’s memory. closure Outer function is gone,the exectution context is gone.But what’s in memory for that execution context isn’t and JavaScript engine makes sure that the inner function can still go down the scope chain and find it. closure In this way we say that the execution context has closed in its outer variables.And so this phenomenon,of it closing in all the variables that it’s supposed to have access to,is called a closure. This is the feature of the language JavaScript,very important. callback function: a function you give to another function,to be run when the other function is finished. call(),apply() and bind()All functions in JavaScript also get access to some special functions/methods, on their own.So all functions have access to a call method,an apply method and a bind method. bind() creates a new copy of whatever function you’re calling it on.And then whatever object you pass to this method is what the this variable points to by reference. call() invokes the function you’re calling it on.Also let you decide what the this variable will be.Unlike bind() which creates a new copy,call() actually executes it. apply() does the exact same thing as call() except that it wants an array of parameters as the second parameter rather than just the normal list. These functions can be used for function borrowing and function currying. function currying: creating a copy of a function but with some preset parameters. some open source libraries: underscore.js lodash moment.js Object-Oriented JavaScript and Prototypal InheritanceClassical vs. Prototypal Inheritance: Classical Inheritance: verbose Prototypal Inheritance: simple All objects include functions hava a prototype property.The prototype is simply a reference to another object. The prototype chain,the concept of prototypes is just I have this special reference in my object that says where to look for other properties and methods without manually going dot prototype. prototype chain reflection: an object can look at itself,listening and changing its properties and methods. tip: the “for in” actually reached out and grabbed every property and method not just on the object but also on the object’s prototype extend: here we just talk about the extend function in underscore.You can combine and compose objects in this extend pattern with relection,not just the prototype pattern. Building Objectsfunction constructors: a normal function that is used to construct objects.(The this variable points a new empty object,and that object is returned from the function automatically.) There are many approaches to building an object: object literal syntax: {} the key word new: var john = new Person(); first, an empty object is created. then, it invokes the function with the this variable pointing to that empty object. last, return the object if you don’t return anything explicitly,or return what is returned in the function. Object.create: creates an empty object with its prototype pointing at whatever you have passed in to Object.create. you can simply override/hide properties and methods on those created objects by setting the values of those properties and methods on new objects themselves. ES6 and classes: another approach but still works the same under the hood,just syntactic sugar. key word class: class is not the template or definition like other languages such as Java/C++,class is also an object. key word extends: sets the prototype(__prototype__) for any of the objects created with this class. .prototype: this prototype property of all functions is where the prototype chain points for any objects created using that function as a constructor. The prototype property on a function is not the prototype property(__prototype__) of the function. It’s used only by the new operator.In other cases,it’s just an empty object,hanging out there. It’s the prototype of any objects created if you’re using the function as a function constructor. takes up less memory space if you add method to the prototype because it’ll only have one,while it’ll have many copies if you add it to function constructor. polyfill: code that adds a feature which the engine may lack. 123456789101112// polyfillif (!Object.create) &#123; Object.create = function (o) &#123; if (arguments.length &gt; 1) &#123; throw new Error('Object.create implementation' + ' only accepts the first parameter.'); &#125; function F() &#123;&#125; F.prototype = o; return new F(); &#125;;&#125; syntactic sugar: a different way to type something that doesn’t change how it works under the hood. Odds and Endsinitialization: when come accross a large initialization of objects,don’t get overwhelmed by the syntax. typeof and instanceof: typeof: it’s an operator(essentially a function) that takes a parameter returns a string.It will tell you under most cases what something is. Object.prototype.toString.call(arr) gets array type([object Array]) returned,or you’ll get object returned. typeof undefined returns undefined typeof null returns object.It’s been a bug since forever. instanceof: tells if any object is down the prototype chain.It will tell you what something has in its prototype chain. strict mode on the MDN transpile: convert the syntax of one programming language to another. Typescript Traceur(Traceur is a JavaScript.next-to-JavaScript-of-today compiler) features of ECMAScript 6","tags":[{"name":"前端","slug":"前端","permalink":"https://brianway.github.io/tags/前端/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://brianway.github.io/tags/JavaScript/"}]},{"title":"Java８新特性总览","date":"2017-03-28T22:30:07.000Z","path":"2017/03/29/2017-03-29-javase-java8/","text":"本文主要介绍 Java 8 的新特性，包括 Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等等各个方面。 写在前面 本文是《Java 8 in Action》的读书笔记，主要提炼了概念性的知识/观点性的结论，对推导和阐释没有摘录 文中涉及到的源码请参考我在 GitHub 上的项目 java-learning (地址为 https://github.com/brianway/java-learning)的 Java 8 模块部分，比书中参考源码分类更清晰 基础知识Java 8 的主要想法： stream API 向方法传递代码的技巧(方法引用、Lambda) 接口中的默认方法 三个编程概念： 流处理（好处：更高抽象，免费并行） 行为参数化（通过 API 来传递代码） 并行与共享的可变数据 函数式编程范式的基石： 没有共享的可变数据 将方法和函数即代码传递给其它方法的能力 Java 8 使用 Stream API 解决了两个问题： 集合处理时的套路和晦涩 难以利用多核 Collection 主要是为了存储和访问数据，而 Stream 则主要用于描述对数据的计算。 通过行为参数化来传递代码行为参数化：类似于策略设计模式 类 -&gt; 匿名类 -&gt; Lambda 表达式，代码越来越简洁 Lambda 表达式Lambda 表达式：简洁地表示可传递的匿名函数的一种方式 重点留意这四个关键词：匿名、函数、传递、简洁 三个部分： 参数列表 箭头 Lambda 主体 Lambda 基本语法，下面两者之一： (parameters) -&gt; expression (parameters) -&gt; { statements; } 函数式接口：只定义一个抽象方法的接口。函数式接口的抽象方法的签名称为 函数描述符 Lambda 表达式允许你以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口(一个具体实现)的实例。 常用函数式接口有：Predicate, Consumer, Function, Supplier 等等。 Lambda 的类型是从使用 Lambda 的上下文推断出来的。上下文中 Lambda 表达式需要的类型称为目标类型。 方法引用方法引用主要有三类： (1) 指向静态方法的方法引用 Lambda: (args) -&gt; ClassName.staticMethod(args) 方法引用：ClassName::staticMethod (2) 指向任意类型实例方法的方法引用 Lambda: (arg0, rest) -&gt; arg0.instanceMethod(rest) 方法引用：ClassName::instanceMethod(arg0 是 ClassName 类型的) (3) 指向现有对象的实例方法的方法引用 Lambda: (args) -&gt; expr.instanceMethod(args) 方法引用：expr::intanceMethod 方法引用就是替代那些转发参数的 Lambda 表达式的语法糖 流(Stream API)引入的原因： 声明性方式处理数据集合 透明地并行处理，提高性能 流 的定义：从支持数据处理操作的源生成的元素序列 两个重要特点： 流水线 内部迭代 流与集合： 集合与流的差异就在于什么时候进行计算 集合是内存中的数据结构，包含数据结构中目前所有的值 流的元素则是按需计算/生成 另一个关键区别在于遍历数据的方式 集合使用 Collection 接口，需要用户去做迭代，称为外部迭代 流的 Streams 库使用内部迭代 流操作主要分为两大类： 中间操作：可以连接起来的流操作 终端操作：关闭流的操作，触发流水线执行并关闭它 流的使用： 一个数据源（如集合）来执行一个查询； 一个中间操作链，形成一条流的流水线； 一个终端操作，执行流水线，并能生成结果。 流的流水线背后的理念类似于构建器模式。常见的中间操作有 filter,map,limit,sorted,distinct；常见的终端操作有 forEach,count,collect。 使用流 筛选 谓词筛选：filter 筛选互异的元素：distinct 忽略头几个元素：limit 截短至指定长度：skip 映射 对流中每个元素应用函数：map 流的扁平化：flatMap 查找和匹配 检查谓词是否至少匹配一个元素：anyMatch 检查谓词是否匹配所有元素：allMatch/noneMatch 查找元素：findAny 查找第一个元素：findFirst 归约（折叠）：reduce(初值，结合操作) 元素求和 最大值和最小值 anyMatch,allMatch,noneMatch 都用到了短路；distinct,sorted是有状态且无界的，skip,limit,reduce是有状态且有界的。 原始类型流特化：IntStream,DoubleStream,LongStream，避免暗含的装箱成本。 映射到数值流：mapToInt,mapToDouble,mapToLong 转换回流对象：boxed 默认值：OptionalInt,OptionalDouble,OptionalLong 数值范围： range:[起始值，结束值) rangeClosed:[起始值，结束值] 构建流 由值创建流：Stream.of,Stream.empty 由数组创建流：Arrays.stream(数组变量) 由文件生成流：Files.lines 由函数生成流：创建无限流， 迭代： Stream.iterate 生成：Stream.generate 用流收集数据对流调用 collect 方法将对流中的元素触发归约操作（由 Collector 来参数化）。 Collectors 实用类提供了许多静态工厂方法，用来创建常见收集器的实例，主要提供三大功能： 将流元素归约和汇总为一个值 元素分组 元素分区 归约和汇总(Collectors 类中的工厂方法)： 统计个数：Collectors.counting 查找流中最大值和最小值：Collectors.maxBy,Collectors.minBy 汇总：Collectors.summingInt,Collectors.averagingInt,summarizingInt/IntSummaryStatistics。还有对应的 long 和 double 类型的函数 连接字符串：joining 广义的归约汇总：Collectors.reducing(起始值，映射方法，二元结合)/Collectors.reducing(二元结合)。Collectors.reducing 工厂方法是所有上述特殊情况的一般化。 collect vs. reduce，两者都是 Stream 接口的方法，区别在于： 语意问题 reduce 方法旨在把两个值结合起来生成一个新值，是不可变的归约； collect 方法设计就是要改变容器，从而累积要输出的结果 实际问题 以错误的语义使用 reduce 会导致归约过程不能并行工作 分组和分区 分组：Collectors.groupingBy 多级分组 按子数组收集数据: maxBy 把收集器的结果转换为另一种结果 collectingAndThen 与 groupingBy 联合使用的其他收集器例子：summingInt,mapping 分区：是分组的特殊情况，由一个谓词作为分类函数(分区函数) 收集器接口：Collector，部分源码如下： 1234567public interface Collector&lt;T, A, R&gt; &#123; Supplier&lt;A&gt; supplier(); BiConsumer&lt;A, T&gt; accumulator(); Function&lt;A, R&gt; finisher(); BinaryOperator&lt;A&gt; combiner(); Set&lt;Characteristics&gt; characteristics();&#125; 其中 T、A、R 分别是流中元素的类型、用于累积部分结果的对象类型，以及 collect 操作最终结果的类型。 建立新的结果容器：supplier 方法 将元素添加到结果容器：accumulator 方法，累加器是原位更新 对结果容器应用最终转换： finisher 方法 合并两个结果容器：combiner 方法 定义收集器的行为： characteristics 方法，Characteristics 包含 UNORDERED,CONCURRENT,IDENTITY_FINISH 前三个方法已经足以对流进行顺序归约，实践中实现会复杂点，一是因为流的延迟性质，二是理论上可能要进行并行归约。 Collectors.toList 的源码实现： 12345678public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123; return new CollectorImpl&lt;&gt;( (Supplier&lt;List&lt;T&gt;&gt;) ArrayList::new, List::add, (left, right) -&gt; &#123; left.addAll(right); return left; &#125;, CH_ID);&#125;// static final Set&lt;Collector.Characteristics&gt; CH_ID = Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH)); 并行流并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。 关于并行流的几点说明： 选择适当的数据结构往往比并行化算法更重要，比如避免拆箱装箱的开销，使用便于拆分的方法而非 iterate。 同时，要保证在内核中并行执行工作的时间比在内核之间传输数据的时间长。 使用并行流时要注意避免共享可变状态。 并行流背后使用的基础架构是 Java 7 中引入的分支/合并框架。 分支/合并框架 分支/合并框架的目的是以递归的方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。 RecursiveTast&lt;R&gt; 有一个抽象方法 compute，该方法同时定义了： 将任务拆分成子任务的逻辑 无法/不方便再拆分时，生成单个子任务结果的逻辑 对任务调用 fork 方法可以把它排进 ForkJoinPool，同时对左边和右边的子任务调用 fork 的效率要比直接对其中一个调用 compute 低，因为可以其中一个子任务可以重用同一线程，减少开销 工作窃取：用于池中的工作线程之间重新分配和平衡任务。 Spliterator 代表“可分迭代器”，用于遍历数据源中的元素。可以延迟绑定。 高效 Java 8 编程重构、测试、调试 改善代码的可读性 用 Lambda 表达式取代匿名类 用方法引用重构 Lambda 表达式 用 Stream API 重构命令式的数据处理 增加代码的灵活性 采用函数接口 有条件的延迟执行 环绕执行 使用 Lambda 重构面向对象的设计模式： 策略模式 一个代表某个算法的接口 一个或多个该接口的具体实现，它们代表的算法的多种实现 一个或多个使用策略对象的客户 模版方法 传统：继承抽象类，实现抽象方法 Lambda：添加一个参数，直接插入不同的行为，无需继承 观察者模式 执行逻辑较简单时，可以用 Lambda 表达式代替类 责任链模式 工厂模式 传统：switch case 或者 反射 Lambda：创建一个 Map，将名称映射到对应的构造函数 调试的方法： 查看栈跟踪：无论 Lambda 表达式还是方法引用，都无法显示方法名，较难调试 输出日志：peek 方法，设计初衷就是在流的每个元素恢复运行之前，插入执行一个动作 默认方法Java 8 中的接口现在支持在声明方法的同时提供实现，通过以下两种方式可以完成： Java 8 允许在接口内声明 静态方法 Java 8 引入了一个新功能：默认方法 默认方法的引入就是为了以兼容的方式解决像 Java API 这样的类库的演进问题的。它让类可以自动地继承接口的一个默认实现。 向接口添加新方法是 二进制兼容 的，即如果不重新编译该类，即使不实现新的方法，现有类的实现依旧可以运行。默认方法 是一种以 源码兼容 方式向接口内添加实现的方法。 抽象类和抽象接口的区别： 一个类只能继承一个抽象类，但一个类可以实现多个接口 一个抽象类可以通过实例变量保存一个通用状态，而接口不能有实例变量 默认方法的两种用例： 可选方法：提供默认实现，减少空方法等无效的模版代码 行为的多继承 类型的多继承 利用正交方法的精简接口 组合接口 如果一个类使用相同的函数签名从多个地方继承了方法，解决冲突的三条规则： 类中的方法优先级最高 若 1 无法判断，那么子接口的优先级更高，即优先选择拥有最具体实现的默认方法的接口 若 2 还无法判断，那么继承了多个接口的类必须通过显示覆盖和调用期望的方法，显示地选择使用哪一个默认方法的实现。 Optional 取代 nullnull 的问题： 错误之源：NullPointerException 问题 代码膨胀：各种 null 检查 自身无意义 破坏了 Java 的哲学: null 指针 在 Java 类型系统上开了个口子：null 不属于任何类型 java.util.Optional&lt;T&gt; 对可能缺失的值建模,引入的目的并非是要消除每一个 null 引用，而是帮助你更好地设计出普适的 API。 创建 Optional 对象,三个静态工厂方法： Optional.empty：创建空的 Optional 对象 Optional.of：依据非空值创建 Optional 对象，若传空值会抛 NPE Optianal.ofNullable：创建 Optional 对象，允许传空值 使用 map 从 Optional 对象提取和转换值,Optional 的 map 方法： 若 Optional 包含值，将该值作为参数传递给 map，对该值进行转换后包装成 Optional 若 Optional 为空，什么也不做，即返回 Optional.empty 使用 flatMap 链接 Optional 对象： 由于 Optional 的 map 方法会将转换结果生成 Optional，对于返回值已经为 Optional 的，就会出现 Optional&lt;Optional&lt;T&gt;&gt; 的情况。类比 Stream API 的 flatMap，Optional 的 flapMap 可以将两层的 Optional 对象转换为单一的 Optional 对象。 简单来说，返回值是 T 的，就用 map 方法；返回值是 Optional&lt;T&gt; 的，就用 flatMap 方法。这样可以使映射完返回的结果均为 Optional&lt;T&gt; 参数为 null 时，会由 Objects.requireNonNull 抛出 NPE；参数为空的 Optional 对象时，返回 Optional.empty 参数非 null/空的 Optional 对象时，map 返回 Optional；flatMap 返回对象本身 原因可以参考这两个方法的源码： 1234567891011121314151617public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Optional.ofNullable(mapper.apply(value)); &#125;&#125;public&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper) &#123; Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else &#123; return Objects.requireNonNull(mapper.apply(value)); &#125;&#125; 另外，Optional 类设计的初衷仅仅是要支持能返回 Optional 对象的方法。设计时并未考虑将其作为类的字段，所以并未实现 Serializable 接口。 默认行为及解引用 Optional 对象： get(): 返回封装的变量值，或者抛出 NoSuchElementException orElse(T other): 提供默认值 orElseGet(Supplier&lt;? extends T&gt; other): orElse 方法的延迟调用版 orElseThrow(Supplier&lt;&gt; extends X&gt; exceptionSupplier): 类似 get，但可以定制希望抛出的异常类型 ifPresent(Consumer&lt;? super T&gt;): 变量存在时可以执行一个方法 CompletableFuture:组合式异步编程Future 接口有一定的局限性。CompletableFuture 和 Future 的关系就跟 Stream 和 Collection 的关系一样。 同步 API 与 异步 API 同步 API：调用方需要等待被调用方结束运行，即使两者是在不同的线程中运行 异步 API：直接返回，被调用方完成之前是将任务交给另一个线程去做，该线程和调用方是异步的，返回方式有如下两种： 要么通过回调函数 要么由调用方再执行一个“等待，直到计算完成”的方法调用 使用工厂方法 supplyAsync 创建 CompletableFuture 比较方便，该方法会抛出 CompletableFuture 内发生问题的异常。 代码的阻塞问题的解决方案及如何选择： 使用并行流对请求进行并行操作：适用于计算密集型的操作，且没有 I/O ，此时推荐使用 Stream 接口 使用 CompletableFuture 发起异步请求(可以使用定制的执行器)：若涉及等待 I/O 的操作，使用 CompletableFuture 灵活性更好 注意，CompletableFuture 类中的 join 方法和 Future 接口中的 get 有相同的含义，join 不抛出检测异常。另外，需要使用两个不同的 Stream 流水线而不是同一个，来避免 Stream的延迟特性引起顺序执行 构造同步和异步操作： thenApply 方法不会阻塞代码的执行 thenCompose 方法允许你对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作 thenCombine 方法将两个完全不相干的 CompletableFuture 对象的结果整合起来 调用 get 或者 join 方法只会造成阻塞，响应 CompletableFuture 的 completion 事件可以实现等所有数据都完备之后再呈现。thenAccept 方法在每个 CompletableFuture 上注册一个操作，该操作会在 CompletableFuture 完成执行后使用它的返回值，即 thenAccept 定义了如何处理 CompletableFuture 返回的结果，一旦 CompletableFuture 计算得到结果，它就返回一个 CompletableFuture&lt;Void&gt;。 新的时间和日期 API原来的 java.util.Date 类的缺陷： 这个类无法表示日期，只能以毫秒的精度表示时间 易用性差：年份起始 1900 年，月份从 0 起始 toString 方法误导人：其实并不支持时区 相关类同样缺陷很多： java.util.Calender 类月份依旧从 0 起始 同时存在 java.util.Date 和 java.util.Calender，徒添困惑 有的特性只在某一个类提供，如 DateFormat 方法 DateFormat 不是线程安全的 java.util.Date 和 java.util.Calender 都是可变的 一些新的 API（java.time 包） LocalDate: 该类实例是一个不可变对象，只提供简单的日期，并不含当天的时间信息，也不附带任何和时区相关的信息 LocalTime: 时间(时、分、秒) LocalDateTime: 是 LocalDate 和 LocalTime 的合体，不含时区信息 Instant: 机器的日期和时间则使用 java.time.Instant 类对时间建模，以 Unix 元年时间开始所经历的秒数进行计算 Temporal: 上面四个类都实现了该接口，该接口定义了如何读取和操纵为时间建模的对象的值 Duration: 创建两个 Temporal 对象之间的 duration。LocalDateTime 和 Instant 是为不同目的设计的，不能混用，且不能传递 LocalDate 当参数。 Period: 得到两个 LocalDate 之间的时长 LocalDate，LocalTime，LocalDateTime 三个类的实例创建都有三种工厂方法：of,parse,now Duration，Period 有很多工厂方法：between,of,还有 ofArribute 之类的 以上日期－时间对象都是不可修改的，这是为了更好地支持函数式编程，确保线程安全 操纵时间： withArribute 创建一个对象的副本，并按照需要修改它的属性。更一般地，with 方法。但注意，该方法并不是修改原值，而是返回一个新的实例。类似的方法还有 plus,minus 等 使用 TemporalAdjuster 接口: 用于定制化处理日期，函数式接口，只含一个方法 adjustInto TemporalAdjusters: 对应的工具类，有很多自带的工厂方法。（如果想用 Lamda 表达式定义 TemporalAdjuster 对象，推荐使用 TemporalAdjusters 类的静态工厂方法 ofDateAdjuster） 打印输出及解析日期－时间对象：主要是 java.time.format 包，最重要的类是 DateTimeFormatter 类，所有该类的实例都是 线程安全 的，所以可以单例格式创建格式器实例。 处理不同的时区和历法使用 java.time.ZoneId 类，该类无法修改。 123// ZoneDateTime 的组成部分ZonedDateTime = LocalDateTime + ZoneId = (LocalDate + LocalTime) + ZoneId 结语本文主要对 Java 8 新特性中的 Lambda 表达式、Stream API、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API，等方面进行了简单的介绍和罗列，至于更泛化的概念，譬如函数式编程、Java 语言以外的东西没有介绍。当然，很多细节和设计思想还需要进一步阅读官方文档/源码，在实战中去体会和运用。 参考资料 《Java 8 in Action》(中文版)／(英文版) Java 8新特性：全新的Stream API Java 8 中的 Streams API 详解 另外附上 lucida 的几篇译文： 深入理解Java 8 Lambda（语言篇——lambda，方法引用，目标类型和默认方法） 深入理解Java 8 Lambda（类库篇——Streams API，Collectors和并行） 深入理解 Java 8 Lambda（原理篇——Java 编译器如何处理 lambda）暂时还没","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://brianway.github.io/tags/读书笔记/"}]},{"title":"大型网站技术架构-入门梳理","date":"2017-01-18T05:44:07.000Z","path":"2017/01/18/2017-01-18-reading-note-architecture-design/","text":"罗列了大型网站架构涉及到的概念，附上了简单说明 前言 本文是对《大型网站架构设计》(李智慧 著)一书的梳理，类似文字版的“思维导图” 全文主要围绕“性能，可用性，伸缩性，扩展性，安全”这五个要素 性能，可用性，伸缩性这几个要素基本都涉及到应用服务器，缓存服务器，存储服务器这几个方面 概述 三个纬度：演化、模式、要素 五个要素： 性能，可用性，伸缩性，扩展性，安全 演化历程图例可参考 大型网站架构演化历程： 初始阶段的网站架构：一台服务器，上面同时拥有应用程序，数据库，文件，等所有资源。例如 LAMP 架构 应用和数据服务分离：三台服务器（硬件资源各不相同），分别是应用服务器，文件服务器和数据库服务器 使用缓存改善网站性能：分为两种，缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器的远程缓存 使用应用服务器集群改善网站并发处理能力：通过负载均衡调度服务器来将访问请求分发到应用服务器集群中的任何一台机器 数据库读写分离：数据库采用主从热备，应用服务器在写数据时访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。应用服务器使用专门的数据访问模块从而对应用透明 使用反向代理和 CDN 加速网站响应：这两者基本原理都是缓存。反向代理部署在网站的中心机房，CDN 部署在网络提供商的机房 使用分布式文件系统和分布式数据库系统：数据库拆分的最后手段，更常用的是业务分库 使用 NoSQL 和搜索引擎：对可伸缩的分布式有更好的支持 业务拆分：将整个网站业务拆分成不同的应用，每个应用独立部署维护，应用之间通过超链接建立联系/消息队列进行数据分发/访问同一数据存储系统 分布式服务：公共业务提取出来独立部署 架构演化-分布式服务 演化的价值观 大型网站架构的核心价值是随网站所需灵活应对 驱动大型网站技术发展的主要力量是网站的业务发展 误区 一味追随大公司的解决方案 为了技术而技术 企图用技术解决所有问题 架构模式模式的关键在于模式的可重复性 分层：横向切分 分割：纵向切分 分布式：分层和分割的主要目的是为了切分后的模块便于分布式部署。常用方案： 分布式应用和服务 分布式静态资源 分布式数据和存储 分布式计算 分布式配置，分布式锁，分布式文件，等等 集群：多台服务器部署相同的应用构成一个集群，通过负载均衡设备共同对外提供服务 缓存：将数据放距离计算最近的位置加快处理速度，改善性能第一手段，可以加快访问速度，减小后端负载压力。使用缓存 两个前提条件 ：1.数据访问热点不均衡；2.数据某时段内有效，不会很快过期 CDN 反向代理 本地缓存 分布式缓存 异步：旨在系统解耦。异步架构是典型的消费者生产者模式，特性如下： 提高系统可用性 加快网站访问速度 消除并发访问高峰 冗余：实现高可用。数据库的冷备份和热备份 自动化：包括发布过程自动化，自动化代码管理，自动化测试，自动化安全检测，自动化部署，自动化监控，自动化报警，自动化失效转移，自动化失效恢复，自动化降级，自动化分配资源 安全：密码，手机校验码，加密，验证码，过滤，风险控制 核心要素架构是“最高层次的规划，难以改变的规定”。主要关注五个要素： 性能 可用性(Availability) 伸缩性(Scalability) 扩展性(Extensibility) 安全性 架构下面依次对这五个要素进行归纳 高性能性能的测试指标主要有： 响应时间：指应用执行一个操作需要的时间 并发数：指系统能够同时处理请求的数目 吞吐量：指单位时间内系统处理的请求数量 性能计数器：描述服务器或者操作系统性能的一些数据指标 性能测试方法： 性能测试 负载测试 压力测试 稳定性测试 性能测试曲线 性能优化,根据网站分层架构，可以分为三大类： Web 前端性能优化 浏览器访问优化 减少 http 请求 使用浏览器缓存 启用压缩 CSS 放在页面最上面，JavaScript 放在页面最下面 减少 Cookie 传输 CDN 加速：本质是一个缓存，一般缓存静态资源 反向代理 保护网站安全 通过配置缓存功能加速 Web 请求 实现负载均衡 应用服务器性能优化：主要手段有 缓存、集群、异步 分布式缓存(网站性能优化第一定律：优化考虑使用缓存优化性能) 异步操作(消息队列，削峰作用) 使用集群 代码优化 多线程(设计为无状态，使用局部对象，并发访问资源使用锁) 资源复用(单例，对象池) 数据结构 垃圾回收 存储服务器性能优化 机械硬盘 vs. 固态硬盘 B+ 树 vs. LSM 树 RAID vs. HDFS 高可用 高可用的网站架构：目的是保证服务器硬件故障时服务依然可用、数据依然保存并能够被访问，主要手段数据和服务的冗余备份及失效转移 高可用的应用：显著特点是应用的无状态性 通过负载均衡进行无状态服务的失效转移 应用服务器集群的 Session 管理 Session 复制 Session 绑定 利用 Cookie 记录 Session Session 服务器 高可用的服务：无状态的服务，可使用类似负载均衡的失效转移策略，此外还有如下策略 分级管理 超时设置 异步调用 服务降级 幂等性设计 高可用的数据：主要手段是数据备份和失效转移机制 CAP 原理 数据一致性(Consisitency) 数据可用性(Availibility) 分区耐受性(Partition Tolerance) 数据备份 冷备：缺点是不能保证数据最终一致和数据可用性 热备：分为异步热备和同步热备 失效转移：由以下三部分组成 失效确认 访问转移 数据恢复 高可用网站的软件质量保证 网站发布 自动化测试 预发布验证 代码控制 主干开发、分支发布 分支开发、主干发布 自动化发布 灰度发布 网站运行监控 监控数据采集 用户行为日志采集（服务器端和客户端） 服务器性能监控 运行数据报告 监控管理 警报系统 失效转移 自动优雅降级 伸缩性大型网站的“大型”是指： 用户层面：大量用户及大量访问 功能方面：功能庞杂，产品众多 技术层面：网站需要部署大量的服务器 伸缩性的分为如下几个方面 网站架构的伸缩性设计 不同功能进行物理分离实现伸缩 纵向分离(分层后分离) 横向分离(业务分割后分离) 单一功能通过集群规模实现伸缩 应用服务器集群的伸缩性设计 HTTP 重定向负载均衡 DNS 域名解析负载均衡 反向代理负载均衡(在 HTTP 协议层面，应用层负载均衡) IP 负载均衡(在内核进程完成数据分发) 数据链路层负载均衡(数据链路层修改 mac 地址，三角传输模式，LVS) 负载均衡算法 轮询(Round Robin, RR) 加权轮询(Weighted Round Robin, WRR) 随机(Random) 最少链接(Least Connections) 源地址散列(Source Hashing) 分布式缓存集群的伸缩性设计 Memcached 分布式缓存集群的访问模型 Memcached 客户端（包括 API，路由算法，服务器列表，通信模块） Memcached 服务器集群 Memcached 分布式缓存集群的伸缩性挑战 分布式缓存的一致性 Hash 算法(一致性 Hash 环，虚拟层) 数据存储服务集群的伸缩性设计 关系数据库集群的伸缩性设计 NoSQL 数据库的伸缩性设计 可扩展系统架构设计层面的“开闭原则” 构建可扩展的网站架构 利用分布式消息队列降低耦合性 事件驱动架构(Event Driven Architecture) 分布式消息队列 利用分布式服务打造可复用的业务平台 Web Service 与企业级分布式服务 大型网站分布式服务的特点 分布式服务框架设计(Thrift, Dubbo) 可扩展的数据结构(如 ColumnFamily 设计) 利用开放平台建设网站生态圈 安全XSS 攻击和 SQL 注入攻击是构成网站应用攻击最主要的两种手段，此外还包括 CSRF,Session 劫持等手段。 攻击与防御 XSS 攻击：跨站点脚本攻击（Cross Site Script） 反射型 持久型 XSS 防御手段 消毒(即对某些 html 危险字符转义) HttpOnly 注入攻击 SQL 注入攻击 OS 注入攻击 注入防御 避免被猜到数据库表结构信息 消毒 参数绑定 CSRF 攻击：跨站点请求伪造（Cross Site Request Forgery） CSRF 防御：主要手段是识别请求者身份 表单 Token 验证码 Referer Check 其他攻击和漏洞 Error Code HTML 注释 文件上传 路径遍历 Web 应用防火墙（ModSecurity） 网站安全漏洞扫描 信息加密技术及密钥安全管理 单向散列加密：不同输入长度的信息通过散列计算得到固定长度的输出 不可逆，非明文 可加盐(salt)增加安全性 输入的微小变化会导致输出完全不同 对称加密：加密和解密使用同一个密钥 非对称加密 信息传输：公钥加密，私钥解密 数字签名：私钥加密，公钥解密 密钥安全管理：信息安全传输是靠密钥保证的，改善手段有： 把密钥和算法放在一个独立的服务器上 将加解密算法放在应用系统中，密钥放在独立服务器 信息过滤与反垃圾 文本匹配 分类算法 黑名单","tags":[{"name":"总结","slug":"总结","permalink":"https://brianway.github.io/tags/总结/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://brianway.github.io/tags/读书笔记/"}]},{"title":"爬取知乎60万用户信息之后的简单分析","date":"2016-12-20T05:03:07.000Z","path":"2016/12/20/2016-12-20-webporter-zhihu-user-analysis/","text":"使用 Java+Elasticsearch+Kibana 爬取了知乎 60 万用户数据，做了简单的可视化分析。 项目源码 GitHub - webporter 动机在知乎上看到有个叫 @路人甲 的大神每隔一段时间就爬爬豆瓣/B站等等网站，做了很多有意思的分析，加上之前因为实验室项目接触过 Nutch，浅尝辄止了，所以一直想好好玩玩爬虫。 网上 Python 的爬虫教程很多，而自己的主语言是 Java，本着宣传 Java，以练促学的目的，我使用 Java 爬取了知乎 60 万用户信息，主要想看看知乎上妹子多不多啊/是不是都是基佬啊，标配常青藤/年薪百万是不是真的啊，等等。 思路为了保证数据的质量，避免爬到一些僵尸号什么的，我选择爬取关注列表而非粉丝列表。我随机挑选了一位粉丝过千的优秀回答者作为起始，爬取他的关注列表，再对列表中的每个人爬取其关注列表，以此类推…… 下载了大概 7 个小时，爬了 40 多万用户的关注列表，拿到了 10G 的数据，如图所示： 爬取10G数据 理论上有 800 多万用户，可惜有很多重复的，去重后将数据导入 Elasticsearch，得到 60+ 万用户数据: ES索引 数据验证接下来简单看看下载下来的数据靠不靠谱，随手在知乎和我的 Kibana 分别搜了下轮子哥 @vczh 搜索轮子哥 搜索轮子哥 可以看到，连同名的都搜出来是一样的，数据没啥问题。 关心的数据然后使用 Elastichearch 的聚合查询配合 Kibana 对数据进行可视化展示，我主要分析了下面几个问题： 性别分布 粉丝最多的用户top10 员工最多的公司top10 校友最多的学校top10 人数最多的地方top10 top10行业分布 top10职业分布 图中涉及性别的， 1 表示男，0 表示女，-1 表示不男不女 性别分布 性别分布 可以看到知乎男性人数过半了，比女性和未知性别加起来都多。 粉丝最多的用户top10 粉丝最多的用户top10 粉丝数前 10 的依次是 @张佳玮，@李开复，@黄继新，@周源，@yolfilm，@张亮，@张小北，@李淼，@葛巾，@采铜。最多的 120 万粉丝，第十也过 60 万了。不过前十里好几个都是知乎员工，有黑幕的嫌疑吧？ 员工最多的公司top10 员工最多的公司top10 可以看到 BAT 全部上榜了（乱入了一个学生什么鬼？），仅接着是网易,华为,谷歌,微软,美团。都是牛逼哄哄的互联网相关企业，看来国企和实体企业比较低调，不在知乎填公司信息啊。 另外华为的男女比简直不能看啊，妹子那么少，想去华为的单身狗们需要好好考虑一下了。 校友最多的学校top10 校友最多的学校top10 差强人意，校友人数排名前十的全特么是 985 啊，清北复交浙全部上榜，俨然中国大学排行榜。看来知乎标配不是常青藤，而是 985 嘛。另外可以看到，我科(倒数第三个)的男女比在这几个里面确实感人，难怪我现在还单身… 人数最多的地方top10 人数最多的地方top10 北京独领风骚，上海紧随其后。另外知乎居然把深圳和广州根据有没有“市”标记为了两个城市，简直坑爹，我也懒得二次处理了。综合来看，北上广深杭，主要集中在这五个城市，基本也是我国互联网企业分布最多的几个城市。 top10行业分布 top10行业分布 可以看到，互联网和计算机软件两个加起来就占了半数以上，要是算上电子商务和电子游戏等基本是程序员的天下了，所以知乎上程序员偏多，IT 从业者占主流啊。 另外互联网的男女比大概 2:1 的样子吧，法律，信息传媒和创意艺术的男女比比较均衡，大概五五开。 top10职业分布 top10职业分布 将近四分之一是产品经理，创始人和 CEO 也不少，比工程师还多，学生也占一定比例。另外除了运营和编辑的男女比差不多，其它都是男多女少啊。 结语从这 60 万用户数据可以看出，知乎的主要群体是程序员和学生，平均学历 985 不是黑，是真的！虽然知乎用户远不止 60 万，这些数据分析出来的结果可能有些偏差，但应该也能说明一些问题吧。 最后按照国际惯例，附上源码链接[GitHub - webporter]: https://github.com/brianway/webporter","tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://brianway.github.io/tags/Elasticsearch/"},{"name":"Kibana","slug":"Kibana","permalink":"https://brianway.github.io/tags/Kibana/"},{"name":"webporter","slug":"webporter","permalink":"https://brianway.github.io/tags/webporter/"}]},{"title":"Elasticsearch 5.0-配置检查","date":"2016-12-13T05:48:07.000Z","path":"2016/12/13/2016-12-13-elasticsearch-bootstrap-checks/","text":"本文是 Elasticsearch 5.0 系列博文的配置检查篇,主要介绍 Elasticsearch 的 Bootstrap Checks 写在前面 本文以 Elasticsearch 5.0.1 版本为例进行讲解,不定期更新 该系列主要参考的 Elasticsearch Reference: 5.0，尽量避免照搬翻译，只摘录精要部分辅以简单说明 写这个系列博客的初衷是强迫自己梳理，同时方便一些较忙/没空耐心看英文文档的朋友快速上手，建议读者有空多读官方文档，毕竟别人写的都是二手资料 如需查看 ES 系列更多博文，请关注我的个人网站@brianway 或者 @CSDN 为什么有 Bootstrap ChecksBootstrap Checks 是 Elasticsearch 5.0 新加入的，在之前的 2.x 版本是没有的。之前的版本中，错误的配置会被当成 warning 记录到日志中，但这些信息往往被用户忽视。为了保证一些重要的配置得到应有的重视，Elasticsearch 会在启动时进行 Bootstrap Checks . Bootstrap Checks 会检查很多 Elasticsearch 和系统的配置。在开发模式下，所有没通过的检查都会报 warnings 并写进日志文件，即使检查没通过，依然可以启动节点运行 Elasticsearch；而在生产模式下，任何没通过的 Bootstrap Checks 都会报异常并阻止 Elasticsearch 启动。 开发模式 vs. 生产模式Elasticsearch 的 HTTP 默认绑定到localhost，并且 transport 使用内部通信，适用于日常开发；而组成集群时，由于每个 ES 实例要可达，故 transport 必须绑定到外部接口。 一般 Elasticsearch 默认你是在开发模式下工作；一旦配置了诸如network.host的网络配置项，Elasticsearch会认为你处于生产环境。这是避免服务器因不良配置造成数据丢失的重要安全措施。 另外，HTTP 和 transport 可以分别通过 http.host 和 transport.host进行配置，所以配置单点实例可达时，可以用 HTTP 进行测试而无需触发生产模式。 Bootstrap Checks有很多检查项，以 Heap size check为例子，由于 Elasticsearch 是使用 Java 写的，程序在 JVM 上运行，而 JVM 的堆大小是可以配置的。如果 JVM 的起始堆大小不等于最大堆大小，那么在堆 resize 的时候很容易造成系统停滞，为了避免这种resize pauses,一开始就应将两者设置成相等。 类似的检查还有很多，大部分是针对 JVM 配置项的检查，有些检查项只在 Linux 系统上会检查，有些在所有平台都会检查。这里只列举出检查项，不作进一步说明了，具体每一项说明可参考 Bootstrap Checks Heap size check File descriptor check Memory lock check Maximum number of threads check Maximum size virtual memory check Maximum map count check Client JVM check Use serial collector check OnError and OnOutOfMemoryError checks 重要的系统配置从上节可知，很多Bootstrap Checks涉及到系统配置，我们需要对系统进行一些配置来使 Elasticsearch 可以获取更多的资源。 一般必须配置以下几条设置： Set JVM heap size Disable swapping Increase file descriptors Ensure sufficient virtual memory Ensure sufficient threads 在哪里配置系统设置取决于你使用的安装包以及你使用的操作系统，具体的配置方法见 Configuring system settings JVM 参数建议通过 jvm.options 配置文件进行配置，当然，也可以通过 ES_JAVA_OPTS 环境变量来配置。","tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://brianway.github.io/tags/Elasticsearch/"}]},{"title":"Elasticsearch 5.0-简单查询","date":"2016-12-13T05:45:07.000Z","path":"2016/12/13/2016-12-13-elasticsearch-simple-query/","text":"本文是 Elasticsearch 5.0 系列博文的简单查询篇,主要介绍如何使用 Elasticsearch 进行简单查询 写在前面 本文以 Elasticsearch 5.0.1 版本为例进行讲解,不定期更新 该系列主要参考的 Elasticsearch Reference: 5.0，尽量避免照搬翻译，只摘录精要部分辅以简单说明 写这个系列博客的初衷是强迫自己梳理，同时方便一些较忙/没空耐心看英文文档的朋友快速上手，建议读者有空多读官方文档，毕竟别人写的都是二手资料 如需查看 ES 系列更多博文，请关注我的个人网站@brianway 或者 @CSDN 数据准备随机 json 数据生成网站 www.json-generator.com 可以从官网下载数据 accounts.json，然后使用 _bulk api 建立索引即可 123curl -O https://raw.githubusercontent.com/elastic/elasticsearch/master/docs/src/test/resources/accounts.jsoncurl -XPOST 'localhost:9200/bank/account/_bulk?pretty&amp;refresh' --data-binary \"@accounts.json\"curl 'localhost:9200/_cat/indices?v' 查询API两种执行 search 的方式： 通过 REST request URI 发送查询参数 通过 REST request body发送查询参数 1234567891011# returns all documents in the bank indexGET /bank/_search?q=*&amp;sort=account_number:asc# using the alternative request body methodGET /bank/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: [ &#123; &quot;account_number&quot;: &quot;asc&quot; &#125; ]&#125; 返回数据(部分省略) 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;took&quot;: 6, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 1000, &quot;max_score&quot;: null, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;bank&quot;, &quot;_type&quot;: &quot;account&quot;, &quot;_id&quot;: &quot;0&quot;, &quot;_score&quot;: null, &quot;_source&quot;: &#123; &quot;account_number&quot;: 0, &quot;balance&quot;: 16623, &quot;firstname&quot;: &quot;Bradshaw&quot;, &quot;lastname&quot;: &quot;Mckenzie&quot;, &quot;age&quot;: 29, &quot;gender&quot;: &quot;F&quot;, &quot;address&quot;: &quot;244 Columbus Place&quot;, &quot;employer&quot;: &quot;Euron&quot;, &quot;email&quot;: &quot;bradshawmckenzie@euron.com&quot;, &quot;city&quot;: &quot;Hobucken&quot;, &quot;state&quot;: &quot;CO&quot; &#125;, &quot;sort&quot;: [ 0 ] &#125;, ... ] &#125;&#125; 每个字段的含义根据字段名即可看出来，不赘述。其中： took的单位是毫秒 hits.hits默认返回结果中的前十条记录 需要注意的是,一旦获得返回结果，Elasticsearch 就彻底完成了请求，且不保存任何服务端资源或者状态信息，这和 SQL 里一些先得到结果子集再通过状态信息(如游标)得到剩下结果集的情况不同 Query DSL介绍几个简单的查询,size 未指定则默认是 10,from 参数默认从零开始 123456789101112131415161718192021222324252627# returns documents 11 through 20:GET /bank/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;from&quot;: 10, &quot;size&quot;: 10&#125;# sorts the results by account balance in descending order and returns the top 10 (default size) documentsGET /bank/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;sort&quot;: &#123; &quot;balance&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125;&#125;# return two fields, account_number and balanceGET /bank/_search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;_source&quot;: [&quot;account_number&quot;, &quot;balance&quot;]&#125;# returns the account numbered 20GET /bank/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;account_number&quot;: 20 &#125; &#125;&#125; 更多例子，如must,should,bool query 等等，请参考 Executing Searches 过滤器查询条件和文档的相关性用 _score 这个数值字段来表示，数值越高越相关。而有时我们不需要去计算相关性，只需要确定文档满不满足查询条件即可，这时可以用 filter(过滤器). 1234567891011121314151617# uses a bool query to return all accounts with balances between 20000 and 30000GET /bank/_search&#123; &quot;query&quot;: &#123; &quot;bool&quot;: &#123; &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;filter&quot;: &#123; &quot;range&quot;: &#123; &quot;balance&quot;: &#123; &quot;gte&quot;: 20000, &quot;lte&quot;: 30000 &#125; &#125; &#125; &#125; &#125;&#125; 在上面的例子中，返回所有 balance 在 20000～30000 的文档，所有满足条件的文档的匹配程度都是“等价”的，没有谁更相关，所以计算分数是无意义且没必要的。 聚合aggregation(聚合)能够对数据分组和提取统计信息，大致类似 SQL 中的 group by 和聚合函数。 Elasticsearch 能同时分别返回查询结果和聚合结果，从而避免多次查询。 12345678910111213# 类似SQL中的 SELECT state, COUNT(*) FROM bank GROUP BY state ORDER BY COUNT(*) DESCGET /bank/_search&#123; &quot;size&quot;: 0, &quot;aggs&quot;: &#123; &quot;group_by_state&quot;: &#123; &quot;terms&quot;: &#123; &quot;field&quot;: &quot;state.keyword&quot; &#125; &#125; &#125;&#125; 更多聚合例子参考 Executing Aggregations","tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://brianway.github.io/tags/Elasticsearch/"}]},{"title":"Elasticsearch 5.0-基本操作","date":"2016-12-13T05:42:07.000Z","path":"2016/12/13/2016-12-13-elasticsearch-basic-operations/","text":"本文是 Elasticsearch 5.0 系列博文的基本操作篇,主要介绍 Elasticsearch 的 CRUD 操作 写在前面 本文以 Elasticsearch 5.0.1 版本为例进行讲解,不定期更新 该系列主要参考的 Elasticsearch Reference: 5.0，尽量避免照搬翻译，只摘录精要部分辅以简单说明 写这个系列博客的初衷是强迫自己梳理，同时方便一些较忙/没空耐心看英文文档的朋友快速上手，建议读者有空多读官方文档，毕竟别人写的都是二手资料 如需查看 ES 系列更多博文，请关注我的个人网站@brianway 或者 @CSDN 基础指令下面是在 Console 中输入的一些命令，可以依次运行看看结果。 123456789101112131415161718192021# Cluster HealthGET _cat/health?v# list of nodesGET /_cat/nodes?v#List All IndicesGET /_cat/indices?v# Create an IndexPUT /customer?prettyGET /_cat/indices?v# Index and Query a DocumentPUT /customer/external/1?pretty&#123; &quot;name&quot;: &quot;John Doe&quot;&#125;GET /customer/external/1?prettyDELETE /customer/external/1# Delete an IndexDELETE /customer?pretty 可以看出Elasticsearch 的 REST API基本格式： &lt;REST Verb&gt; /&lt;Index&gt;/&lt;Type&gt;/&lt;ID&gt; 索引/替换文档1234567891011# Indexing/Replacing DocumentsPUT /customer/external/1?pretty&#123; &quot;name&quot;: &quot;John Doe&quot;&#125;# using the POST verb instead of PUT since we didn’t specify an IDPOST /customer/external?pretty&#123; &quot;name&quot;: &quot;Jane Doe&quot;&#125; 使用 PUT 方法需要明确指定 ID,两次 PUT 的 id 相同则是替换之前的文档，第二次 id 不同则是创建新的文档 没明确指定 ID 则使用 POST 方法 更新文档12345678910111213141516# Updating DocumentsPOST /customer/external/1/_update?pretty&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot; &#125;&#125;POST /customer/external/1/_update?pretty&#123; &quot;doc&quot;: &#123; &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 20 &#125;&#125;# uses a script to increment the age by 5POST /customer/external/1/_update?pretty&#123; &quot;script&quot; : &quot;ctx._source.age += 5&quot;&#125; 更新文档其实就是先删除再建一个新的文档 Whenever we do an update, Elasticsearch deletes the old document and then indexes a new document with the update applied to it in one shot 删除文档12# Deleting DocumentsDELETE /customer/external/2?pretty 直接删除整个 index 要比删除 index 里的所有文档要更有效率 It is worth noting that it is much more efficient to delete a whole index instead of deleting all documents with the Delete By Query API. 批处理123456789101112# Batch ProcessingPOST /customer/external/_bulk?pretty&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123;&quot;name&quot;: &quot;John Doe&quot; &#125;&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125;&#123;&quot;name&quot;: &quot;Jane Doe&quot; &#125;POST /customer/external/_bulk?pretty&#123;&quot;update&quot;:&#123;&quot;_id&quot;:&quot;1&quot;&#125;&#125;&#123;&quot;doc&quot;: &#123; &quot;name&quot;: &quot;John Doe becomes Jane Doe&quot; &#125; &#125;&#123;&quot;delete&quot;:&#123;&quot;_id&quot;:&quot;2&quot;&#125;&#125; 删除操作后面没有相应的文档数据，只提供要删除的 ID 即可 批处理对每个操作(action)按顺序依次执行(sequentially and in order)，如果单个操作出错，也会继续执行剩下的操作 批处理放回结果时，按照请求顺序为每个操作提供一个状态以便用户检查","tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://brianway.github.io/tags/Elasticsearch/"}]},{"title":"Elasticsearch 5.0-基础概念","date":"2016-12-13T05:40:07.000Z","path":"2016/12/13/2016-12-13-elasticsearch-basic-concepts/","text":"本文是 Elasticsearch 5.0 系列博文的基础概念篇，主要介绍集群，节点，索引，类型，文档，分片，副本等基础概念 写在前面 本文以 Elasticsearch 5.0.1 版本为例进行讲解,不定期更新 该系列主要参考的 Elasticsearch Reference: 5.0，尽量避免照搬翻译，只摘录精要部分辅以简单说明 写这个系列博客的初衷是强迫自己梳理，同时方便一些较忙/没空耐心看英文文档的朋友快速上手，建议读者有空多读官方文档，毕竟别人写的都是二手资料 如需查看 ES 系列更多博文，请关注我的个人网站@brianway 或者 @CSDN 基本概念有关概念在Basic Concepts中已经介绍的很详细了，这里简单说一下。 集群(cluster)：集群由一个或者多个节点组成，由名称唯一标识 节点(node)：一个单独的 Elasticsearch 实例 索引(index)：文档的集合 类型(type)：索引的逻辑分类/分区 文档(document)：能够被索引的信息基础单元 分片(shard)：索引的物理分区，是一个最小的 Lucene 索引单元。分为 primary shard(主分片) 和 replica shard(简称replicas)。 副本/备份(replicas)：主分片的备份 下面就这几个概念进一步说明 类比关系型数据库其中索引,类型,文档的概念可以类比关系型数据库 Elasticsearch 关系型数据库 索引(index) 数据库(database) 类型(type) 表(table) 文档(document) 行记录(row) 字段(field) 列(column) 为什么有shard和replica为什么有 shard? 可以水平切分和扩展内容容量 在shards 间分发和并行执行操作，从而提供性能和吞吐量 为什么有replica? 当 shard 失效时提供高可用性。因为这个原因，一个primary shard的replica不会分配到和该shard所处的同一节点 扩展查询的容量/吞吐量，因为查询操作是一个读操作，可以在所有replica上并行执行 其他补充Elasticsearch 默认为每个 index 创建 5 个主分片，且备份数为 1。也就是说，每个索引由 5 个主分片组成，并且每个分片拥有一个备份。需要注意的是，主分片的数量一旦确定，之后是不能更改的（除非重新建立索引），而 replicas 的数量可以在之后随时更改。 所以在上一篇文章中，我们启动 Kibana 后在 Consonle 查询索引状态GET /_cat/indices?v，会发现 health 是 yellow 而不是 green，就是因为我们只开启了一个节点，而且 Kibana 启动后在 Elasticsearch 中建立了一个默认索引 .kibana，该索引只有 1 个主分片和一个副本，故 shard 都在该节点上，而 shard 的副本不能和该 shard 分配在同一节点，故未生效，从而导致状态是黄色。 另外，每个索引被分配到多个分片，但 number_of_shards 的值只适用于索引，而不是整个集群。这个值指定了每个索引的分片数，而非整个集群中的全部主分片数。（摘自Optimizing Elasticsearch: How Many Shards per Index?）","tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://brianway.github.io/tags/Elasticsearch/"}]},{"title":"Elasticsearch 5.0-安装使用","date":"2016-12-13T05:35:07.000Z","path":"2016/12/13/2016-12-13-elasticsearch-installation/","text":"本文是 Elasticsearch 5.0 系列博文的安装使用篇,主要介绍如何安装并运行 Elasticsearch，顺带介绍 Kibana 的安装 写在前面 本文以 Elasticsearch 5.0.1 版本为例进行讲解,不定期更新 该系列主要参考的 Elasticsearch Reference: 5.0，尽量避免照搬翻译，只摘录精要部分辅以简单说明 写这个系列博客的初衷是强迫自己梳理，同时方便一些较忙/没空耐心看英文文档的朋友快速上手，建议读者有空多读官方文档，毕竟别人写的都是二手资料 如需查看 ES 系列更多博文，请关注我的个人网站@brianway 或者 @CSDN 下载安装参考install Elasticsearch即可，这里简单展示一下 前台运行 ES 默认运行在前台，日志打印到标准输出 12345wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.0.1.tar.gzsha1sum elasticsearch-5.0.1.tar.gztar -xzf elasticsearch-5.0.1.tar.gzcd elasticsearch-5.0.1/./bin/elasticsearch 在终端输入curl -XGET &#39;localhost:9200/?pretty&#39; 得到响应： 12345678910111213&#123; \"name\": \"Dp0oq_v\", \"cluster_name\": \"elasticsearch\", \"cluster_uuid\": \"6rLSu0JMTlq_YJqyhWS_xQ\", \"version\": &#123; \"number\": \"5.0.1\", \"build_hash\": \"080bb47\", \"build_date\": \"2016-11-11T22:08:49.812Z\", \"build_snapshot\": false, \"lucene_version\": \"6.2.1\" &#125;, \"tagline\": \"You Know, for Search\"&#125; 后台运行 参考 Running as a daemon 日志信息在$ES_HOME/logs/文件夹 文件夹结构这里我使用的是.zip和.tar.gz的包直接解压得到的，文件夹的目录结构：Directory layout of .zip and .tar.gz archives 重要配置 path.data和path.logs:使用.zip和.tar.gz的 Elasticsearch 的话，这两个路径是$ES_HOME的子文件夹，升级 Elasticsearch 时有被删除的风险，所以需要另外指定路径，path.data可指定多路径 cluster.name:节点只能加进cluster.name相同的集群中，默认名是elasticsearch node.name:Elasticsearch 默认采用随机 UUID 的前 7 位字符作为节点id，且节点id一直保存，节点重启并不会改变节点名。 bootstrap.memory_lock:JVM 不被交换到硬盘对于节点健康很重要，一种实现方式是将bootstrap.memory_lock设置成true network.host:Elasticsearch 默认只绑定 loopback 地址(127.0.0.1和[::1]),多节点在一个 server 上启动也是可行的，生产环境下不建议罢了。 discovery.zen.ping.unicast.hosts:同一个 server 上的节点将扫描端口号 9300 到 9305 来尝试连接其他该 server 上的节点。和其他 server 节点组成集群时，需要配置该项。端口默认 9300,域名对应多IP的话会尝试所有解析出来的 IP discovery.zen.minimum_master_nodes:不设置的话可能出现split brain问题，造成数据丢失。为了避免这样，该项设置为(master_eligible_nodes / 2) + 1 Kibana 安装由于老在终端里使用 curl 命令很不方便，所以顺带安装了一下 Kibana。简单介绍下 Kinaba，它是一个配合 Elasticsearch 工作的分析和可视化平台，一些和 Elasticsearch 通过 REST API 交互的请求可以在这里面比较方便的输入和回显。 我是在 Mac 下安装的，下载好安装好解压就行了。其他系统参考 Installing Kibana 12curl -O https://artifacts.elastic.co/downloads/kibana/kibana-5.0.1-darwin-x86_64.tar.gztar -xzf kibana-5.0.1-darwin-x86_64.tar.gz 先启动 Elasticsearch，再启动 Kibana 12cd kibana-5.0.1-darwin-x86_64.tar.gzbin/kibana 默认的访问网址是localhost:5601，在浏览器访问即可。然后点击侧栏的 Dev Tools就行了。顺带提一句，在之前的版本中，这个窗口是一个叫做 Sense 的插件的功能，在 5.0 版本中默认和 Kibana 集成了，并改名为 Console。 在左边输入 GET /，点绿色的播放按钮发送请求，就可以看到和刚才在终端里输入curl -XGET &#39;localhost:9200/?pretty&#39;同样的的响应了。如图所示： Kibana - Console界面 后面的Elasticsearch的文章演示部分都会基于 Console - Kibana ，请安装好。","tags":[{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://brianway.github.io/tags/Elasticsearch/"}]},{"title":"常见数据结构(二)-树(二叉树，红黑树，B树)","date":"2016-10-14T07:05:07.000Z","path":"2016/10/14/2016-10-14-algorithms-data-structures-2/","text":"本文介绍数据结构中几种常见的树:二分查找树，2-3树，红黑树，B树 写在前面 本文所有图片均截图自coursera上普林斯顿的课程《Algorithms, Part I》中的Slides 相关命题的证明可参考《算法（第4版）》 源码可在官网下载,也可以在我的github仓库 algorithms-learning下载，已经使用maven构建 仓库下载：git clone git@github.com:brianway/algorithms-learning.git Binary Search Tree(二分查找树)定义：A BST is a binary tree in symmetric order. A binary tree is either: Empty. Two disjoint binary trees (left and right). Symmetric order.Each node has a key, and every node’s key is: Larger than all keys in its left subtree. Smaller than all keys in its right subtree. 在java的实现中，每个节点(Node)由四个域组成：key,value,left,right。即：键，值，左子树，右子树。 12345678910private class Node &#123; private Key key; private Value val; private Node left, right; public Node(Key key, Value val) &#123; this.key = key; this.val = val; &#125;&#125; Binary Search Tree 查找：得到相应键的值，若无此键则返回null. 123456789101112131415/* 查找 */public Value get(Key key) &#123; Node x = root; while (x != null) &#123; int cmp = key.compareTo(x.key); if (cmp &lt; 0) &#123; x = x.left; &#125; else if (cmp &gt; 0) &#123; x = x.right; &#125; else &#123; // if (cmp == 0) return x.val; &#125; &#125; return null;&#125; 插入：如果小，往左；如果大，往右；如果null，插入；如果存在，覆盖。 123456789101112131415161718/* 插入 */public void put(Key key, Value val) &#123; root = put(root, key, val);&#125;/* 辅助函数，递归调用 */private Node put(Node x, Key key, Value val) &#123; if (x == null) return new Node(key, val); int cmp = key.compareTo(x.key); if (cmp &lt; 0) &#123; x.left = put(x.left, key, val); &#125; else if (cmp &gt; 0) &#123; x.right = put(x.right, key, val); &#125; else &#123; // if (cmp == 0) x.val = val; &#125; return x;&#125; 比较的次数为节点的深度+1,由于插入节点的顺序会有差异，所以树的高度不确定，最坏的情况是N个节点的树高度为N。 删除：列出下面几种处理方法 将值置为null，在树中保留键 删除最小值：一直向左找到左子树为null的节点，用它的右子节点代替它。 Hibbard deletion 下面重点讲一下Hibbard deletion,分为三种情况： 没有子节点的节点，将其parent link置为null即可。 有一个子节点的节点，删除该节点并以子节点代替即可。 有两个子节点的节点，找到该节点t的下一个节点x（即右子树的最小节点），在右子树删除这个节点，并将该节点x放到t的位置。 12345678910111213141516171819/* 删除 */private Node delete(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) &#123; x.left = delete(x.left, key); &#125; else if (cmp &gt; 0) &#123; x.right = delete(x.right, key); &#125; else &#123; if (x.right == null) return x.left; // no right child if (x.left == null) return x.right; // no left child Node t = x; x = min(t.right); // replace with successor x.right = deleteMin(t.right); x.left = t.left; &#125; x.count = size(x.left) + size(x.right) + 1; return x;&#125; 2-3 Search Trees(2-3树)在介绍红黑树前，先介绍一下2-3树，便于后面理解红黑树。 2-3树是二分查找树的变形，每个节点是下面两种情况之一： 2-node:一个键，两个分叉（smaller,larger） 3-node:两个键，三个分叉（smaller,between,larger） 2-3 trees 在底部向一个3-node插入。 向3-node插入一个键，临时成为一个4-node 将4-node中间的key移动到父节点 向上重复 如果到了顶端的根节点，且根节点是4-node,将其分成3个2-nodes. 总结起来就是：当插入的值导致节点变四叉时进行分裂，将中间的值传给上一个节点，并将另外两个值作为两个子节点分开，若上一节点也因此变成四叉，依次类推。分裂4-node是一个local transformation，只会进行常数次数的操作。高度加一由且仅由顶节点分裂造成 2-3 trees proof 树的高度，在查找和插入时，保证了logarithmic的性能。 Worst case: lg N. [all 2-nodes] Best case: log3 N ≈ 0.631 lg N. [all 3-nodes] Red-Black BSTs(红黑树)这里的红黑树均指Left-leaning red-black BSTs。主要是用二叉树的形式来表示2-3树，用一个“内部”的left-leaning连接来表示3-node。red link是2-3tree的三叉节点的连接两个key的内部link，大值作为根节点，小值作为左子节点，故名left leaning 红黑树。 红黑树定义 一个等价的定义,A BST such that: No node has two red links connected to it. Every path from root to null link has the same number of black links. Red links lean left. 红黑树对应2-3树 红黑树的java表示 1234567891011121314private static final boolean RED = true;private static final boolean BLACK = false;private class Node &#123; Key key; Value val; Node left, right; boolean color;// color of parent link&#125;private boolean isRed(Node x) &#123; if (x == null) return false; return x.color == RED;&#125; 左转-右转-变色红黑树插入过程中可能用到的三个基本操作（左转，右转，变色）： left rotate right rotate flip colors 下面依次介绍 左转 红黑树左转 12345678910/* left rotate */private Node rotateLeft(Node h) &#123; assert isRed(h.right); Node x = h.right; h.right = x.left; x.left = h; x.color = h.color; h.color = RED; return x;&#125; 右转 红黑树右转 12345678910/* right rotate */private Node rotateRight(Node h) &#123; assert isRed(h.left); Node x = h.left; h.left = x.right; x.right = h; x.color = h.color; h.color = RED; return x;&#125; 变色 红黑树变色 123456789/* flip colors */private void flipColors(Node h) &#123; assert !isRed(h); assert isRed(h.left); assert isRed(h.right); h.color = RED; h.left.color = BLACK; h.right.color = BLACK;&#125; 插入操作 红黑树插入两个节点 从图中可以看出，插入的次序不同，需要转换的操作也不同，分三种情况（图中每一列是一种情况）： 已有a和b时，c插入在b的右子节点，直接变色即可 已有b和c时，a插入在b的左子节点，先右转把b滑上去，成1中的状态，再变色即可 已有a和c时，b插入在a的右子节点，先左转把a滑下去，成2中的状态，再右转＋变色即可 从上面的分析可以看出，三种情况之间有转换关系，且逐步趋向简单，如下图所示： 红黑树状态转换 根本原因在于，2-3树中，是把3-node中处于中间的那个键传递给父节点，所以在红黑树中，当有一个节点连了两个 red link时，说明这三个点是一个3-node，但次序还需要调整，从而达到中间键在最上的状态，进而变色。而这个这个调整的趋势则是先让b处于a,c中间(即a的父，c的左子，成一条线)，再让b成为a,c的父节点，最后变色。记住这个顺序和原因，写代码就简单了，状态3-&gt;状态2-&gt;状态1 123456789101112131415161718private Node put(Node h, Key key, Value val) &#123; //insert at bottom (and color it red) if (h == null) return new Node(key, val, RED); int cmp = key.compareTo(h.key); if (cmp &lt; 0) &#123; h.left = put(h.left, key, val); &#125; else if (cmp &gt; 0) &#123; h.right = put(h.right, key, val); &#125; else &#123; h.val = val; &#125; if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h);// lean left if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h);//balance 4-node if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h);//split 4-node return h;&#125; 红黑树的高度 h &lt;= 2 lg N，证明： Every path from root to null link has same number of black links. Never two red links in-a-row. B-Trees(B树)最后简单提一下B树，就是将2-3树一般化，将每个节点的key-link pairs增加到 M - 1 At least 2 key-link pairs at root. At least M / 2 key-link pairs in other nodes. External nodes contain client keys. Internal nodes contain copies of keys to guide search. B-Trees 在B树中查找 Start at root. Find interval for search key and take corresponding link. Search terminates in external node. 在B树中插入 Search for new key. Insert at bottom. Split nodes with M key-link pairs on the way up the tree. 命题：A search or an insertion in a B-tree of order M with N keys requires between log M-1 N and log M/2 N probes","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brianway.github.io/tags/数据结构/"}]},{"title":"常见数据结构(一)-栈,队列,堆,哈希表","date":"2016-10-13T08:45:07.000Z","path":"2016/10/13/2016-10-14-algorithms-data-structures-1/","text":"本文介绍几种常见的数据结构:栈、队列、堆、哈希表，等等。 写在前面 本文所有图片均截图自coursera上普林斯顿的课程《Algorithms, Part I》中的Slides 相关命题的证明可参考《算法（第4版）》 源码可在官网下载,也可以在我的github仓库 algorithms-learning下载，已经使用maven构建 仓库下载：git clone git@github.com:brianway/algorithms-learning.git Stacks(栈)LIFO(后进先出):last in first out. 使用linked-list实现 保存指向第一个节点的指针，每次从前面插入／删除节点。 以字符串栈为例，示例代码： 12345678910111213141516171819202122232425public class LinkedStackOfStrings &#123; private Node first = null; private class Node &#123; String item; Node next; &#125; public boolean isEmpty() &#123; return first == null; &#125; public void push(String item) &#123; Node oldfirst = first; first = new Node(); first.item = item; first.next = oldfirst; &#125; public String pop() &#123; String item = first.item; first = first.next; return item; &#125;&#125; 使用数组实现 使用数组来存储栈中的项 12345678910111213141516171819202122public class FixedCapacityStackOfStrings &#123; private String[] s; private int N = 0; public FixedCapacityStackOfStrings(int capacity) &#123; s = new String[capacity]; &#125; public boolean isEmpty() &#123; return N == 0; &#125; public void push(String item) &#123; s[N++] = item; &#125; public String pop() &#123; String item = s[--N]; s[N] = null; return item; &#125;&#125; 上面的实现会有几个问题： 从空栈pop会抛出异常 插入元素过多会超出数组上界 这里重点解决第二个问题，resizing arrays.一个可行的方案是: 当数组满的时候，数组大小加倍；当数组是1/4满的时候，数组大小减半。 这里不是在数组半满时削减size,这样可以避免数组在将满未满的临界点多次push-pop-push-pop操作造成大量的数组拷贝操作。 插入N个元素，N + (2 + 4 + 8 + ... + N) ~ 3N。 N:1 array access per push (2 + 4 + 8 + … + N):k array accesses to double to size k (ignoring cost to create new array) 由于resize操作不是经常发生，所以均摊下来，平均每次push/pop操作的还是常量时间(constant amortized time). Queues(队列)FIFO(先进先出):first in first out. 使用linked-list实现 保存指向首尾节点的指针，每次从链表尾插入，从链表头删除。 123456789101112131415161718192021222324252627282930public class LinkedQueueOfStrings &#123; private Node first, last; private class Node &#123; /* same as in StackOfStrings */ &#125; public boolean isEmpty() &#123; return first == null; &#125; public void enqueue(String item) &#123; Node oldlast = last; last = new Node(); last.item = item; last.next = null; if (isEmpty()) &#123; first = last; &#125; else &#123; oldlast.next = last; &#125; &#125; public String dequeue() &#123; String item = first.item; first = first.next; if (isEmpty()) last = null; return item; &#125;&#125; 使用数组实现 12345・Use array q[] to store items in queue.・enqueue(): add new item at q[tail].・dequeue(): remove item from q[head].・Update head and tail modulo the capacity.・Add resizing array. Priority QueuesCollections. Insert and delete items. Stack. Remove the item most recently added. Queue. Remove the item least recently added. Randomized queue. Remove a random item. Priority queue. Remove the largest (or smallest) item. unordered array 实现 12345678910111213141516171819202122232425public class UnorderedMaxPQ&lt;Key extends Comparable&lt;Key&gt;&gt; &#123; private Key[] pq; // pq[i] = ith element on pq private int N; // number of elements on pq public UnorderedMaxPQ(int capacity) &#123; pq = (Key[]) new Comparable[capacity]; &#125; public boolean isEmpty() &#123; return N == 0; &#125; public void insert(Key x) &#123; pq[N++] = x; &#125; public Key delMax() &#123; int max = 0; for (int i = 1; i &lt; N; i++) if (less(max, i)) max = i; exch(max, N - 1); return pq[--N]; &#125;&#125; Binary Heaps(二叉堆)使用数组来表示一个二叉堆。根节点索引从1开始。索引对应在树中的位置，最大的键值是a[1],同时也是二叉树的根节点。 Parent’s key no smaller than children’s keys Indices start at 1. Parent of node at k is at k/2. Children of node at k are at 2k and 2k+1. 数组表示二叉堆 上浮和下沉有两种情况会触发节点移动： 子节点的键值变为比父节点大 父节点的键值变为比子节点（一个或两个）小 而 要消除这种违反最大堆定义的结构，就需要进行节点移动和交换， 使之满足父节点键值不小于两个子节点 。对应的操作分别是 上浮 和 下沉 上浮：子节点key比父节点大 Exchange key in child with key in parent. Repeat until heap order restored. 下沉：父节点key比子节点（one or both）小 Exchange key in parent with key in larger child. Repeat until heap order restored 12345678910111213141516171819/* 上浮 */private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; less(k / 2, k)) &#123; exch(k, k / 2); k = k / 2; &#125;&#125;/* 下沉 */private void sink(int k) &#123; while (2 * k &lt;= N) &#123; int j = 2 * k; if (j &lt; N &amp;&amp; less(j, j + 1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125;&#125; 插入和删除所有操作（插入和删除）都保证在log N 时间内。 插入：二叉堆的插入操作比较简单，把节点加在数组尾部，然后上浮即可。 删除最大：二叉堆的删除则是把根节点和末尾的节点交换，然后下沉该节点即可。 1234567891011121314/* 插入 */public void insert(Key x)&#123; pq[++N] = x; swim(N);&#125;/* 删除 */public Key delMax()&#123; Key max = pq[1]; exch(1, N--); sink(1); pq[N+1]=null; return max;&#125; 最后，堆中的键值是不能变的，即Immutable.不然就不能保证父节点不小于子节点。 Symbol Tables键值对的抽象.其中键一般使用immutable的类型，值是任何普通类型。 关于比较，所有的java类都继承了equals()方法，要求对于引用x,y,z Reflexive: x.equals(x) is true. Symmetric: x.equals(y) iff y.equals(x). Transitive: if x.equals(y) and y.equals(z), then x.equals(z). Non-null: x.equals(null) is false. 对于用户自定义的类型，一般按如下流程实现equals()方法: Optimization for reference equality. Check against null. Check that two objects are of the same type and cast. Compare each significant field: if field is a primitive type, use == if field is an object, use equals().[apply rule recursively] if field is an array, apply to each entry.[alternatively, use Arrays.equals(a, b) or Arrays.deepEquals(a, b),but not a.equals(b)] 两种实现的数据结构： 无序链表：Maintain an (unordered) linked list of key-value pairs. 有序数组：Maintain an ordered array of key-value pairs. 在有序数组进行查找时使用二分查找。两种方式的对比如下图： elementary ST implementations summary Hash Tables(哈希表)上面几种数据结构都是通过遍历或者二分查找去搜寻某个元素，而哈希表则是通过一个key-indexed table来存储其中的项，即“索引”是“键”的一个函数。换句话说，哈希是通过定义一种函数/计算方法，把键直接映射成一个哈希值（再通过取余操作换算成数组的下标索引），从而定位元素，而避免耗时的逐个比较和遍历的操作。 Hash code:An int between -2^31 and 2^31 - 1. Hash function. An int between 0 and M - 1 (for use as array index). 1234//这里hashCode可能为负，且-2^31取绝对值会溢出，所以要“位与”private int hash(Key key)&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125; 所有的java类均继承了hashCode()方法来计算哈希值, 返回一个32-bit的int.默认实现是返回该对象的内存地址。对常用的类型有自己的实现，以java的String类为例子： 123456789101112 public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; hash code design.”Standard” recipe for user-defined types： Combine each significant field using the 31x + y rule. If field is a primitive type, use wrapper type hashCode(). If field is null, return 0. If field is a reference type, use hashCode().[applies rule recursively] If field is an array, apply to each entry.[or use Arrays.deepHashCode()] 当然，这种映射并不能保证是一对一的，所以一定会出现多个键映射到同一个哈希值的尴尬情况（尤其是对数组的size取余操作后,映射到同一数组下标），即哈希冲突，这是就需要一些方法来解决。这里介绍两种常用的方法： separate chaining linear probing separate chainingUse an array of M &lt; N linked lists. 哈希：将key映射到0 ~ M-1 之间的一个整数i 插入：将值插在第i个链的前端 查找：只需遍历第i个链 separate chaining linear probing开放地址：如果发生冲突，将值放入下一个空的位置.(数组尺寸 M 必须比键值对的数目 N 要多.) 哈希：将key映射到 0 ~ M-1 之间的一个整数i 插入：如果数组索引为 i 的位置为空，则把值放入，否则依次尝试 i+1,i+2等索引，直到有空的 查找：先找索引 i，如果被占用且没匹配，则依次尝试i+1, i+2,等等","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://brianway.github.io/tags/数据结构/"}]},{"title":"git常用指令整理及说明(详细)","date":"2016-08-07T04:16:07.000Z","path":"2016/08/07/2016-08-07-git-basic-git-commands/","text":"本文是git系列博客的第二篇。本文对指令按照使用场景(建库，查看，修改，分支)进行分类归纳，介绍指令基本含义和用法，方便查阅。 安装和配置参考我前面的博客:git在各操作系统平台下的安装和配置 工作区、版本库和暂存区 工作区：就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 暂存区：Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以,现在git commit就是往master分支上提交更改。 简单理解:需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 详细知识见工作区和暂存区和Git 基础 - 记录每次更新到仓库 本地库和远程库新建仓库 建立远程库(为空，不要加README.md，不然后面会push不上去) 本地新建文件夹 git init初始化仓库，可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的。勿人为瞎改 远程库的名字就是origin，这是Git默认的叫法 git remote add origin git@github.com:michaelliao/learngit.git 这个命令是在本地的learngit仓库下执行的。这两个地方的仓库名不需要相同，因为会通过在本地的仓库目录下执行这条命令（命令中包含远程库的名字）已经将两者建立了联系 git push -u origin master 把本地库的所有内容推送到远程库上。把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数(推送和关联)，Git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 git push origin master每次本地提交后,推送最新修改到远程库 从远程库克隆假设github上面已经有一个远程库，但是本地没有，需要克隆到本地，远程库的名字叫gitskills git clone git@github.com:michaelliao/gitskills.git 克隆一个本地库,则在当前文件夹下会多一个gitskills的文件夹。 cd gitskills进入克隆下来的本地库，默认的名字是和github上的一样的 git push origin master 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 常用查看指令 git status 查看仓库当前的状态 git diff 文件名查看对文件做什么修改 git diff 版本号1 版本号2 --stat查看两个版本的差异的文件列表，包括被修改行数和增删图。参数改为--name-status前面显示修改说明字母(A,M等)，无行数 git log显示从最近到最远的提交日志 git log --pretty=oneline 简化日志输出的显示信息，commit id很长,详细显示见这里 git reflog 记录你的每一次命令，最先显示的是这个命令执行之后的版本的版本号的前七位，这样就算你清屏了或者重启了，也能找到某个版本的版本号，就可以轻松回退到那个版本 git branch 查看当前所在的分支。git branch命令会列出所有分支，当前分支前面会标一个*号 git log --graph --pretty=oneline --abbrev-commit用带参数的git log可以看到分支的合并情况。用git log --graph命令可以看到分支合并图 git remote 查看远程库的信息 git remote -v 显示更为详细的信息 常用修改指令 git add readme.txt添加，但是不提交 git commit -m &quot;提交描述&quot;提交，只有add后提交才有效。“改文件-&gt;add文件-&gt;再改-&gt;提交”，则第二次修改无效,不会被提交，只会成功提交第一次的修改。 撤销修改和版本回退 git checkout -- 文件名把没暂存(即没add)的干掉，或者说，丢弃工作区，回到到暂存状态 git reset HEAD 文件名把暂存的状态取消，工作区内容不变，但状态变为“未暂存”。 简单来说，没有add过的修改，只需要git checkout -- 文件名即可撤销；add 过的修改，先git reset HEAD 文件名变成没add 过的修改，再git checkout -- 文件名撤销。操作示例可以看这张图 git reset --hard HEAD^ 会回退到上一个版本 git reset --hard 某版本号前几位通过命令行上的历史信息（假如你没清屏的话），找到某版本 的版本号回到指定版本。不一定要全部的版本号，就像这个命令的例子，只要前面的约7、8位这样就可以。 分支管理创建和合并分支 git checkout -b dev创建一个新的分支：dev，并且会切换到dev分支。所以这条命令有两个作用。git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：git branch dev和git checkout dev git branch dev，新建分支是新建指针,指向当前commit git checkout dev切换到dev分支 git checkout masterdev分支的工作完成，我们就可以切换回master分支(此时在dev分支的修改在master上是看不到的) git merge dev 这是在master分支上执行的命令，作用是：把dev分支上的工作成果合并到master分支上 git branch -d dev 删除已合并的分支。删除分支就是删除指针 git branch -D devGit友情提醒，dev分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用git branch -D dev命令 git rebase master变基。在当前分支(非master)下执行该命令，则相当于把当前分支和mater分支合并，和merge操作类似，但提交历史不同，rebase操作的log更干净。具体可参考Git 分支 - 变基 解决冲突假设在master分支和feature1分支对同一文件做了修改 git merge feature1 在master分支上执行该命令，与feature1分支合并。这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件 合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息 git merge --no-ff -m &quot;merge with with no-ff&quot; dev准备合并dev分支，注意--no-ff参数表示禁用Fast forward，因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去 bug分支Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作 git stash保存工作现场 git stash list 查看工作现场 git stash apply恢复工作现场，但是恢复后，stash内容并不删除，有多个工作现场时可以git stash apply stash@{0}恢复特定的现场 git stash drop删除stash的内容 git stash pop恢复的同时也把stas内容删除了 远程分支这部分只介绍常用的几个操作 git fetch origin 这个命令查找 “origin” 是哪一个服务器，从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master指针指向新的、更新后的位置 git push (remote) (branch)推送本地的分支来更新远程仓库上的 同名分支。如前文提到的git push origin master就是将本地master分支推送到远程master分支；复杂一点的，git push origin serverfix:awesomebranch将本地的 serverfix分支推送到远程仓库上的awesomebranch分支 git push origin --delete serverfix或者git push origin :remotebranch,删除远程的serverfix分支 git pull在大多数情况下它的含义是一个git fetch紧接着一个git merge命令。具体可参考Git远程操作详解和Documentation git-pull 优秀教程&amp;笔记 廖雪峰的git教程(强烈推荐) Pro Git 使用git和github管理自己的项目—基础操作学习 使用git和github管理自己的项目—真实开发环境的策略","tags":[{"name":"git","slug":"git","permalink":"https://brianway.github.io/tags/git/"}]},{"title":"git在各操作系统平台下的安装和配置","date":"2016-08-07T03:40:07.000Z","path":"2016/08/07/2016-08-07-git-install-and-config/","text":"本文是git系列博客的第一篇，主要介绍git在windows,linux,Mac OX等不同操作系统下的安装和配置，主要以后两者为主。 工具下载 ubuntu:sudo apt-get intall git 安装 windows:下载git for windows安装即可 mac:个人对homebrew不是很安心,建议安装macports,再用macports安装git(sudo port install git +bash_completion) 环境相关配置 git config --global user.email &quot;you@example.com&quot; 配置邮件 git config --global user.name &quot;Your Name&quot; 配置用户名 git config --global color.ui true 开启颜色显示 创建SSH Key。在用户主目录下(~)，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴.ssh目录下id_rsa.pub文件的内容，点“Add Key” 命令行显示配置 提示语换英语,mac下在.bash_profile里添加下面内容,ubuntu在~/.profile下添加 12# git languageexport LANGUAGE=&apos;en_US.UTF-8 git&apos; 终端显示分支,mac下在.bash_profile里添加下面内容 123456# Git branch in prompt.parse_git_branch() &#123; git branch 2&gt; /dev/null | sed -e &apos;/^[^*]/d&apos; -e &apos;s/* \\(.*\\)/ (\\1)/&apos;&#125;export PS1=&quot;\\u@\\h:\\w\\[\\033[32m\\]\\$(parse_git_branch)\\[\\033[00m\\]$ &quot; 参考Add Git Branch Name to Terminal Prompt (Mac) git补全如果是linux或者windows用户，一般不会出现这个问题，mac下我当时是bash环境没设置好，按照这篇文章安的，使用的是Command Line Tools安装的git,不能识别macports里的git的补全。有几种办法可以完全补全 方法一：直接下载补全文件并使其生效 参考git auto-complete for branches at the command line? 1.通过curl下载：curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash 2.在~/.bash_profile里添加 123if [ -f ~/.git-completion.bash ]; then . ~/.git-completion.bashfi 方法二：使用macports的bash环境 参考：How to use bash-completion 检查的下自己的bash:which bash,which -a bash 方法三：使用oh-my-zsh并启用git plugins 检查下支持的shell:cat /etc/shells 查看当前shell:echo $SHELL 参考资料 Creating a Happy Git Environment on OS X 提示语中文改英文 Add Git Branch Name to Terminal Prompt (Mac) git auto-complete for branches at the command line? How to configure git bash command line completion? Install Bash git completion How to use bash-completion","tags":[{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"},{"name":"git","slug":"git","permalink":"https://brianway.github.io/tags/git/"}]},{"title":"Docker commands和Dockerfile","date":"2016-07-31T18:08:07.000Z","path":"2016/08/01/2016-08-01-docker-docker-command-and-Dockerfile/","text":"本文主要对Docker commands和Dockerfile的相关知识进行整理 Docker commands官网传送门： Docker run reference Docker commands 首先，当然是配置命令自动补全，只需要把一个文件用curl下载copy到特定路径即可，具体操作参考Command-line Completion 其实docker有很完备的命令帮助提示，对哪个指令不清楚，只需要在后面加--help就能看到帮助说明。例如： 输入docker --help可以看到所有可执行的命令。 随便挑一个，比如run命令，则输入docker run --help又能看到run的相关帮助了。 常用命令： 查看本地images: 1docker images 运行image 1234docker run [OPTIONS] IMAGE [COMMAND] [ARG...]//i.e.docker run imagedocker run -it image /bin/bash 常用的一些参数： --rm:container退出后自动删除 -i和-t常常一起用，-it:以超级管理员权限打开一个命令行窗口 -d: 后台运行container --name:给container命名 查看当前container 1docker ps -a 删除所有状态的container 1docker rm $(docker ps -a -q) 通过另外的tty查看已经运行的容器 1docker exec -it $&#123;container_id&#125; /bin/bash 查看容器的信息 1docker inspect $&#123;container_id&#125; 另外， 在以上指令中，容器名和容器的container_id都是可以使用的，如果用户没有指定容器名，docker会默认给每个容器分配一个比较友好的随机名称，像fervent_perlman,high_galileo等等 Dockerfile官网传送门： Dockerfile reference Best practices for writing Dockerfiles 感觉文档里说了很全了，这里稍微提几个容易困惑的点 1.exec form vs shell form 在CMD和ENTRYPOINT都涉及到着两种形式(CMD多一种完全作为参数的形式)，例如: CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;](exec形式,推荐) CMD command param1 param2 (shell形式) 至于两种形式的区别，官方的几点说明挺详细的，主要就是变量替换，脚本环境等方面有差别： Note: If CMD is used to provide default arguments for the ENTRYPOINT instruction, both the CMD and ENTRYPOINT instructions should be specified with the JSON array format. Note: The exec form is parsed as a JSON array, which means that you must use double-quotes (“) around words not single-quotes (‘). Note: Unlike the shell form, the exec form does not invoke a command shell. This means that normal shell processing does not happen. For example, CMD [ “echo”, “$HOME” ] will not do variable substitution on $HOME. If you want shell processing then either use the shell form or execute a shell directly, for example: CMD [ “sh”, “-c”, “echo $HOME” ]. 2.ENTRYPOINT vs CMD 读完官方的Understand how CMD and ENTRYPOINT interact ，觉得这两者特别相似，对这两者有什么区别和联系还是有些困惑，阅读下面这篇文章： Dockerfile: ENTRYPOINT vs CMD 简而言之，ENTRYPOINT更像一个写死的可执行指令，CMD更像默认的一个可选项。 一个image只做一个单一的用途，就像一个可执行的命令时，建议使用ENTRYPOINT，把CMD作为默认参数(第三种形式CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT))。因为一般而言，ENTRYPOINT是不被覆盖的(除非在run时显式使用–entrypoit),而CMD是defaults的选项，从前文的run命令格式docker run [OPTIONS] IMAGE [COMMAND] [ARG...]可知，用户可以在运行images时输入自己的COMMAND来覆盖默认的CMD。 3.ADD vs COPY 这两个好像都是把东西从host拷贝到docker的container里,官方比较如下： Although ADD and COPY are functionally similar, generally speaking, COPY is preferred. That’s because it’s more transparent than ADD. COPY only supports the basic copying of local files into the container, while ADD has some features (like local-only tar extraction and remote URL support) that are not immediately obvious. Consequently, the best use for ADD is local tar file auto-extraction into the image, as in ADD rootfs.tar.xz /. 简单来说，主要就两点区别： COPY只能把本地文件拷贝到container里；ADD还支持从远程拷贝(remote URL support) ADD可以自动解压本地压缩文件 官方建议用COPY(preferred) 参考链接 Reference - ADD or COPY Stackoverflow - Docker COPY vs ADD","tags":[{"name":"Docker","slug":"Docker","permalink":"https://brianway.github.io/tags/Docker/"}]},{"title":"docker入门概览","date":"2016-07-29T05:55:11.000Z","path":"2016/07/29/2016-07-29-docker-getting-started/","text":"本文对docker进行大致介绍，包括概述,安装,简单使用,架构,基本原理等方面 写在前面 本文是自己学习docker的一个记录和整理,啃英文文档挺吃力的,懒得翻译，所以写这篇类似“索引”的文章,希望能帮助和我一样的新手快速入门 本文主要参考官方文档(Docker Document)和相关技术博客 如果有理解有误的地方还望不吝指正 概述什么是Docker?可以参考下面三篇文章。从我使用的感受来看，我觉得Docker就是一个应用打包工具，把写好的应用用docker打包发布，然后别人就可以直接部署使用了，特别方便。 Docker是什么 理解Docker What is Docker？(译文) 什么是Docker Engine?Docker Engine is a client-server application with these major components: A server which is a type of long-running program called a daemon process. A REST API which specifies interfaces that programs can use to talk to the daemon and instruct it what to do. A command line interface (CLI) client. 我觉得官网的解释很言简意赅，附上图(摘自官网) Docker Engine Docker的用处 Faster delivery of your applications Deploying and scaling more easily Achieving higher density and running more workloads 安装安装参考Install Docker Engine Ubuntu以ubuntu 14.04 为例，参考Installation on Ubuntu安装Docker engine 这里列出重要的步骤： 更新apt源，包括添加证书，密钥等 用sudo apt-get安装 进一步配置，主要是创建docker用户组 注 ：如果输入docker info出问题，多半是权限问题，以sudo运行试试 Mac OS XMac下安装参考Installation on Mac OS X Mac下有两种安装方式供选 Docker for Mac : Mac的原生应用，没有使用虚拟机(VirtualBox)，而是使用的HyperKit Docker Toolbox : 会安装虚拟机，使用docker-machine来运行boot2docker 和Docker Engine 两者的区别请参考 Docker for Mac vs. Docker Toolbox 演示先不多说，跑起来体验下。具体的步骤和指令在Docker简明教程这篇文章已经写得很清楚了，在此不再赘述 架构和原理 dokcer architecture 由上图可知，docker是一个client-server架构 The Docker daemon : 运行在主机上 The Docker client : 用户和dokcer daemon交互的接口 docker的内部主要有三种资源/组件 docker images : build component,只可读 docker registries : distribution component,images共享库 docker containers : run component 这里重点说说images and containers Docker使用union file systems 把不同的层(layer)做整合成单一的image. Union File System的中一种是AUFS,可以参考这篇博文 官网文档对image的layers是这么描述的 Each Docker image references a list of read-only layers that represent filesystem differences. Layers are stacked on top of each other to form a base for a container’s root filesystem 新版docker(version&gt;=1.10)的存储模型有变化 Previously, image and layer data was referenced and stored using a randomly generated UUID. In the new model this is replaced by a secure content hash. container-based-on-ubuntu15.04 而container和image的主要区别就在于top writable layer，所有对image的更改都保存在这一层。换句话说，多个container可以共享同一个image，这就大大节省了空间。实现image和container的管理有两个关键的技术：stackable image layers 和 copy-on-write (CoW). multiple containers 从图中可以看出，copy-on-write (CoW)是一个很好的策略，既节省了空间，又避免了因数据共享带来的写冲突问题，从而提高效率。 结语本文主要对docker做简单介绍，对于一些更详细的知识，如docker file,volume,network,docker compose等等，会另写文章进行介绍。至于很具体的操作指令，比如怎么安装，怎么build image和run container来跑一个简单的docker hello world，请参考官方文档Docker Engine部分的“get started with docker”或者”learn by example”,也可参考文末的一些参考资料 参考资料 Docker Documentation(官方文档) Docker入门教程(系列) Docker简明教程（使用演示） docker中文（系列) docker资源 docker-从入门到实践(gitbook)","tags":[{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"},{"name":"Docker","slug":"Docker","permalink":"https://brianway.github.io/tags/Docker/"}]},{"title":"zookeeper单机伪集群配置","date":"2016-06-29T04:36:11.000Z","path":"2016/06/29/2016-06-29-zookeeper-replicated/","text":"本对zookeeper做简单介绍，分享查阅时搜集的一些好的链接，并以最新的稳定版zookeeper-3.4.8为例，对单机模式和伪分布式的部署步骤做记录和说明。 zookeeper简介Zookeeper 分布式服务框架是曾Apache Hadoop的一个子项目，现在是一个独立的顶级项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。 通读下面几个链接，可以对zookeeper有个大致了解 简单介绍：Apache ZooKeeper - 维基百科 项目主页：Apache ZooKeeper - Home IBM developerWorks:分布式服务框架 Zookeeper – 管理分布式环境中的数据 文档outline:ZooKeeper 3.4 Documentation 单机单server运行基本上照着ZooKeeper Getting Started Guide走一遍就OK了，这里简单描述下步骤 环境要求:各种系统都行，java １.6＋ 下载压缩包,解压 把解压目录下conf/zoo_sample.cfg复制一份在同目录下，重命名为zoo.cfg,dataDir属性可设置成别的 执行解压目录下的bin/zkServer.sh start开启zookeeper 执行解压目录下的bin/zkCli.sh -server 127.0.0.1:2181连接zookeeper 这时可以看到连接成功和一些欢迎信息，如果日志选项没改的话，默认是INFO级别，所以会在控制台看到一些日志输出，至此，已经运行成功，可以输入help查看帮助命令，试着玩一玩ls,create,get,set,delete等命令体验下 伪分布式官网对分布式讲的不是很详细，这里简单记录一下 大体流程就是把压缩包解压三份，每份单独配置conf/zoo.cfg,并在dataDir对应的目录下添加一个只含数字的文本文件myid表明自己是哪台服务器。 部署规模为3的单机伪机群 以我的电脑为例，我新建了一个根目录zookeeper,并在该目录下分别新建了三个文件夹：server0,server1,server2,然后在每个文件夹解压zookeeper的压缩包，并另外新建data，logs文件夹来分别存放数据和日志,目录结构如下： 12345678910111213.├── server0│ ├── data│ ├── logs│ └── zookeeper-3.4.8├── server1│ ├── data│ ├── logs│ └── zookeeper-3.4.8└── server2├── data├── logs└── zookeeper-3.4.8 然后在每个data目录下创建一个myid的文件(另外两个文件是运行后自动生成的，开始没有)，里面写入一个数字，这个数字和配置文件里的一致 1234mi@mi-OptiPlex-9020:~/MyPrograms/zookeeper/server0/data$ catmyid version-2/ zookeeper_server.pidmi@mi-OptiPlex-9020:~/MyPrograms/zookeeper/server0/data$ cat myid0 配置conf/zoo.cfg,比如我的server0目录下的配置文件，其他几个类似： 1234567891011121314151617181920# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial# synchronization phase can takeinitLimit=10# The number of ticks that can pass between# sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just# example sakes.dataDir=/home/mi/MyPrograms/zookeeper/server0/datadataLogDir=/home/mi/MyPrograms/zookeeper/server0/logs# the port at which the clients will connectclientPort=2180## 单机集群server.0=127.0.0.1:2880:3880server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882 server.A=B：C：D:其中 A 是一个数字，就是myid里的那个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址,C和D是两个端口。 两个端口的作用，官网描述如下： Finally, note the two port numbers after each server name: “ 2888” and “3888”. Peers use the former port to connect to other peers. Such a connection is necessary so that peers can communicate, for example, to agree upon the order of updates. More specifically, a ZooKeeper server uses this port to connect followers to the leader. When a new leader arises, a follower opens a TCP connection to the leader using this port. Because the default leader election also uses TCP, we currently require another port for leader election. This is the second port in the server entry. 简单来说，第一个端口用来集群成员的信息交换以及与集群中的Leader 服务器交换信息，第二个端口是在leader挂掉时专门用来进行选举leader所用。 因为是伪分布式，所以dataDir,clientPort也不一样，同时C,D两个端口也不能相同。 启动ZooKeeper伪机群的所有服务器 分别进入三个服务器文件夹的解压目录的/bin目录下，启动服务： 1bin/zkServer.sh start 接入客户端 进入解压目录的/bin目录下(3个server中任意一个)，连接任意一个服务器,比如我就是进入了server2的目录下，连接的server0 1bin/zkCli.sh -server 127.0.0.1:2180 运行截图 zookeeper_单机集群运行截图 参考链接 Apache ZooKeeper - 维基百科 Apache ZooKeeper - Home 分布式服务框架 Zookeeper – 管理分布式环境中的数据 ZooKeeper 3.4 Documentation zookeeper 单机伪集群配置 zookeeper入门（1）在单机上实现ZooKeeper伪机群/伪集群部署","tags":[{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://brianway.github.io/tags/ZooKeeper/"}]},{"title":"3D Rigid Object Tracking","date":"2016-05-16T04:58:00.000Z","path":"2016/05/16/2016-05-16-3D-Rigid-Object-Tracking/","text":"华中科技大学图像分析与理解课程项目–3D Rigid Object Tracking. 每周最新进展概况可参看Time Line,详细进度可参看Details 组员： 魏楚阳，邵滨峰，郑琪，付鼎 IntroductionThe objective of 3D rigid object tracking is to associate 3D target objects in consecutive video frames and meanwhile estimate the relative pose (3D translation and 3D rotation) between the 3D target and the camera.Rigid means the relative position among object components do not change. For instance, a cup, a book and a car are rigid object while a human face and a cat are non-rigid object.It has a variety of uses, some of which are: humancomputer interaction, security and surveillance, video communication and compression, augmented reality, traffic control, medical imaging and video editing. 3D object tracking can be especially difficult when the objects are moving fast relative to the frame rate. Another situation that increases the complexity of the problem is when the tracked object changes orientation over time. For these situations the tracking system usually employs a motion model which describes how the image of the target might change for different possible motions of the object. To Do List计划逐步扩充并实现下面的任务 选定项目题目，组队确定组员，创建项目链接(2016.5.13~2016.5.19) 阅读相关论文，确定实现方案(1~2周) 代码实现，PC上验证和测试方案(2周) 移植到移动端，在安卓设备上实现(1周) Time Line Time details 2016.05.16 choose the project 5,create the projetct link 2016.05.26 meet OpenCV,read two references,test one method 2016.06.02 Android preparing 2016.06.10 Monocular camera calibration and find corner on the object by Checkerboard 2016.06.16 Implement PC demo all by our own and complete the android version with Vuforia Video PC端演示视频 Android端演示视频 Reference [1]. Multiple 3D Object Tracking for Augmented Reality, In ISMAR, 2008. [2]. https://www.ssontech.com/tutes/tuteobj.html [3]. Manipulator and Object Tracking for In-Hand 3D Object Modeling, IN IJRR, 2011. [4]. Robust Statistics for 3D Object Tracking, In ICRA 2006. [5]. Real-time 3D Object Pose Estimation and Tracking for Natural Landmark Based Visual Servo. In IROS, 2008. [6]. OpenCV Tutorial C++ Details项目详细进展 week 1因为之前从来都没有接触过3D object tracking，所以这一周我们主要是从算法入手，选择性地详细阅读了两篇参考文献，了解一下实现步骤。 为了熟悉一下openCV，我们运行了一个tracking ball的小程序，没有考虑物体的3D信息： http://7xph6d.com1.z0.glb.clouddn.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE_trackingball.jpg 3D object tracking的复杂性在于要估计物体姿态，逼近物体表面，而不是简单地用一个方形或者圆形的框把物体框住。由于没有采集深度信息的设备，如Kinect等，我们只能利用基于模型的方法来实现。 [1] Youngmin Park, Vincent Lepetit, Woontack Woo. Multiple 3D Object Tracking for Augmented Reality. Proposed 方法把object detection和tracking结合起来了，可以满足实时性要求，并且同时可以tracking多个object，这是当时其他方法做不到的。 Proposed 方法由两个可以并行的模型组成，object detection和object tracking，如下图所示： 图像处理课_reference1-proposed方法.png 用于表示物体的数据结构： 包括几何信息和目标物体的外形。几何信息是一个存储在一系列三角形中的标准CAD 3D模型；外形信息则是由一些关键帧(keyframe)集合提供，这些关键帧主要是从不同视角拍摄物体，一般3、4个关键帧就足以360°覆盖整个物体。在每一个关键帧中，提取出特征点，也被称为keypoints，然后通过在3D模型上进行back-projecting的方式确定这些keypoints的3D位置，keypoints及其3D位置也被存储起来。 来自所有objects的所有N个keyframes被分到多个不同的子集中，每个子集中含有f个keyframe. (1) object detection：用reference[8]中的方法来匹配输入帧和关键帧，会得到两者之间特征点的匹配数，然后用RANSAC和non-iterative P-n-P算法来估测物体的pose。[这里得到的是matched keypoints] (2) frame-by-frame tracking：有两个目的：一是只要物体出现了就会被检测出来，以此达到tracking的目的；二是消除了单独的object detection可能产生的抖动。具体做法是：在每一帧输入中提取特征点，用基于cross-correlation和local search的方法将这些特征点和前面一帧中提取的特征点进行匹配。[这里得到的是“temporal keypoints”] (3) 将temporal keypoints和matched keypoints进行融合来估测物体的姿态 第一篇文章是2008年的，proposed方法可以实现多目标tracking，但是在实时性上可能效果不太好，作者也说的比较委婉。于是我们阅读了下面一篇文献，是2012年的。 [2] Changhyun Choi and Henrik I. Christensen. Real-time 3D Model-based Tracking Using Edge and Keypoint Features for Robotic Manipulation. 主要步骤： 先用keypoints完成Global Pose Estimation(GPE)中的estimate the initial pose步骤 然后用edge做tracking, 即Local Pose Estimation(LPE) 图像处理课_reference2-LPE.png 和[1]一样，这里也用到了事先存储好的关键帧（keyframe）集合；先得到当前帧的SURF keypoints，再利用这些keypoints将当前帧和关键帧match；keypoints的3D坐标也是通过在CAD model上进行back-projecting得到的，从而可以进行pose estimation。 这篇文章的实验部分写的比较详细，尤其是我们在第一篇文章中不知道CAD模型怎么获取等，在这篇文章中都有讲到。相比之下，这篇文章的方法更复杂，速度非常快，我们准备尝试实现该文章的算法，具体的细节下次再更新~ week 2本周主要完成安卓的准备工作 1.功能需求： 调用手机的相机进行拍照 对拍照得到的图像进行轮廓识别和描点（由于目前图像3D识别相关的c算法还未完成，这里先用google的人脸识别功能代替） 小组主页的展示 2.实现效果： 菜单见下图（菜单中包含照相、分析、关于我们三部分） 图像处理课_week2-菜单 3.相关知识点： 菜单的动画效果： 这里的动画效果采用的是属性动画（ValueAnimator），相比于原始动画，属性动画的点击效果会随动画的位置改变而改变这更加符合响应时的逻辑，而且属性动画的可定制性更高可以做出更酷炫的效果。属性动画的原理是基于TimeInterpolator和TypeEvaluator的。如果将属性值的变化过程看做一个数学函数的话，从动画效果上来看它是连续的，但实际上它还是离散的，因为它实际上也就是通过插入中间值（简称插值）从而”一帧一帧”完成动画的，那每一帧在哪里取，取多少呢？这也就是ValueAnimator类主要完成的作用。TimeInterpolator用来控制在哪里取，而TypeEvaluator用来控制取多少。 调用相机功能： 调用相机的原理是通过使用startActivityForResult来启动相机组件，拍照完成后通过onActivityResult方法可以获取到拍照得到的图像，进而可以对图像进行处理。在这里需要做一个适配。需要判断当前android手机的版本是6.0以前的还是6.0以后的（&gt;=6.0）,因为android6.0以后采用的是运行时的权限机制，需要在运行时由用户自行决定是否开启某项权限（这里主要是两个权限：调用相机和访问存储空间），这就需要在代码中加入额外的逻辑。 人脸识别： 这里调用的是google人脸识别的api，其识别原理是先对人眼进行识别，然后再得到其余的相关点。人脸识别的过程相对比较耗时，因此我们通过使用AsyncTask将其放入异步线程中执行防止其对主线程的阻塞。在AsyncTask类中有三个主要的方法，分别是onPreExecute（）、doInBackground（）、onPostExecute（）。首先在onPreExecute中初始化加载对话框提示用户正在进行加载，然后将人脸识别的任务放在异步的doInBackground方法中进行执行，最后onPostExecute方法回到主线程来取消加载对话框并显示人脸识别后的图像。 图像处理课_week2-识别人脸 app中内嵌web页面： 这里我们使用的是WebView来做的内嵌页面。通过对WebView设置加载客户端和访问Url地址可以使其显示相关网页上的内容。这里需要注意的是要开启JavaScript配置，这样显示出来的页面才具有交互性。并且设置加载客户端时需要覆盖shouldOverrideUrlLoading方法，这样页面才能在app程序中运行，而不是调用系统的浏览器运行。最后还需要覆盖该activity界面的onKeyDown方法，设置按下返回键时判断WebView能否返回上一页面，若能返回则返回上一页面，否则退出这个activity。 好吧，这周的工作就到此为止啦，下周将继续研究和实现java使用jni调用c算法的部分~ week 3由于端午过节，更新晚了。 上周完成了两个任务，一是单目摄像机的标定，主要是利用棋盘格子和opencv的calibrateCamera()函数，计算摄像机的内参矩阵和RT矩阵。那么对于图像平面上的二维点，可以求出对应的三维坐标，找到物体平面和图像平面之间的关系，如图所示： week3-平面 可以看出，与视线垂直的棋盘面上的物体是垂直于棋盘面的。 另外一个就是以棋盘为参照物，在棋盘旁放置物体，可以找到该物体上的角点，用于后面的三维重建： week3-棋盘格 week 4俗话说的好，deadline是第一生产力。这周我们完成了PC端的简单demo以及android端的程序，演示视频已在Video部分更新。 PC部分 在之前阅读了一些参考文献后，对3d物体追踪的步骤有了基本了解，但由于对CAD等3维模型不熟悉，加上时间比较紧迫，我们降低了实验难度和实现结果的预期，对实验条件进行了简化(如:采用规则物体)并只使用长方体框出物体并进行姿态估计，而不是做到实时勾勒出物体的轮廓。 效果如图(tracking的框画漏了)，具体可看视频部分： PC 实现思路是选择一帧图像作为参考，具体而言就是，在棋盘图像上放置物体，利用棋盘对摄像头进行标定，并计算出棋盘坐标系。然后找出图中物体的特征点，计算ORB特征描述。对物体的特征点进行kmeans聚类，可以得到物体的中心点，在中心点处的棋盘坐标系上以长方体给出物体的姿态估计。 后面对物体的追踪部分就是找出物体特征点，计算其ORB特征描述(正好我们组之前论文阅读汇报作业里读的论文就是BRIEF，也算学以致用吧)，并与参考帧进行特征点匹配。计算匹配特征点之间的单应性矩阵，然后对初始姿态的长方体角点进行变换，更新物体姿态。 环境配置：Python 2.7.6 + openCV 2.4.10，Ubuntu 14.04 Android部分 本来计划是在PC端实现算法，然后封装起来，在移动端通过JNI调用，但由于时间不够App最后的功能实现使用的是Vuforia的SDK中的算法（也是基于openGL实现的，封装成接口，可以直接调用）。 3D物体追踪主要涉及两个方面： 物体的特征提取 根据1中得到的物体特征进行物体识别和追踪 其中物体的特征识别使用的是Vuforia的Scanner软件，将物体放在定标纸可以定标的区域，然后对物体进行360度的拍摄扫描得到物体的特征信息如图（示例中扫描的物体为一个鼠标） scanner 特征信息会保存到一个od文件中。在Vuforia的开发者平台上，开发者可以创建自己的数据库，在数据库中添加刚刚得到的od文件，之后便可以下载得到这个od文件对应的xml数据文件，这个xml数据文件会在后面我们设计的app中用到。 接下来就是我们自己app的部分了，首先需要进行一些环境的配置： 将开发者网站上下载的sdk文件放置到libs文件夹下，并在build.gradle文件依赖中设置编译这个sdk； 新建一个jniLibs文件夹，将算法主体的libVuforia.so（封装了调用openGL的算法）放置到该文件夹下，在build.gradle文件配置.so文件使其可以被正确引用； 将开发者网站中注册得到的license key配置到Vuforia的初始代码中； 将先前得到的xml数据文件放到项目的assets文件中。 配置完成以后就是界面和实现的部分了。进入物体追踪界面时首先会进行任务的初始化，初始化包括： 初始化框住物体的openGL view，这个view是基于android的GLSurfaceView实现的； 渲染器的初始化，这里的渲染器是基于GLSurfaceView里的内部类Renderer来实现的； Vuforia任务初始化，初始化后将其绑定到2的渲染器上，在渲染器上通过设置Texture可以设置渲染器的渲染材质，将渲染器绑定到openGL view上。 初始化时界面背景为黑色，且中间会显示一个进度条代表正在进行初始化，初始化完毕以后显示摄像头界面并取消进度条。初始化完成以后就可开始物体的识别和追踪了。该activity设置了GestureListener实现了手势监听，单击屏幕中要追踪的物体则会显示一个正方体块将目标物体包住（这里需要借助定标纸），与此同时会初始化一个Object Tracker来跟踪物体实时位置变化使包络能和物体一起移动。现在拖动定标纸，就可以看到正方形包络和物体一起发生移动，效果如下图，具体可看视频部分。","tags":[{"name":"project","slug":"project","permalink":"https://brianway.github.io/tags/project/"}]},{"title":"几种常见排序算法","date":"2016-05-07T22:19:00.000Z","path":"2016/05/08/2016-05-08-algorithms-several-sort-algorithms/","text":"本文介绍几种常见排序算法（选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序），对算法的思路、性质、特点、具体步骤、java实现以及trace图解进行了全面的说明。最后对几种排序算法进行了比较和总结。 写在前面 本文所有图片均截图自coursera上普林斯顿的课程《Algorithms, Part I》中的Slides 相关命题的证明可参考《算法（第4版）》 源码可在官网下载,也可以在我的github仓库 algorithms-learning下载，已经使用maven构建 仓库下载：git clone git@github.com:brianway/algorithms-learning.git 基础介绍 java: Interface Comparable&lt;T&gt; Java中很多类已经实现了Comparable&lt;T&gt;接口，用户也可自定义类型实现该接口 total order: Antisymmetry(反对称性): if v ≤ w and w ≤ v, then v = w. Transitivity(传递性): if v ≤ w and w ≤ x, then v ≤ x. Totality: either v ≤ w or w ≤ v or both. 注意： The &lt;= operator for double is not a total order，violates totality: (Double.NaN &lt;= Double.NaN) is false 通用代码： 1234567891011// Less. Is item v less than w ?private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0;&#125;//Exchange. Swap item in array a[] at index i with the one at index jprivate static void exch(Comparable[] a,, int i, int j) &#123; Comparable swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 初级排序算法selection sort(选择排序)思路： 在第i次迭代中，在剩下的(即未排序的)元素中找到最小的元素 将第i个元素与最小的元素交换位置 现象： 设已排序的和未排序的交界处为 ↑，则每次循环， ↑ 从左往右移动一个位置 ↑ 左边的元素（包括↑）固定了，且升序 ↑ 右边的任一元素全部比左边的所有元素都大 选择排序 步骤： move the pointer to the right indentify index of minimun entry on right exchange into positon 选择排序 java实现： 12345678910public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 0; i &lt; N; i++) &#123; int min = i; for (int j = i+1; j &lt; N; j++) &#123; if (less(a[j], a[min])) min = j; &#125; exch(a, i, min); &#125;&#125; 特点： 运行时间和输入无关，无论输入是已排序，时间复杂度都是O(n^2) 数据移动最少，交换的次数和数组大小是线性关系 insertion sort(插入排序)思路： 在第i次迭代中，将第i个元素与每一个它左边且比它大的的元素交换位置 现象： 设已排序的和未排序的交界处为 ↑，则每次循环， ↑ 从左往右移动一个位置 ↑ 左边的元素（包括↑）且升序，但位置不固定(因为后续可能会因插入而移动) ↑ 右边的元素还不可见 插入排序 步骤： Move the pointer to the right. Moving from right to left, exchange a[i] with each larger entry to its left. 插入排序 java实现： 12345678public static void sort(Comparable[] a) &#123; int N = a.length; for (int i = 0; i &lt; N; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) &#123; exch(a, j, j-1); &#125; &#125;&#125; inversion（倒置）：An inversion is a pair of keys that are out of order 部分有序：An array is partially sorted if the number of inversions is ≤ c N. 特点： 运行时间和输入有关，当输入已排序时，时间复杂度是O(n); For partially-sorted arrays, insertion sort runs in linear time.(交换的次数等于输入中倒置(inversion)的个数) 插入排序适合部分有序数组，也适合小规模数组 ShellSort(希尔排序)希尔排序是基于插入排序的。 思路： Move entries more than one position at a time by h-sorting the array 按照h的步长进行插入排序 现象： 数组中任意间隔为h的元素都是有序的 A g-sorted array remains g-sorted after h-sorting it. 性质： 递增数列一般采用3x+1：1,4,13,40,121,364…..，使用这种递增数列的希尔排序所需的比较次数不会超过N的若干倍乘以递增数列的长度。 最坏情况下，使用3x+1递增数列的希尔排序的比较次数是O(N^(3/2)) java实现： 1234567891011121314151617public static void sort(Comparable[] a) &#123; int N = a.length; // 3x+1 increment sequence: 1, 4, 13, 40, 121, 364, 1093, ... int h = 1; while (h &lt; N/3) h = 3*h + 1; while (h &gt;= 1) &#123; // h-sort the array for (int i = h; i &lt; N; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h) &#123; exch(a, j, j-h); &#125; &#125; h /= 3; &#125;&#125; shuffing(不是排序算法) 目标：Rearrange array so that result is a uniformly random permutation shuffle sort思路 为数组的每一个位置生成一个随机实数 排序这个生成的数组 Knuth shuffle demo In iteration i, pick integer r between 0 and i uniformly at random. Swap a[i] and a[r]. correct variant: between i and N – 1 Mergesort–Java sort for objects. Quicksort–Java sort for primitive types. 下面看看这两种排序算法 merge sort(归并排序)思路： Divide array into two halves. Recursively sort each half. Merge two halves. Abstract in-place merge(原地归并的抽象方法) Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi],replace with sorted subarray a[lo] to a[hi] 步骤： 先将所有元素复制到aux[]中，再归并回a[]中。 归并时的四个判断： 左半边用尽(取右半边元素) 右半边用尽(取左半边元素) 右半边的当前元素小于左半边的当前元素(取右半边的元素) 右半边的当前元素大于/等于左半边的当前元素(取左半边的元素) merging java实现： 123456789101112131415161718 // stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi]private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // precondition: a[lo .. mid] and a[mid+1 .. hi] are sorted subarrays // copy to aux[] for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; // merge back to a[] int i = lo, j = mid+1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125;&#125; Top-down mergesort(自顶向下的归并排序)mergesort java实现： 12345678// mergesort a[lo..hi] using auxiliary array aux[lo..hi]private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); //将左边排序 sort(a, aux, mid + 1, hi); //将右边排序 merge(a, aux, lo, mid, hi); //归并结果&#125; 自顶向下的归并排序的轨迹图 归并排序 由图可知，原地归并排序的大致趋势是，先局部排序，再扩大规模；先左边排序，再右边排序；每次都是左边一半局部排完且merge了，右边一半才开始从最局部的地方开始排序。 改进 对小规模子数组使用插入排序 测试数组是否已经有序（左边最大&lt;右边最小时，直接返回） 不将元素复制到辅助数组(节省时间而非空间) Bottom-up mergesort(自底向上的归并排序)思路： 先归并微型数组，从两两归并开始(每个元素理解为大小为1的数组) 重复上述步骤，逐步扩大归并的规模，2,4,8….. java实现： 1234567891011public class MergeBU&#123; private static void merge(...)&#123; /* as before */ &#125; public static void sort(Comparable[] a)&#123; int N = a.length; Comparable[] aux = new Comparable[N]; for (int sz = 1; sz &lt; N; sz = sz+sz) for (int lo = 0; lo &lt; N-sz; lo += sz+sz) merge(a, aux, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1)); &#125;&#125; 自底向上的归并排序的轨迹图 归并排序 由图可知，自底向上归并排序的大致趋势是，先局部排序，逐步扩大到全局排序；步调均匀，稳步扩大 quicksort思路： Shuffle the array. Partition(切分) so that, for some j entry a[j] is in place no larger entry to the left of j no smaller entry to the right of j Sort each piece recursively. 其中很重要的一步就是Partition(切分)，这个过程使得满足以下三个条件: 对于某个j,a[j]已经排定; a[lo]到a[j-1]中的所有元素都不大于a[j]; a[j+1]到a[hi]中的所有元素都不小于a[j]; partition java实现 12345678910111213141516171819202122232425262728// partition the subarray a[lo..hi] so that a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]// and return the index j.private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; // find item on lo to swap while (less(a[++i], v)) if (i == hi) break; // find item on hi to swap while (less(v, a[--j])) if (j == lo) break; // redundant since a[lo] acts as sentinel // check if pointers cross if (i &gt;= j) break; exch(a, i, j); &#125; // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi] return j;&#125; 快排java实现： 12345678910111213public static void sort(Comparable[] a) &#123; StdRandom.shuffle(a); sort(a, 0, a.length - 1);&#125;// quicksort the subarray from a[lo] to a[hi]private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); assert isSorted(a, lo, hi);&#125; 快排的轨迹图 快速排序 由图可知，和归并排序不同，快排的大致趋势是，先全局大体有个走势——左边比右边小，逐步细化到局部；也是先左后右；局部完成时全部排序也就完成了。 一些实现的细节： 原地切分：不使用辅助数组 别越界：测试条件(j == lo)是冗余的(a[lo]不可能比自己小)； 保持随机性：初始时的随机打乱跟重要 终止循环 处理切分元素值有重复的情况：这里可能出问题 性质： 快排是in-place的 快排不稳定 改进 对小规模子数组使用插入排序 三取样切分 三向切分的快速排序思路： Let v be partitioning item a[lo]. Scan i from left to right. (a[i] &lt; v): exchange a[lt] with a[i]; increment both lt and i (a[i] &gt; v): exchange a[gt] with a[i]; decrement gt (a[i] == v): increment i 主要是通过增加一个指针来实现的。普通的快拍只有lo和high两个指针，故只能记录大于(high右边)和小于(lo左边)两个区间，等于只能并入其中一个；这里增加了使用了lt,i,gt三个指针，从而达到记录大于(gt右边)、小于(lt左边)和等于(lt和i之间)三个区间。 三切分的示意图 三向切分 三向切分的java实现： 1234567891011121314151617// quicksort the subarray a[lo .. hi] using 3-way partitioningprivate static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo; while (i &lt;= gt) &#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; &#125; // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. sort(a, lo, lt-1); sort(a, gt+1, hi);&#125; Heapsort(堆排序)思路： Create max-heap with all N keys. Repeatedly remove the maximum key. swim:由下至上的堆有序化 sink:由上至下的对有序化 堆排序主要分为两个阶段： 堆的构造 下沉排序 java实现如下： 123456789101112public static void sort(Comparable[] pq) &#123; int N = pq.length; //堆的构造 for (int k = N/2; k &gt;= 1; k--) sink(pq, k, N); //下沉排序 while (N &gt; 1) &#123; exch(pq, 1, N--); sink(pq, 1, N); &#125;&#125; 堆排序的轨迹图 堆排序 由图看出，堆排序的趋势是，堆构造阶段，大致是降序的走势，到了下沉阶段，从右到左（或者说从后往前）逐步有序 Significance： In-place sorting algorithm with N log N worst-case. Mergesort: no, linear extra space. Quicksort: no, quadratic time in worst case 缺点 Inner loop longer than quicksort’s. Makes poor use of cache memory. Not stable(不稳定) 总结和比较排序算法总结表 总结 最好情况和最坏情况：参见上面的表格 关于稳定性： 稳定性，插入排序，归并排序 不稳定：选择排序，快排，希尔排序，堆排序 原因： Long-distance exchange 关于额外空间：除了归并排序需要线性的额外空间，其他都是in-place的 命题 对于长度为N的数组，选择排序需要N^2/2次比较和N次交换(pf见P156) 对于随机排列的长度为N的且主键不重复的数组（pf见P157） 平均情况下插入排序需要~N^2/4次比较和~N^2/4次交换 最坏情况下需要~N^2/2次比较和~N^2/2次交换， 最好情况下需要N-1次比较和0次交换。 Mergesort uses at most N lg N compares and 6 N lg N array accesses to sort any array of size N. (pf见P173) Mergesort uses extra space proportional to N.(The array aux[] needs to be of size N for the last merge.) Any compare-based sorting algorithm must use at least lg ( N ! ) ~ N lg N compares in the worst-case.(pf见P177) 长度为N的无重复数组排序，快速排序平均需要~2N ln N 次比较（以及1/6即1/3 N ln N的交换） 最多需要约N^2/2次比较 最少需要~N lg N 次比较 用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换(pf见P206) 将N个元素排序，堆排序只需少于（2NlgN+2N）次比较以及一半次数的交换(pf见P208)","tags":[{"name":"算法","slug":"算法","permalink":"https://brianway.github.io/tags/算法/"}]},{"title":"java多线程核心技术梳理(附源码)","date":"2016-04-18T00:18:01.000Z","path":"2016/04/18/2016-04-18-javase-multithread-programming-reading-note/","text":"本文对多线程基础知识进行梳理，主要包括多线程的基本使用，对象及变量的并发访问，线程间通信，lock的使用，定时器，单例模式，以及线程状态与线程组。 写在前面花了一周时间阅读《java多线程编程核心技术》(高洪岩 著)，本文算是此书的整理归纳，书中几乎所有示例，我都亲手敲了一遍，并上传到了我的github上，有兴趣的朋友可以到我的github下载。源码采用maven构建，多线程这部分源码位于java-multithread模块中。 仓库地址：java-learning git clone： `git@github.com:brianway/java-learning.git` java多线程基础知识 创建线程的两种方式：1.继承Thread类，2.实现Runnable接口。具体两者的联系可以参考我之前的博文《java基础巩固笔记(5)-多线程之传统多线程》 一些基本API：isAlive(),sleep(),getId(),yield()等。 isAlive()测试线程是否处于活动状态 sleep()让“正在执行的线程”休眠 getId()取得线程唯一标识 yield()放弃当前的CPU资源 弃用的API:stop(),suspend(),resume()等，已经弃用了，因为可能产生数据不同步等问题。 停止线程的几种方式： 使用退出标识，使线程正常退出，即run方法完成。 使用interrupt方法中断线程 线程的优先级:继承性，规则性，随机性 线程的优先级具有继承性. 如,线程A启动线程B，则B和A优先级一样 线程的优先级具有规则性. CPU尽量倾向于把资源优先级高的线程 线程的优先级具有随机性. 优先级不等同于执行顺序，二者关系不确定 java中的两种线程：用户线程和守护(Daemon)线程。 守护线程：进程中不存在非守护线程时，守护线程自动销毁。典型例子如：垃圾回收线程。 比较和辨析 某个线程与当前线程：当前线程则是指正在运行的那个线程，可由currentThread()方法返回值确定。例如，直接在main方法里调用run方法，和调用线程的start方法，打印出的当前线程结果是不同的。 interrupted()和isInterrupted() interrupted()是类的静态方法，测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能。 isInterrupted()是类的实例方法，测试Thread对象是否已经是中断状态，但不清楚状态标志。 sleep()和wait()区别： sleep()是Thread类的static(静态)的方法；wait()方法是Object类里的方法 sleep()睡眠时，保持对象锁，仍然占有该锁；wait()睡眠时，释放对象锁 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级；wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程 wait()必须放在synchronized block中，否则会在runtime时扔出java.lang.IllegalMonitorStateException异常 方法 是否释放锁 备注 wait 是 wait和notify/notifyAll是成对出现的, 必须在synchronize块中被调用 sleep 否 可使低优先级的线程获得执行机会 yield 否 yield方法使当前线程让出CPU占有权, 但让出的时间是不可设定的 对象及变量的并发访问 synchronized关键字 调用用关键字synchronized声明的方法是排队运行的。但假如线程A持有某对象的锁，那线程B异步调用非synchronized类型的方法不受限制。 synchronized锁重入:一个线程得到对象锁后，再次请求此对象锁时是可以得到该对象的锁的。同时，子类可通过“可重入锁”调用父类的同步方法。 同步不具有继承性。 synchronized使用的“对象监视器”是一个，即必须是同一个对象 synchronized同步方法和synchronized同步代码块。 对其他synchronized同步方法或代码块调用呈阻塞状态。 同一时间只有一个线程可执行synchronized方法/代码块中的代码 synchronized(非this对象x)，将x对象作为“对象监视器” 当多个线程同时执行synchronized(x){}同步代码块时呈同步效果 当其他线程执行x对象中synchronizd同步方法时呈同步效果 当其他线程执行x对象方法里的synchronized(this)代码块时呈同步效果 静态同步synchronized方法与synchronized(class)代码块：对当前对应的class类进行持锁。 线程的私有堆栈图 javaSE_多线程-线程的私有堆栈 volatile关键字：主要作用是使变量在多个线程间可见。加volatile关键字可强制性从公共堆栈进行取值,而不是从线程私有数据栈中取得变量的值 在方法中while循环中设置状态位(不加volatile关键字)，在外面把状态位置位并不可行，循环不会停止，比如JVM在-server模式。 原因：是私有堆栈中的值和公共堆栈中的值不同步 volatile增加了实例变量在多个线程间的可见性，但不支持原子性 原子类:一个原子类型就是一个原子操作可用的类型，可在没有锁的情况下做到线程安全。但原子类也不是完全安全，虽然原子操作是安全的，可方法间的调用却不是原子的，需要用同步。 读取公共内存图 javaSE_多线程-读取公共内存.png 辨析和零散补充 synchronized静态方法与非静态方法：synchronized关键字加static静态方法上是给Class类上锁，可以对类的所有实例对象起作用；synchronized关键字加到非static静态方法上是给对象上锁，对该对象起作用。这两个锁不是同一个锁。 synchronized和volatile比较 1)关键字volatile是线程同步的轻量级实现，性能比synchronized好，且volatile只能修饰变量，synchronized可修饰方法和代码块。 2)多线程访问volatile不会发生阻塞，synchronized会出现阻塞 3)volatile能保证数据可见性，不保证原子性;synchronized可以保证原子性，也可以间接保证可见性，因为synchronized会将私有内存和公共内存中的数据做同步。 4)volatile解决的是变量在多个线程间的可见性，synchronized解决的是多个线程访问资源的同步性。 String常量池特性，故大多数情况下，synchronized代码块都不适用String作为锁对象。 多线程死锁。使用JDK自带工具，jps命令+jstack命令监测是否有死锁。 内置类与静态内置类。 锁对象的的改变。 一个线程出现异常时，其所持有的锁会自动释放。 变量在内存中的工作过程图 javaSE_多线程-变量在内存中的工作过程.png 线程间通信 等待/通知机制：wait()和notify()/notifyAll()。wait使线程停止运行，notify使停止的线程继续运行。 wait()：将当前执行代码的线程进行等待，置入”预执行队列”。 在调用wait()之前，线程必须获得该对象的对象级别锁； 执行wait()方法后，当前线程立即释放锁； 从wait()返回前，线程与其他线程竞争重新获得锁 当线程呈wait()状态时，调用线程的interrup()方法会出现InterrupedException异常 wait(long)是等待某一时间内是否有线程对锁进行唤醒，超时则自动唤醒。 notify()：通知可能等待该对象的对象锁的其他线程。随机挑选一个呈wait状态的线程，使它等待获取该对象的对象锁。 在调用notify()之前，线程必须获得该对象的对象级别锁； 执行完notify()方法后，不会马上释放锁，要直到退出synchronized代码块，当前线程才会释放锁。 notify()一次只随机通知一个线程进行唤醒 notifyAll()和notify()差不多，只不过是使所有正在等待队中等待同一共享资源的“全部”线程从等待状态退出，进入可运行状态。 每个锁对象有两个队列：就绪队列和阻塞队列。 就绪队列：存储将要获得锁的线程 阻塞队列：存储被阻塞的的线程 生产者/消费者模式 “假死”：线程进入WAITING等待状态，呈假死状态的进程中所有线程都呈WAITING状态。 假死的主要原因：有可能连续唤醒同类。notify唤醒的不一定是异类，也许是同类，如“生产者”唤醒“生产者”。 解决假死：将notify()改为notifyAll() wait条件改变，可能出现异常，需要将if改成while 通过管道进行线程间通信：一个线程发送数据到输出管道，另一个线程从输入管道读数据。 字节流：PipedInputStream和PipedOutputStream 字符流：PipedReader和PipedWriter join()：等待线程对象销毁，具有使线程排队运行的作用。 join()与interrupt()方法彼此遇到会出现异常。 join(long)可设定等待的时间 join与synchronized的区别：join在内部使用wait()方法进行等待;synchronized使用的是“对象监视器”原理作为同步 join(long)与sleep(long)的区别：join(long)内部使用wait(long)实现，所以join(long)具有释放锁的特点;Thread.sleep(long)不释放锁。 ThreadLocal类：每个线程绑定自己的值 覆写该类的initialValue()方法可以使变量初始化，从而解决get()返回null的问题 InheritableThreadLocal类可在子线程中取得父线程继承下来的值。 Lock的使用 ReentrantLock类：实现线程之间的同步互斥，比synchronized更灵活 lock()，调用了的线程就持有了“对象监视器”，效果和synchronized一样 使用Condition实现等待/通知：比wait()和notify()/notyfyAll()更灵活，比如可实现多路通知。 调用condition.await()前须先调用lock.lock()获得同步监视器 Object与Condition方法对比 Object Condition wait() await() wait(long timeout) await(long time,TimeUnit unit) notify() signal() notifyAll() signalAll() 一些API 方法 说明 int getHoldCount() 查询当前线程保持此锁定的个数，即调用lock()方法的次数 int getQueueLength() 返回正在等待获取此锁定的线程估计数 int getWaitQueueLength(Condition condition) 返回等待与此锁定相关的给定条件Conditon的线程估计数 boolean hasQueueThread(Thread thread) 查询指定的线程是否正在等待获取此锁定 boolean hasQueueThreads() 查询是否有线程正在等待获取此锁定 boolean hasWaiters(Condition) 查询是否有线程正在等待与此锁定有关的condition条件 boolean isFair() 判断是不是公平锁 boolean isHeldByCurrentThread() 查询当前线程是否保持此锁定 boolean isLocked() 查询此锁定是否由任意线程保持 void lockInterruptibly() 如果当前线程未被中断，则获取锁定，如果已经被中断则出现异常 boolean tryLock() 仅在调用时锁定未被另一个线程保持的情况下，才获取该锁定 boolean tryLock(long timeout,TimeUnit unit) 如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定 公平锁与非公平锁 公平锁表示线程获取锁的顺序是按照加锁的顺序来分配的，即FIFO先进先出。 非公平锁是一种获取锁的抢占机制，随机获得锁。 ReentrantReadWriteLock类 读读共享 写写互斥 读写互斥 写读互斥 定时器常用API 方法 说明 schedule(TimerTask task, Date time) 在指定的日期执行某一次任务 scheduleAtFixedRate(TimerTask task, Date firstTime, long period) 在指定的日期之后按指定的间隔周期，无限循环的执行某一任务 schedule(TimerTask task, long delay) 以执行此方法的当前时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务 schedule(TimerTask task, long delay, long period) 以执行此方法的当前时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一TimerTask任务 schedule和scheduleAtFixedRate的区别:schedule不具有追赶执行性;scheduleAtFixedRate具有追赶执行性 单例模式与多线程 立即加载/“饿汉模式”：调用方法前，实例已经被创建了。通过静态属性new实例化实现的 延迟加载/“懒汉模式”：调用get()方法时实例才被创建。最常见的实现办法是在get()方法中进行new实例化 缺点：多线程环境中，会出问题 解决方法 声明synchronized关键字，但运行效率非常低下 同步代码块，效率也低 针对某些重要代码(实例化语句)单独同步，效率提升，但会出问题 使用DCL双检查锁 使用enum枚举数据类型实现单例模式 拾遗补增方法与状态关系示意图 javaSE_多线程-方法与状态关系示意图.png 线程的状态：Thread.State枚举类,参考官网APIEnum Thread.State 线程组：线程组中可以有线程对象，也可以有线程组，组中还可以有线程。可批量管理线程或线程组对象。 SimpleDateFormat非线程安全，解决办法有： 创建多个SimpleDateFormat类的实例 使用ThreadLocal类 线程组出现异常的处理 setUncaughtExceptionHandler()给指定线程对线设置异常处理器 setDefaultUncaughtExceptionHandler()对所有线程对象设置异常处理器 参考资料 浅谈Java中的锁 java synchronized关键字的用法 Java Thread(线程)案例详解sleep和wait的区别","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://brianway.github.io/tags/多线程/"}]},{"title":"一场说走就走的会友之旅(流水账)","date":"2016-04-05T06:07:00.000Z","path":"2016/04/05/2016-04-05-Travel-notes/","text":"好久没出去转转了，上次出去还是毕业前夕7人小分队和班级毕业旅行。转眼快一年了，恰逢清明假日，提前两天便出发，会会老友，聊聊人生。 第一站：北京夜发朝至的卧铺，7点就到了北京，感谢杜sir凌晨4点多从村里来接我，在西直门和小鑫汇合，进了传说中的庆丰包子铺尝了尝习大大同款炒肝(just so so)。 种种原因，错过了八达岭的行程，改道去中科院，途径“怀柔光谷”，转乘小黑车，然后236寝室毕业之后首度合影。(不要问我为什么打码，因为阿耀说要遮住台阶！) 寝室合影 大三暑假时基本把颐和园、圆明园、故宫、景山公园、北海公园玩遍了，所以这次主要是见见老同学，散散步、聊聊天。 下午加上超洁、张立琨，一起徒步环湖一周，一路走一路聊，从实验室近况聊到工作意向，从选课、实习聊到人生、八卦。然后各种自拍，也是拼了…可以感受下。 当天雾霾，简直拍不清楚，感受一下不同的雁栖湖吧,清晰版vs雾霾版。 清晰版 清晰版 雾霾版 雾霾版 张立琨的拍照技术不错，构图和角度感觉很nice，还能用手机拍出景深的效果(某朵花的特写)。下面这嵌入乱石的水泥路和地标日出东方均出自他手。 石头路 石头路 日出东方 日出东方 晚上筋疲力尽，在室友给我订的中科院招待所入住了双卧双床双电视，简直高大上！感谢室友的全程款待，包吃包车包住包接送，真是给力！最后感谢张立琨送我去车站。 感觉北京这个城市整体给人的节奏很快的感觉，无论是7点的地铁上看到中学生捧着笔记本埋头读记，还是坐错方向结果没挤上地铁，再或者清晨空气中扑鼻的灰尘味，都给人一种无形的压力。 第二站：嘉兴很早二哥就邀我来他家这边玩了，正好恰逢他北大汇丰复试刚过，赋闲在家，我就来了。 在高铁上列了下假期后几个讲座的提纲，尝试了下15元套餐。一出南站就碰到二哥接我了，在他家围观了下“工科吊”是怎么转战“金融狗”的，你们感受下。 二哥书架 二哥书架 第二天上午，二哥带我逛了下市区的南湖和月河。按照国际惯例，拍照留图。 南湖小船 南湖小船 南湖的桥 南湖桥 中午和他的同学一起吃的火锅，简直是虐狗。人家都是一对对的，谈婚论嫁了，一对计划着今年领证明年办婚礼，一对谈论着生几个，另一对说要躲开上海的丈母娘换个地方住。。。单身狗表示受到暴击。 在这里发现浙江人真是会做生意，比如我吃的那家早餐店，同时卖手抓饼和杂粮煎饼(选择多了一倍，原料准备却不用花两倍精力，真是花心思了)，还附带卖豆浆和水等饮品，真是想的周到，一个路边摊而已，居然微信支付宝齐全，方便的一逼；再比如下午和大家一起玩的桌游，一个人才34，饮料无限续杯，还可以打台球和电玩，感觉好划算。 第三站：杭州因为老司机最近很忙，所以我在嘉兴的晚上制定第二天的行程，为了错开西湖客流， 原计划是茅家埠-&gt;浴鹄湾-&gt;四眼井-&gt;江洋生态公园-&gt;大兜路,结果我特么地图都背好了，请教帮主，帮主说那些也是西湖周边，有去无回。真是血坑，早知道直接问帮主就好了。 这就算了，因为全程都有人带，所以我这次没怎么做攻略，因为我是那种买鞋信脚不信码的人，想着有活地图用啥百度地图。然后事实证明，我错了。 我：“出了东站坐哪路到紫金港？” 老司机：“89路” 嗯，我信了，直到我看到一个93路车的抬头是”前往浙大紫金港”…老司机就是老司机，为了不让这次旅途平淡无趣、没有挑战，为了考察我的信息甄别、信息检索、临场应变等综合能力，为了加深我对杭州公交的认识，选择了这样一道送分题，没难到我，哼哼~ 然后中午到了紫金港,吃了”童年小筑”，就去西溪湿地了。因为下雨，主要是乘船游湖，岸上就简单逛了逛花朝节。景美人更美，哪有心思拍照，此处就无图了，嗯…. 晚餐 晚餐 晚餐没吃完，太多了。。。我和老司机战斗力不行，没办法。老司机没教会我剥螃蟹，看来下次得找老司机的师傅教我了。晚上看了《火锅英雄》，剧情不错~ 第二天上午逛了下紫金港校区，感觉真是漂亮，进门就是偌大的草坪，左手边一栋高高的行政楼和很气派的四层图书馆。校园里面各种视野开阔，绿荫垂柳，小桥流水，真的是美不胜收，哦，又忘了拍照，下次再去好了。 中午去了玉泉，找帮主蹭饭，帮主真老司机！首先驾轻就熟的穿过条条小路带我来到了一家餐厅，前面一哥们被告知排号要排一个小时，他镇定自若的拿出手机，报了下号码，服务员就把我们领进去了，牛逼！然后几个菜都挺可口的，菜名我忘了，只记得一个叫西湖牛肉羹。 帮主 帮主 下午先在咖啡厅小憩了一下，顺便参观了帮主的实验室，然后就去爬了下老和山俯瞰风景。路上有个小插曲，我俩无聊，数了下来往车辆的牌子，结果30秒内经过的车，5辆奥迪4辆宝马，不得不感叹杭州人真是有钱。 老和山俯瞰 老和山 此行感觉浙大完爆我科，真的有点后悔当初年少无知，没有试一下浙大，没办法，自己选的路，跪着也要走完。 完这一趟游学收获还是蛮大的，了解了好友们的近况，感受到差距，看到大家都这么优秀，感觉自己必须好好努力了，不然掉队掉太远就不好玩了。以后至少每半年出去一趟，散散心，开开眼。","tags":[{"name":"随笔","slug":"随笔","permalink":"https://brianway.github.io/tags/随笔/"}]},{"title":"springmvc+mybatis学习笔记(汇总)","date":"2016-03-30T01:40:00.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-TOC/","text":"笔记分为两大部分：mybatis和springmvc mybatis springmvc 笔记内容主要是mybatis和springmvc的一些基本概念和使用方法，涉及概念介绍、环境搭建、编程细节、运行调试等方面。 这套笔记整体偏入门和应用，适合快速上手，对底层实现和机理并未做过多分析。我后续会研读spring源码，并把学习的收获写成博客分享出来，根据情况再开一个仓库或者贴博客链接。 github: springmvc-mybatis-learning git-clone:`git@github.com:brianway/springmvc-mybatis-learning.git` 如果觉得不错，请先在这个仓库上点个star吧，这也是对我的肯定和鼓励，谢谢了。不定时进行调整和补充，需要关注更新的请 Watch、Star、Fork 目录 mybatis mybatis学习笔记(1)-对原生jdbc程序中的问题总结.md mybatis学习笔记(2)-mybatis概述.md mybatis学习笔记(3)-入门程序一.md mybatis学习笔记(3)-入门程序二.md mybatis学习笔记(4)-开发dao方法.md mybatis学习笔记(5)-配置文件.md mybatis学习笔记(6)-输入映射.md mybatis学习笔记(7)-输出映射.md mybatis学习笔记(8)-动态sql.md mybatis学习笔记(9)-订单商品数据模型分析.md mybatis学习笔记(10)-一对一查询.md mybatis学习笔记(11)-一对多查询.md mybatis学习笔记(12)-多对多查询.md mybatis学习笔记(13)-延迟加载.md mybatis学习笔记(14)-查询缓存之一级缓存.md mybatis学习笔记(15)-查询缓存之二级缓存.md mybatis学习笔记(16)-mybatis整合ehcache.md mybatis学习笔记(17)-spring和mybatis整合.md mybatis学习笔记(18)-mybatis逆向工程.md springmvc springmvc学习笔记(1)-框架原理和入门配置.md springmvc学习笔记(2)-非注解的处理器映射器和适配器.md springmvc学习笔记(3)-注解的处理器映射器和适配器.md springmvc学习笔记(4)-前端控制器.md springmvc学习笔记(5)-入门程序小结.md springmvc学习笔记(6)-springmvc整合mybatis(IDEA中通过maven构建).md springmvc学习笔记(7)-springmvc整合mybatis之mapper.md springmvc学习笔记(8)-springmvc整合mybatis之service.md springmvc学习笔记(9)-springmvc整合mybatis之controller.md springmvc学习笔记(10)-springmvc注解开发之商品修改功能.md springmvc学习笔记(11)-springmvc注解开发之简单参数绑定.md springmvc学习笔记(12)-springmvc注解开发之包装类型参数绑定.md springmvc学习笔记(13)-springmvc注解开发之集合类型参数绑定.md springmvc学习笔记(14)-springmvc校验.md springmvc学习笔记(15)-数据回显.md springmvc学习笔记(16)-异常处理器.md springmvc学习笔记(17)-上传图片.md springmvc学习笔记(18)-json数据交互.md springmvc学习笔记(19)-RESTful支持.md springmvc学习笔记(20)-拦截器.md springmvc学习笔记(21)-springmvc整合mybatis遇到的问题及解决小结.md springmvc学习笔记(22)-springmvc开发小结.md sourcecode说明该文件下是涉及到的源码，其中mybatis部分都是直接新建的web工程，springmvc部分都是使用maven构建的。 我使用的IDE是intellij IDEA 15.0.2,以下每个子文件夹对应一个project。 mybatis:mybatis部分前16篇笔记用到的源码 mybatis-spring:mybatis部分笔记(17)对应的源码 mybatis-generator:逆向工程的源码 springmvcfirst:springmvc部分前两篇笔记对应的非注解方式配置的源码 springmvcsecond:springmvc部分前几篇笔记对应的注解方式配置的源码 learnssm-firstssm:核心代码，springmvc和mybatis整合部分的笔记几乎所有的源码 All Copyright Reserved","tags":[{"name":"总结","slug":"总结","permalink":"https://brianway.github.io/tags/总结/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(22)-springmvc开发小结","date":"2016-03-29T22:28:22.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-22-developing-summary/","text":"本文对springmvc系列博文进行小结 springmvc框架 springmvc_核心架构图 DispatcherServlet前端控制器：接收request，进行response HandlerMapping处理器映射器：根据url查找Handler。（可以通过xml配置方式，注解方式） HandlerAdapter处理器适配器：根据特定规则去执行Handler，编写Handler时需要按照HandlerAdapter的要求去编写。 Handler处理器（后端控制器）：需要程序员去编写，常用注解开发方式。 Handler处理器执行后结果是ModelAndView，具体开发时Handler返回方法值类型包括：ModelAndView、String（逻辑视图名）、void（通过在Handler形参中添加request和response，类似原始 servlet开发方式，注意：可以通过指定response响应的结果类型实现json数据输出） View Resolver视图解析器：根据逻辑视图名生成真正的视图（在springmvc中使用View对象表示） View视图：jsp页面，仅是数据展示，没有业务逻辑。 注解开发使用注解方式的处理器映射器和适配器1234&lt;!--注解映射器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/&gt;&lt;!--注解适配器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/&gt; 在实际开发，使用&lt;mvc:annotation-driven&gt;代替上边处理器映射器和适配器配置。 @controller注解必须要加，作用标识类是一个Handler处理器。 @requestMapping注解必须要加，作用： 1、对url和Handler的方法进行映射。 2、可以窄化请求映射，设置Handler的根路径，url就是根路径+子路径请求方式 3、可以限制http请求的方法 映射成功后，springmvc框架生成一个Handler对象，对象中只包括 一个映射成功的method。 注解开发中参数绑定将request请求过来的key/value的数据（理解一个串），通过转换（参数绑定的一部分），将key/value串转成形参，将转换后的结果传给形参（整个参数绑定过程）。 springmvc所支持参数绑定： 1、默认支持很多类型：HttpServletRequest、response、session、model/modelMap(将模型数据填充到request域) 2、支持简单数据类型，整型、字符串、日期..等 只要保证request请求的参数名和形参名称一致，自动绑定成功 如果request请求的参数名和形参名称不一致，可以使用@RequestParam（指定request请求的参数名），@RequestParam加在形参的前边。 3、支持pojo类型 只要保证request请求的参数名称和pojo中的属性名一致，自动将request请求的参数设置到pojo的属性中。 4、包装类型pojo参数绑定 第一种方法：在形参中添加HttpServletRequest request参数，通过request接收查询条件参数。 第二种方法：在形参中让包装类型的pojo接收查询条件参数。 5、集合类型参数绑定 数组绑定：方法形参使用数组接收页面请求的多个参数 list绑定：使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义list属性 map绑定：在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收 注意：形参中即有pojo类型又有简单类型，参数绑定互不影响。 自定义参数绑定 日期类型绑定自定义： 定义的Converter&lt;源类型，目标类型&gt;接口实现类，比如：Converter&lt;String,Date&gt;,表示：将请求的日期数据串转成java中的日期类型。 注意：要转换的目标类型一定和接收的pojo中的属性类型一致。 将定义的Converter实现类注入到处理器适配器中。 123456789101112&lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt;&lt;/mvc:annotation-driven&gt;&lt;!-- conversionService --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;!-- 转换器 --&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"cn.itcast.ssm.controller.converter.CustomDateConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; springmvc和struts2区别springmvc面向方法开发的（更接近service接口的开发方式），struts2面向类开发。 springmvc可以单例开发，struts2只能是多例开发。 校验服务端校验： 控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用） 业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。 持久层dao：一般是不校验的。 一般使用hibernate的校验框架，依赖hibernate-validator.jar,jboss-logging.jar,validation-api.jar这几个jar包 开发步骤 在springmvc.xml中添加校验器 校验器注入到处理器适配器中 在CustomValidationMessages.properties配置校验错误信息 在pojo中添加校验规则 在控制器中对参数注解@Validated来捕获和显示校验错误信息 分组校验 定义校验分组 在校验规则中添加分组 在controller方法使用指定分组的校验 数据回显数据回显有三种方法 1.springmvc默认对pojo数据进行回显。 pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写） 使用@ModelAttribute指定pojo回显到页面在request中的key 2.@ModelAttribute还可以将方法的返回值传到页面 3.使用最简单方法使用model，可以不用@ModelAttribute 异常处理系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理。 springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。 全局异常处理器处理思路： 解析出异常类型 如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示 如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（信息为“未知错误”） 抛出异常的位置 如果与业务功能相关的异常，建议在service中抛出异常。 与业务功能没有关系的异常，建议在controller中抛出。 上传图片开发步骤 在页面form中提交enctype=”multipart/form-data”的数据时，需要springmvc对multipart类型的数据进行解析。 在springmvc.xml中配置multipart类型解析器 加入上传图片的jar：commons-fileupload 创建图片虚拟目录存储图片 json数据交互两种json数据交互的形式： 请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。 请求key/value、输出json。此方法比较常用。 需要的依赖： jackson-databind jackson-mapper-asl 在注解适配器中加入messageConverters 123456789&lt;!--注解适配器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 注意：如果使用&lt;mvc:annotation-driven /&gt;则不用定义上边的内容。 在controller的返回值上加注解@ResponseBody来将java对象输出json，返回json格式数据 RESTful支持@RequestMapping(value=&quot;/ itemsView/{id}&quot;)：{×××}占位符，请求的URL可以是/viewItems/1或/viewItems/2，通过在方法中使用@PathVariable获取{×××}中的×××变量。@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。 如果@RequestMapping中表示为/itemsView/{id}，id和形参名称一致，@PathVariable不用指定名称。 同时需要配置前端控制器。若要访问静态资源，还需在springmvc.xml中添加静态资源解析方法,如&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt; 拦截器拦截器定义定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。可以从名称和参数看出各个接口的顺序和作用 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception 参数最少，只有三个 进入 Handler方法之前执行 用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception 多了一个modelAndView参数 进入Handler方法之后，返回modelAndView之前执行 应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception 多了一个Exception的类型的参数 执行Handler完成执行此方法 应用场景：统一异常处理，统一日志处理 拦截器的配置 针对HandlerMapping配置(一般不推荐) springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器 类似全局的拦截器 springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。 拦截器测试及其应用链式执行测试 两个拦截器都放行 preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行 拦截器1放行，拦截器2不放行 拦截器1放行，拦截器2 preHandle才会执行。 拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。 只要有一个拦截器不放行，postHandle不会执行。 两个拦截器都不放 拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。 拦截器1 preHandle不放行，拦截器2不执行。 应用 统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。 登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面）","tags":[{"name":"总结","slug":"总结","permalink":"https://brianway.github.io/tags/总结/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(21)-springmvc整合mybatis遇到的问题及解决小结","date":"2016-03-29T22:28:21.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-21-debug-summary/","text":"本文主要记录springmvc整合mybatis整合过程中遇到的各种问题和解决方法 遇到的问题在web.xml中&lt;listener-class&gt;标签报红参考： web.xml listener-class is not allowed here 解决：改用2.5的版本 答案节选： Servlet3.0是J2EE6.0规范的一部分，跟随J2EE6.0一起发布，并且Tomcat7.0已经完全支持Servlet3.0 ；平时，我们一般使用tomcat6.0，是不能够使用servelt3.0的，tomcat6.0还不能支持那些规范；至于说，为毛线不能使用lintener-class，是因为在web-app_3_0.xsd结构定义文件中，根本就不提倡这些配置，因为Servlet3.0已经支持注解形式； 当时解决了报红的问题。但后来我其他部分调试好了后，改回3.0也没报错。 BeanCreationException123456789101112org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;dataSource&apos; defined in file [D:\\intellij\\workspace\\learnssm-firstssm\\target\\learnssm-firstssm-1.0-SNAPSHOT\\WEB-INF\\classes\\spring\\applicationContext-dao.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0&apos;: Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:478) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ....省略Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor#0&apos;: Initialization of bean failed; nested exception is java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ....省略 是少依赖的问题，输入mvn dependency:tree打依赖树： 123456789101112131415161718192021222324252627282930313233343536D:\\intellij\\workspace\\learnssm-firstssm&gt;mvn dependency:tree[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building learnssm-firstssm 1.0-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO][INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ learnssm-firstssm ---[INFO] com.iot.learnssm:learnssm-firstssm:war:1.0-SNAPSHOT[INFO] +- org.springframework:spring-core:jar:4.2.4.RELEASE:compile[INFO] | \\- commons-logging:commons-logging:jar:1.2:compile[INFO] +- org.springframework:spring-webmvc:jar:4.2.4.RELEASE:compile[INFO] | +- org.springframework:spring-beans:jar:4.2.4.RELEASE:compile[INFO] | +- org.springframework:spring-context:jar:4.2.4.RELEASE:compile[INFO] | | \\- org.springframework:spring-aop:jar:4.2.4.RELEASE:compile[INFO] | | \\- aopalliance:aopalliance:jar:1.0:compile[INFO] | +- org.springframework:spring-expression:jar:4.2.4.RELEASE:compile[INFO] | \\- org.springframework:spring-web:jar:4.2.4.RELEASE:compile[INFO] +- org.springframework:spring-jdbc:jar:4.2.4.RELEASE:compile[INFO] | \\- org.springframework:spring-tx:jar:4.2.4.RELEASE:compile[INFO] +- mysql:mysql-connector-java:jar:5.1.38:compile[INFO] +- org.mybatis:mybatis:jar:3.3.1:compile[INFO] +- org.mybatis:mybatis-spring:jar:1.2.4:compile[INFO] +- log4j:log4j:jar:1.2.17:compile[INFO] +- org.slf4j:slf4j-api:jar:1.7.18:compile[INFO] +- commons-dbcp:commons-dbcp:jar:1.4:compile[INFO] | \\- commons-pool:commons-pool:jar:1.5.4:compile[INFO] +- javax.servlet:jstl:jar:1.2:compile[INFO] \\- taglibs:standard:jar:1.1.2:compile[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 7.956 s[INFO] Finished at: 2016-03-03T20:06:00+08:00[INFO] Final Memory: 11M/126M[INFO] ------------------------------------------------------------------------ 少了spring-aspects,spring-core等依赖，加上 1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; spring版本统一设置 1234&lt;properties&gt; &lt;!-- jar 版本设置 --&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;&lt;/properties&gt; mybatis绑定错误错误：org.apache.ibatis.binding.BindingException: Invalid bound statement 使用了下面的方法检查，都没有解决。排除了包名不同等低级错误。 mybatis绑定错误- softwarehe的专栏- 博客频道- CSDN.NET Mybatis绑定错误的原因 又找到了oschina一个人的帖子，有个回答感觉靠谱 java spring4+mybatis整合报错BindingException Invalid bound statement 是的，是没有在pom.xml配置build包含 xml，导致target目录下没有userMapper.xml -by 唐小明生 我一看自己的target目录,发现还真是少mapper.xml文件 target少mapper的xml文件 我想到了两种解决方案： 方案一：自定义一个插件，绑定某个生命周期，比如compile，然后插件目标的功能是将源码包下的xml文件copy到相应的输出目录。(现有插件是否有已有这个功能，通过简单的配置就能完成？我还不清楚) 方案二：在maven工程的src/main/resource目录下建和mapper接口类相应的包，将每个mapper.xml存在这里 这里我插件玩的不熟，所以没办法，只能手动在resources目录下建包，把每个mapper.xml手动粘贴进去 解决后如图： mapper.xml存在resources下面 请求参数乱码问题 springmcv_post请求参数乱码 在web.xml添加post乱码filter 12345678910111213&lt;!-- post乱码过虑器 --&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 以上可以解决post请求乱码问题。解决后调试如图 springmcv_post请求参数乱码解决 对于get请求中文参数出现乱码解决方法有两个： 修改tomcat配置文件添加编码与工程编码一致，如下： &lt;Connector URIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 另外一种方法对参数进行重新编码： 12String userName = newString(request.getParamter(\"userName\").getBytes(\"ISO8859-1\"),\"utf-8\") ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 请求参数类型转换问题编写对应的转换类才行,具体参考前面参数绑定的博文《 springmvc学习笔记(11)-springmvc注解开发之简单参数绑定》 maven平台编码问题[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent! 参考: CSDN博客 Maven官网在FAQ 解决: 在pom.xml文件的设置编码即可 123&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; json格式数据问题 1.请求是json格式 debug窗里报下面的错误： org.springframework.web.HttpMediaTypeNotSupportedException: Content type &#39;application/json;charset=UTF-8&#39; not supported 浏览器报下面的错误： HTTP Status 415 -anddescription The server refused this request because the request entity is in a format not supported by the requested resource for the requested method. 2.请求是key/value格式 debug窗里报下面的错误： java.lang.IllegalArgumentException: No converter found for return value of type: class com.iot.learnssm.firstssm.po.ItemsCustom 参考stackoverflow的这个链接: How to return JSON data from spring Controller using @ResponseBody 多加一个依赖jackson-databind（之前只加了jackson-mapper-asl的依赖， 间接依赖jackson-core-asl，但还不够。 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt;&lt;/dependency&gt; 还没弄懂但不影响运行的问题加载spring容器报红 web.xml节选 123456 &lt;!-- 加载spring容器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;!-- &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;--&gt; &lt;/context-param&gt; 加载spring容器报红 /classes/spring/applicationContext-*.xml这部分字会报红，但运行起来没问题。我使用下面的那句&lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;不报红.原因不清楚。 这里两种方式都能跑通，但是引用的路径不同:一个是引用的的输出的target目录的classes下的，一个是引用输出的target/learnssm-firstssm-1.0-SNAPSHOT目录(相当于部署的WEBROOT或者叫做webapp)，所以我觉得还是用WEB-INF下面那个更好 容器加载文件的选用 参数绑定配置问题在自定义参数绑定时，spring.xml的配置如下： 12345678910&lt;!-- 自定义参数绑定 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;!-- 转换器 --&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;!-- 日期类型转换 --&gt; &lt;bean class=\"com.iot.learnssm.firstssm.controller.converter.CustomDateConverter\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 其中&lt;list&gt;标签会报红，但不影响运行。去掉&lt;list&gt;标签，也可以运行成功。原因我还不知道，以后阅读源码会研究下这个问题。 转换器list报红 maven依赖分析问题输入mvn dependency:analyze进行依赖分析 1234567891011121314151617181920212223242526[INFO][INFO] --- maven-dependency-plugin:2.8:analyze (default-cli) @ learnssm-firstssm ---[WARNING] Used undeclared dependencies found:[WARNING] org.springframework:spring-context:jar:4.2.4.RELEASE:compile[WARNING] org.springframework:spring-web:jar:4.2.4.RELEASE:compile[WARNING] org.springframework:spring-beans:jar:4.2.4.RELEASE:compile[WARNING] Unused declared dependencies found:[WARNING] org.springframework:spring-orm:jar:4.2.4.RELEASE:compile[WARNING] org.springframework:spring-aspects:jar:4.2.4.RELEASE:compile[WARNING] org.springframework:spring-test:jar:4.2.4.RELEASE:compile[WARNING] org.springframework:spring-jdbc:jar:4.2.4.RELEASE:compile[WARNING] mysql:mysql-connector-java:jar:5.1.38:compile[WARNING] org.mybatis:mybatis-spring:jar:1.2.4:compile[WARNING] log4j:log4j:jar:1.2.17:compile[WARNING] org.slf4j:slf4j-api:jar:1.7.18:compile[WARNING] commons-dbcp:commons-dbcp:jar:1.4:compile[WARNING] javax.servlet:jstl:jar:1.2:compile[WARNING] taglibs:standard:jar:1.1.2:compile[WARNING] org.hibernate:hibernate-validator:jar:5.2.4.Final:compile[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 3.294 s[INFO] Finished at: 2016-03-06T16:35:23+08:00[INFO] Final Memory: 16M/164M[INFO] ------------------------------------------------------------------------ 可以看到里面有: Used undeclared dependencies found: Unused declared dependencies found: 当时为了解决缺包的问题，看到相关的spring-xxx包就加进去了，具体相互之间的依赖关系也没搞清楚，等我以后阅读spring源码再慢慢改好了。反正多引比少引好点，起码不会报错，顶多工程冗余点。 至于说使用了未声明的包就不知道为啥了，比如 123[WARNING] org.springframework:spring-context:jar:4.2.4.RELEASE:compile[WARNING] org.springframework:spring-web:jar:4.2.4.RELEASE:compile[WARNING] org.springframework:spring-beans:jar:4.2.4.RELEASE:compile 都被org.springframework:spring-webmvc:jar:4.2.4.RELEASE:compile依赖，这点可以从依赖树看到 123456789[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ learnssm-firstssm ---[INFO] com.iot.learnssm:learnssm-firstssm:war:1.0-SNAPSHOT[INFO] +- org.springframework:spring-webmvc:jar:4.2.4.RELEASE:compile[INFO] | +- org.springframework:spring-beans:jar:4.2.4.RELEASE:compile[INFO] | +- org.springframework:spring-context:jar:4.2.4.RELEASE:compile[INFO] | | \\- org.springframework:spring-aop:jar:4.2.4.RELEASE:compile[INFO] | | \\- aopalliance:aopalliance:jar:1.0:compile[INFO] | +- org.springframework:spring-expression:jar:4.2.4.RELEASE:compile[INFO] | \\- org.springframework:spring-web:jar:4.2.4.RELEASE:compile 总之，上面未解决的问题，我会留意，如果有大神指导原因，请不吝赐教。","tags":[{"name":"总结","slug":"总结","permalink":"https://brianway.github.io/tags/总结/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"},{"name":"debug","slug":"debug","permalink":"https://brianway.github.io/tags/debug/"}]},{"title":"springmvc学习笔记(20)-拦截器","date":"2016-03-29T22:28:20.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-20-interceptor/","text":"本文主要介绍springmvc中的拦截器，包括拦截器定义和的配置，然后演示了一个链式拦截的测试示例，最后通过一个登录认证的例子展示了拦截器的应用 拦截定义定义拦截器，实现HandlerInterceptor接口。接口中提供三个方法。 1234567891011121314151617181920212223public class HandlerInterceptor1 implements HandlerInterceptor&#123; //进入 Handler方法之前执行 //用于身份认证、身份授权 //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //return false表示拦截，不向下执行 //return true表示放行 return false; &#125; //进入Handler方法之后，返回modelAndView之前执行 //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; //执行Handler完成执行此方法 //应用场景：统一异常处理，统一日志处理 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 可以从名称和参数看出各个接口的顺序和作用: public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception 参数最少，只有三个 进入 Handler方法之前执行 用于身份认证、身份授权。比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception 多了一个modelAndView参数 进入Handler方法之后，返回modelAndView之前执行 应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception 多了一个Exception的类型的参数 执行Handler完成执行此方法 应用场景：统一异常处理，统一日志处理 拦截器配置针对HandlerMapping配置springmvc拦截器针对HandlerMapping进行拦截设置，如果在某个HandlerMapping中配置拦截，经过该HandlerMapping映射成功的handler最终使用该拦截器。 1234567891011&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"&gt; &lt;property name=\"interceptors\"&gt; &lt;list&gt; &lt;ref bean=\"handlerInterceptor1\"/&gt; &lt;ref bean=\"handlerInterceptor2\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id=\"handlerInterceptor1\" class=\"springmvc.intercapter.HandlerInterceptor1\"/&gt; &lt;bean id=\"handlerInterceptor2\" class=\"springmvc.intercapter.HandlerInterceptor2\"/&gt; 一般不推荐使用。 类似全局的拦截器springmvc配置类似全局的拦截器，springmvc框架将配置的类似全局的拦截器注入到每个HandlerMapping中。 12345678910111213 &lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!--多个拦截器,顺序执行 --&gt; &lt;mvc:interceptor&gt; &lt;!-- /**表示所有url包括子url路径 --&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.iot.learnssm.firstssm.interceptor.HandlerInterceptor1\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.iot.learnssm.firstssm.interceptor.HandlerInterceptor2\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 拦截测试测试多个拦截器各个方法执行时机 访问/items/queryItems.action 1.两个拦截器都放行 123456789101112131415161718192021DEBUG [http-apr-8080-exec-1] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-1] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-1] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-1] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-1] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleHandlerInterceptor2...preHandleDEBUG [http-apr-8080-exec-1] - Fetching JDBC Connection from DataSourceDEBUG [http-apr-8080-exec-1] - Registering transaction synchronization for JDBC ConnectionDEBUG [http-apr-8080-exec-1] - Returning JDBC Connection to DataSourceHandlerInterceptor2...postHandleHandlerInterceptor1...postHandleDEBUG [http-apr-8080-exec-1] - Rendering view [org.springframework.web.servlet.view.JstlView: name &apos;items/itemsList&apos;; URL [/WEB-INF/jsp/items/itemsList.jsp]] in DispatcherServlet with name &apos;springmvc&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemtypes&apos; of type [java.util.HashMap] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemsQueryVo&apos; of type [com.iot.learnssm.firstssm.po.ItemsQueryVo] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;org.springframework.validation.BindingResult.itemsQueryVo&apos; of type [org.springframework.validation.BeanPropertyBindingResult] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Added model object &apos;itemsList&apos; of type [java.util.ArrayList] to request in view with name &apos;items/itemsList&apos;DEBUG [http-apr-8080-exec-1] - Forwarding to resource [/WEB-INF/jsp/items/itemsList.jsp] in InternalResourceView &apos;items/itemsList&apos;HandlerInterceptor2...afterCompletionHandlerInterceptor1...afterCompletionDEBUG [http-apr-8080-exec-1] - Successfully completed request 总结：preHandle方法按顺序执行，postHandle和afterCompletion按拦截器配置的逆向顺序执行。 2.拦截器1放行，拦截器2不放行 123456789DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleHandlerInterceptor2...preHandleHandlerInterceptor1...afterCompletionDEBUG [http-apr-8080-exec-8] - Successfully completed request 总结： 拦截器1放行，拦截器2 preHandle才会执行。 拦截器2 preHandle不放行，拦截器2 postHandle和afterCompletion不会执行。 只要有一个拦截器不放行，postHandle不会执行。 3.两个拦截器都不放 1234567DEBUG [http-apr-8080-exec-9] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-9] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-9] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-9] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-9] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleDEBUG [http-apr-8080-exec-9] - Successfully completed request 总结： 拦截器1 preHandle不放行，postHandle和afterCompletion不会执行。 拦截器1 preHandle不放行，拦截器2不执行。 4.拦截器1不放行，拦截器2放行 1234567DEBUG [http-apr-8080-exec-8] - DispatcherServlet with name &apos;springmvc&apos; processing GET request for [/ssm1/items/queryItems.action]DEBUG [http-apr-8080-exec-8] - Looking up handler method for path /items/queryItems.actionDEBUG [http-apr-8080-exec-8] - Returning handler method [public org.springframework.web.servlet.ModelAndView com.iot.learnssm.firstssm.controller.ItemsController.queryItems(javax.servlet.http.HttpServletRequest,com.iot.learnssm.firstssm.po.ItemsQueryVo) throws java.lang.Exception]DEBUG [http-apr-8080-exec-8] - Returning cached instance of singleton bean &apos;itemsController&apos;DEBUG [http-apr-8080-exec-8] - Last-Modified value for [/ssm1/items/queryItems.action] is: -1HandlerInterceptor1...preHandleDEBUG [http-apr-8080-exec-8] - Successfully completed request 和两个拦截器都不行的结果一致，因为拦截器1先执行，没放行 小结 根据测试结果，对拦截器应用。 比如：统一日志处理拦截器，需要该拦截器preHandle一定要放行，且将它放在拦截器链接中第一个位置。 比如：登陆认证拦截器，放在拦截器链接中第一个位置。权限校验拦截器，放在登陆认证拦截器之后。（因为登陆通过后才校验权限，当然登录认证拦截器要放在统一日志处理拦截器后面） 拦截器应用(实现登陆认证)需求 1.用户请求url 2.拦截器进行拦截校验 如果请求的url是公开地址（无需登陆即可访问的url），让放行 如果用户session 不存在跳转到登陆页面 如果用户session存在放行，继续操作。 登陆controller方法123456789101112131415161718192021222324252627@Controllerpublic class LoginController &#123; // 登陆 @RequestMapping(\"/login\") public String login(HttpSession session, String username, String password) throws Exception &#123; // 调用service进行用户身份验证 // ... // 在session中保存用户身份信息 session.setAttribute(\"username\", username); // 重定向到商品列表页面 return \"redirect:/items/queryItems.action\"; &#125; // 退出 @RequestMapping(\"/logout\") public String logout(HttpSession session) throws Exception &#123; // 清除session session.invalidate(); // 重定向到商品列表页面 return \"redirect:/items/queryItems.action\"; &#125;&#125; 登陆认证拦截实现 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Created by brian on 2016/3/8. * 登陆认证拦截器 */public class LoginInterceptor implements HandlerInterceptor &#123; //进入 Handler方法之前执行 //用于身份认证、身份授权 //比如身份认证，如果认证通过表示当前用户没有登陆，需要此方法拦截不再向下执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取请求的url String url = request.getRequestURI(); //判断url是否是公开 地址（实际使用时将公开 地址配置配置文件中） //这里公开地址是登陆提交的地址 if(url.indexOf(\"login.action\")&gt;=0)&#123; //如果进行登陆提交，放行 return true; &#125; //判断session HttpSession session = request.getSession(); //从session中取出用户身份信息 String username = (String) session.getAttribute(\"username\"); if(username != null)&#123; //身份存在，放行 return true; &#125; //执行这里表示用户身份需要认证，跳转登陆页面 request.getRequestDispatcher(\"/WEB-INF/jsp/login.jsp\").forward(request, response); //return false表示拦截，不向下执行 //return true表示放行 return false; &#125; //进入Handler方法之后，返回modelAndView之前执行 //应用场景从modelAndView出发：将公用的模型数据(比如菜单导航)在这里传到视图，也可以在这里统一指定视图 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"LoginInterceptor...postHandle\"); &#125; //执行Handler完成执行此方法 //应用场景：统一异常处理，统一日志处理 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"LoginInterceptor...afterCompletion\"); &#125;&#125; 拦截器配置 12345678910&lt;!--拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;!--多个拦截器,顺序执行 --&gt; &lt;!-- 登陆认证拦截器 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**\"/&gt; &lt;bean class=\"com.iot.learnssm.firstssm.interceptor.LoginInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; ...省略","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(19)-RESTful支持","date":"2016-03-29T22:28:19.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-19-RESTful-support/","text":"本文介绍RESTful的概念，并通过一个小例子展示如何编写RESTful风格的controller和配置前端控制器，最后展示静态资源的解析 概念首先附上两篇博客链接 理解RESTful架构 - 阮一峰的网络日志 RESTful API 设计指南- 阮一峰的网络日志 RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 RESTful（即Representational State Transfer的缩写）其实是一个开发理念，是对http的很好的诠释。 1.对url进行规范，写RESTful格式的url 非REST的url：http://...../queryItems.action?id=001&amp;type=T01 REST的url风格：http://..../items/001 特点：url简洁，将参数通过url传到服务端 2.http的方法规范 不管是删除、添加、更新，等等。使用url是一致的，如果进行删除，需要设置http的方法为delete，其他同理。 后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。 3.对http的contentType规范 请求时指定contentType，要json数据，设置成json格式的type。 REST的例子查询商品信息，返回json数据。 controller定义方法，进行url映射使用REST风格的url，将查询商品信息的id传入controller . 输出json使用@ResponseBody将java对象输出json。 12345678910111213//查询商品信息，输出json//itemsView/&#123;id&#125;里边的&#123;id&#125;表示占位符，通过@PathVariable获取占位符中的参数，//@PathVariable中名称要和占位符一致，形参名无需和其一致//如果占位符中的名称和形参名一致，在@PathVariable可以不指定名称@RequestMapping(\"/itemsView/&#123;id&#125;\")public @ResponseBody ItemsCustom itemsView(@PathVariable(\"id\") Integer items_id)throws Exception&#123; //调用service查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(items_id); return itemsCustom;&#125; @RequestMapping(value=&quot;/ itemsView/{id}&quot;)：{×××}占位符，请求的URL可以是/viewItems/1或/viewItems/2，通过在方法中使用@PathVariable获取{×××}中的×××变量。@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。 如果@RequestMapping中表示为/itemsView/{id}，id和形参名称一致，@PathVariable不用指定名称。 REST方法的前端控制器配置123456789101112131415&lt;!-- springmvc前端控制器，rest配置 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc_rest&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 访问结果如图： RESTful格式访问 对静态资源的解析配置前端控制器的url-parttern中指定/，对静态资源的解析会出现问题，报404错误。 在springmvc.xml中添加静态资源解析方法。 1234&lt;!-- 静态资源解析 包括 ：js、css、img、.. --&gt;&lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; 这时访问http://localhost:8080/ssm1/js/jquery-1.4.4.min.js，可以在浏览器中看到js的内容","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"},{"name":"RESTful","slug":"RESTful","permalink":"https://brianway.github.io/tags/RESTful/"}]},{"title":"springmvc学习笔记(18)-json数据交互","date":"2016-03-29T22:28:18.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-18-json-interaction/","text":"本文主要介绍如何在springmvc中进行json数据的交互，先是环境准备和配置，然后分别展示了“输入json串，输出是json串”和“输入key/value，输出是json串”两种情况下的交互 springmvc进行json交互json数据格式在接口调用中、html页面中较常用，json格式比较简单，解析还比较方便。 比如：webservice接口，传输json数据. json交互 请求json、输出json，要求请求的是json串，所以在前端页面中需要将请求的内容转成json，不太方便。 请求key/value、输出json。此方法比较常用。 环境准备添加json转换的依赖最开始我少了jackson-databind依赖，程序各种报错。 12345678910111213&lt;!-- json 转换--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt; 查看依赖树 12345[INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.7.2:compile[INFO] | +- com.fasterxml.jackson.core:jackson-annotations:jar:2.7.0:compile[INFO] | \\- com.fasterxml.jackson.core:jackson-core:jar:2.7.2:compile[INFO] \\- org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:compile[INFO] \\- org.codehaus.jackson:jackson-core-asl:jar:1.9.13:compile 配置json转换器在注解适配器中加入messageConverters 123456789&lt;!--注解适配器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter\"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 注意：如果使用&lt;mvc:annotation-driven /&gt;则不用定义上边的内容。 json交互测试显示两个按钮分别测试 jsp页面 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: brian Date: 2016/3/7 Time: 20:49 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;json交互测试&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath &#125;/js/jquery-1.4.4.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; //请求json，输出是json function requestJson()&#123; 省略 &#125; //请求key/value，输出是json function responseJson()&#123; 省略 &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" onclick=\"requestJson()\" value=\"请求json，输出是json\"/&gt;&lt;input type=\"button\" onclick=\"responseJson()\" value=\"请求key/value，输出是json\"/&gt;&lt;/body&gt; controller 1234@Controllerpublic class JsonTest &#123; 省略&#125; 测试结果 输入json串，输出是json串使用jquery的ajax提交json串，对输出的json结果进行解析。 jsp页面 12345678910111213141516//请求json，输出是jsonfunction requestJson()&#123; $.ajax(&#123; type:'post', url:'$&#123;pageContext.request.contextPath &#125;/requestJson.action', contentType:'application/json;charset=utf-8', //数据格式是json串，商品信息 data:'&#123;\"name\":\"手机\",\"price\":999&#125;', success:function(data)&#123;//返回json结果 alert(data); &#125; &#125;);&#125; controller 123456789 //请求json串(商品信息)，输出json(商品信息)//@RequestBody将请求的商品信息的json串转成itemsCustom对象//@ResponseBody将itemsCustom转成json输出@RequestMapping(\"/requestJson\")public @ResponseBody ItemsCustom requestJson(@RequestBody ItemsCustom itemsCustom)&#123; //@ResponseBody将itemsCustom转成json输出 return itemsCustom;&#125; 测试结果 请求json，返回json 可以看到，request和response的HTTP头的Content-Type都是application/json;charset=utf-8 请求json，返回json,response的body 输入key/value，输出是json串使用jquery的ajax提交key/value串，对输出的json结果进行解析 jsp页面 1234567891011121314151617//请求key/value，输出是jsonfunction responseJson()&#123; $.ajax(&#123; type:'post', url:'$&#123;pageContext.request.contextPath &#125;/responseJson.action', //请求是key/value这里不需要指定contentType，因为默认就 是key/value类型 //contentType:'application/json;charset=utf-8', //数据格式是json串，商品信息 data:'name=手机&amp;price=999', success:function(data)&#123;//返回json结果 alert(data.name); &#125; &#125;);&#125; controller 1234567 //请求key/value，输出json@RequestMapping(\"/responseJson\")public @ResponseBody ItemsCustom responseJson(ItemsCustom itemsCustom)&#123; //@ResponseBody将itemsCustom转成json输出 return itemsCustom;&#125; 测试结果 请求key/value,返回json 可以看到，key/value键值对的默认Content-Type是application/x-www-form-urlencoded,同时，我们收到了响应“手机”","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"},{"name":"JSON","slug":"JSON","permalink":"https://brianway.github.io/tags/JSON/"}]},{"title":"springmvc学习笔记(17)-上传图片","date":"2016-03-29T22:28:17.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-17-picture-upload/","text":"本文展示如何在springmvc中上传图片 springmvc中对多部件类型解析在修改商品页面，添加上传商品图片功能。 在页面form中提交enctype=&quot;multipart/form-data&quot;的数据时，需要springmvc对multipart类型的数据进行解析。 在springmvc.xml中配置multipart类型解析器。 12345678&lt;!-- 文件上传 --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!-- 设置上传文件的最大尺寸为5MB --&gt; &lt;property name=\"maxUploadSize\"&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 加入上传图片的jar添加依赖 123456&lt;!-- 文件上传 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 依赖树 12[INFO] \\- commons-fileupload:commons-fileupload:jar:1.3.1:compile[INFO] \\- commons-io:commons-io:jar:2.2:compile 可以看到，其实还间接依赖了commons-io:commons-io:jar 创建图片虚拟目录存储图片参考我之前的博文 在intellij IDEA中为web应用创建图片虚拟目录(详细截图) 也可以直接修改tomcat的配置,在conf/server.xml文件，添加虚拟目录. 注意：在图片虚拟目录中，一定将图片目录分级创建（提高i/o性能），一般我们采用按日期(年、月、日)进行分级创建。 上传图片代码 页面 12345678910&lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt; &lt;c:if test=\"$&#123;items.pic !=null&#125;\"&gt; &lt;img src=\"/pic/$&#123;items.pic&#125;\" width=100 height=100/&gt; &lt;br/&gt; &lt;/c:if&gt; &lt;input type=\"file\" name=\"items_pic\"/&gt; &lt;/td&gt;&lt;/tr&gt; controller方法 修改：商品修改controller方法： 12345678910@RequestMapping(\"/editItemsSubmit\") public String editItemsSubmit( Model model, HttpServletRequest request, Integer id, @ModelAttribute(\"items\") @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom, BindingResult bindingResult, MultipartFile items_pic )throws Exception &#123; 123456789101112131415161718192021 //原始名称String originalFilename = items_pic.getOriginalFilename();//上传图片if(items_pic!=null &amp;&amp; originalFilename!=null &amp;&amp; originalFilename.length()&gt;0)&#123; //存储图片的物理路径 String pic_path = \"D:\\\\tmp\\\\\"; //新的图片名称 String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf(\".\")); //新图片 File newFile = new File(pic_path+newFileName); //将内存中的数据写入磁盘 items_pic.transferTo(newFile); //将新图片名称写到itemsCustom中 itemsCustom.setPic(newFileName);&#125;","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(16)-异常处理器","date":"2016-03-29T22:28:16.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-16-exception/","text":"本文主要介绍springmvc中异常处理的思路，并展示如何自定义异常处理类以及全局异常处理器的配置 异常处理思路系统中异常包括两类： 预期异常 运行时异常RuntimeException 前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试通过手段减少运行时异常的发生。 系统的dao、service、controller出现都通过throws Exception向上抛出，最后由springmvc前端控制器交由异常处理器进行异常处理，如下图： springmvc异常处理 springmvc提供全局异常处理器（一个系统只有一个异常处理器）进行统一异常处理。 自定义异常类对不同的异常类型定义异常类，继承Exception。 123456789101112131415161718192021222324package com.iot.learnssm.firstssm.exception;/** * Created by brian on 2016/3/7. * * 系统 自定义异常类，针对预期的异常，需要在程序中抛出此类的异常 */public class CustomException extends Exception&#123; //异常信息 public String message; public CustomException(String message)&#123; super(message); this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 全局异常处理器思路： 系统遇到异常，在程序中手动抛出，dao抛给service、service给controller、controller抛给前端控制器，前端控制器调用全局异常处理器。 全局异常处理器处理思路： 解析出异常类型 如果该异常类型是系统自定义的异常，直接取出异常信息，在错误页面展示 如果该异常类型不是系统自定义的异常，构造一个自定义的异常类型（信息为“未知错误”） springmvc提供一个HandlerExceptionResolver接口 1234567891011121314151617181920212223242526272829303132333435 public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //handler就是处理器适配器要执行Handler对象（只有method） //解析出异常类型 //如果该 异常类型是系统 自定义的异常，直接取出异常信息，在错误页面展示 //String message = null; //if(ex instanceof CustomException)&#123; //message = ((CustomException)ex).getMessage(); //&#125;else&#123; ////如果该 异常类型不是系统 自定义的异常，构造一个自定义的异常类型（信息为“未知错误”） //message=\"未知错误\"; //&#125; //上边代码变为 CustomException customException; if(ex instanceof CustomException)&#123; customException = (CustomException)ex; &#125;else&#123; customException = new CustomException(\"未知错误\"); &#125; //错误信息 String message = customException.getMessage(); ModelAndView modelAndView = new ModelAndView(); //将错误信息传到页面 modelAndView.addObject(\"message\", message); //指向错误页面 modelAndView.setViewName(\"error\"); return modelAndView; &#125;&#125; 错误页面12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: Brian Date: 2016/3/4 Time: 10:51 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误提示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 在springmvc.xml配置全局异常处理器1234&lt;!-- 全局异常处理器只要实现HandlerExceptionResolver接口就是全局异常处理器--&gt;&lt;bean class=\"com.iot.learnssm.firstssm.exception.CustomExceptionResolver\"&gt;&lt;/bean&gt; 全局异常处理器只有一个，配置多个也没用。 异常测试在controller、service、dao中任意一处需要手动抛出异常。如果是程序中手动抛出的异常，在错误页面中显示自定义的异常信息，如果不是手动抛出异常说明是一个运行时异常，在错误页面只显示“未知错误”。 在商品修改的controller方法中抛出异常 . 12345678910111213141516public String editItems(Model model,@RequestParam(value=\"id\",required=true) Integer items_id)throws Exception &#123; //调用service根据商品id查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(items_id); //判断商品是否为空，根据id没有查询到商品，抛出异常，提示用户商品信息不存在 if(itemsCustom == null)&#123; throw new CustomException(\"修改的商品信息不存在!\"); &#125; //通过形参中的model将model数据传到页面 //相当于modelAndView.addObject方法 model.addAttribute(\"items\", itemsCustom); return \"items/editItems\";&#125; 在service接口中抛出异常： 1234567891011121314151617public ItemsCustom findItemsById(Integer id) throws Exception &#123; Items items = itemsMapper.selectByPrimaryKey(id); if(items==null)&#123; throw new CustomException(\"修改的商品信息不存在!\"); &#125; //中间对商品信息进行业务处理 //.... //返回ItemsCustom ItemsCustom itemsCustom = null; //将items的属性值拷贝到itemsCustom if(items!=null)&#123; itemsCustom = new ItemsCustom(); BeanUtils.copyProperties(items, itemsCustom); &#125; return itemsCustom;&#125; 如果与业务功能相关的异常，建议在service中抛出异常。 与业务功能没有关系的异常，建议在controller中抛出。 上边的功能，建议在service中抛出异常。","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(15)-数据回显","date":"2016-03-29T22:28:15.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-15-data-echo/","text":"本文介绍springmvc中数据回显的几种实现方法 数据回显：提交后，如果出现错误，将刚才提交的数据回显到刚才的提交页面。 pojo数据回显方法1.springmvc默认对pojo数据进行回显。 pojo数据传入controller方法后，springmvc自动将pojo数据放到request域，key等于pojo类型（首字母小写） 使用@ModelAttribute指定pojo回显到页面在request中的key 2.@ModelAttribute还可以将方法的返回值传到页面 在商品查询列表页面，通过商品类型查询商品信息。在controller中定义商品类型查询方法，最终将商品类型传到页面。 1234567891011 // 商品分类//itemtypes表示最终将方法返回值放在request中的key@ModelAttribute(\"itemtypes\")public Map&lt;String, String&gt; getItemTypes() &#123; Map&lt;String, String&gt; itemTypes = new HashMap&lt;String, String&gt;(); itemTypes.put(\"101\", \"数码\"); itemTypes.put(\"102\", \"母婴\"); return itemTypes;&#125; 页面上可以得到itemTypes数据。 123456789&lt;td&gt; 商品名称：&lt;input name=\"itemsCustom.name\" /&gt; 商品类型： &lt;select name=\"itemtype\"&gt; &lt;c:forEach items=\"$&#123;itemtypes&#125;\" var=\"itemtype\"&gt; &lt;option value=\"$&#123;itemtype.key &#125;\"&gt;$&#123;itemtype.value &#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt;&lt;/td&gt; 3.使用最简单方法使用model，可以不用@ModelAttribute 12//可以直接使用model将提交pojo回显到页面//model.addAttribute(\"items\", itemsCustom); 简单类型数据回显使用最简单方法使用model model.addAttribute(&quot;id&quot;, id);","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(14)-springmvc校验","date":"2016-03-29T22:28:14.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-14-validation/","text":"本文主要介绍springmvc校验，包括环境准备，校验器配置，pojo张添加校验规则，捕获和显示检验错误信息以及分组校验简单示例。 校验理解项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。 服务端校验： 控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用） 业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。 持久层dao：一般是不校验的。 springmvc校验需求springmvc使用hibernate的校验框架validation(和hibernate没有任何关系)。 校验思路： 页面提交请求的参数，请求到controller方法中，使用validation进行校验。如果校验出错，将错误信息展示到页面。 具体需求： 商品修改，添加校验（校验商品名称长度，生产日期的非空校验），如果校验出错，在商品修改页面显示错误信息。 环境准备我们需要三个jar包： hibernate-validator.jar jboss-logging.jar validation-api.jar 这里我们添加maven依赖 123456&lt;!-- hibernate 校验 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.2.4.Final&lt;/version&gt;&lt;/dependency&gt; 查看maven依赖树 1234[INFO] \\- org.hibernate:hibernate-validator:jar:5.2.4.Final:compile[INFO] +- javax.validation:validation-api:jar:1.1.0.Final:compile[INFO] +- org.jboss.logging:jboss-logging:jar:3.2.1.Final:compile[INFO] \\- com.fasterxml:classmate:jar:1.1.0:compile 可以看到，另外两个jar包被hibernate-validator依赖，所以不用再额外添加了。 配置校验器 在springmvc.xml中添加 12345678910111213141516171819202122&lt;!-- 校验器 --&gt;&lt;bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"&gt; &lt;!-- hibernate校验器--&gt; &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\" /&gt; &lt;!-- 指定校验使用的资源文件，在文件中配置校验错误信息，如果不指定则默认使用classpath下的ValidationMessages.properties --&gt; &lt;property name=\"validationMessageSource\" ref=\"messageSource\" /&gt;&lt;/bean&gt;&lt;!-- 校验错误信息配置文件 --&gt;&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"&gt; &lt;!-- 资源文件名--&gt; &lt;property name=\"basenames\"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomValidationMessages&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name=\"fileEncodings\" value=\"utf-8\" /&gt; &lt;!-- 对资源文件内容缓存时间，单位秒 --&gt; &lt;property name=\"cacheSeconds\" value=\"120\" /&gt;&lt;/bean&gt; 校验器注入到处理器适配器中 123&lt;mvc:annotation-driven conversion-service=\"conversionService\" validator=\"validator\"&gt;&lt;/mvc:annotation-driven&gt; 在CustomValidationMessages.properties配置校验错误信息： 123#添加校验的错误提示信息items.name.length.error=请输入1到30个字符的商品名称items.createtime.isNUll=请输入商品的生产日期 在pojo中添加校验规则在ItemsCustom.java中添加校验规则： 123456789101112131415public class Items &#123; private Integer id; //校验名称在1到30字符中间 //message是提示校验出错显示的信息 //groups：此校验属于哪个分组，groups可以定义多个分组 @Size(min=1,max=30,message=\"&#123;items.name.length.error&#125;\") private String name; private Float price; private String pic; //非空校验 @NotNull(message=\"&#123;items.createtime.isNUll&#125;\") private Date createtime; 捕获和显示校验错误信息1234567@RequestMapping(\"/editItemsSubmit\")public String editItemsSubmit( Model model, HttpServletRequest request, Integer id, @Validated ItemsCustom itemsCustom, BindingResult bindingResult)throws Exception &#123; 在controller中将错误信息传到页面即可 123456789101112131415161718//获取校验错误信息if(bindingResult.hasErrors())&#123; // 输出错误信息 List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors(); for (ObjectError objectError :allErrors)&#123; // 输出错误信息 System.out.println(objectError.getDefaultMessage()); &#125; // 将错误信息传到页面 model.addAttribute(&quot;allErrors&quot;, allErrors); //可以直接使用model将提交pojo回显到页面 model.addAttribute(&quot;items&quot;, itemsCustom); // 出错重新到商品修改页面 return &quot;items/editItems&quot;;&#125; 页面显示错误信息： 123456&lt;!-- 显示错误信息 --&gt;&lt;c:if test=\"$&#123;allErrors!=null &#125;\"&gt; &lt;c:forEach items=\"$&#123;allErrors &#125;\" var=\"error\"&gt; $&#123; error.defaultMessage&#125;&lt;br/&gt; &lt;/c:forEach&gt;&lt;/c:if&gt; 分组校验 需求： 在pojo中定义校验规则，而pojo是被多个controller所共用，当不同的controller方法对同一个pojo进行校验，但是每个controller方法需要不同的校验 解决方法： 定义多个校验分组（其实是一个java接口），分组中定义有哪些规则 每个controller方法使用不同的校验分组 1.校验分组 12345public interface ValidGroup1 &#123; //接口中不需要定义任何方法，仅是对不同的校验规则进行分组 //此分组只校验商品名称长度&#125; 2.在校验规则中添加分组 12345//校验名称在1到30字符中间//message是提示校验出错显示的信息//groups：此校验属于哪个分组，groups可以定义多个分组@Size(min=1,max=30,message=\"&#123;items.name.length.error&#125;\",groups = &#123;ValidGroup1.class&#125;)private String name; 3.在controller方法使用指定分组的校验 12345678// value=&#123;ValidGroup1.class&#125;指定使用ValidGroup1分组的校验@RequestMapping(\"/editItemsSubmit\")public String editItemsSubmit( Model model, HttpServletRequest request, Integer id, @Validated(value = ValidGroup1.class)ItemsCustom itemsCustom, BindingResult bindingResult)throws Exception &#123;","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(13)-springmvc注解开发之集合类型参数绑定","date":"2016-03-29T22:28:13.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-13-annotation-collection-param-binding/","text":"本文主要介绍注解开发的集合类型参数绑定，包括数组绑定，list绑定以及map绑定 数组绑定需求商品批量删除，用户在页面选择多个商品，批量删除。 表现层实现关键：将页面选择(多选)的商品id，传到controller方法的形参，方法形参使用数组接收页面请求的多个商品id。 controller方法定义： 123// 批量删除 商品信息@RequestMapping(\"/deleteItems\")public String deleteItems(Integer[] items_id) throws Exception 页面定义： 123456789101112&lt;c:forEach items=\"$&#123;itemsList &#125;\" var=\"item\"&gt;&lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"items_id\" value=\"$&#123;item.id&#125;\"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=\"$&#123;item.createtime&#125;\" pattern=\"yyyy-MM-dd HH:mm:ss\"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"$&#123;pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;\"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt; list绑定需求通常在需要批量提交数据时，将提交的数据绑定到list&lt;pojo&gt;中，比如：成绩录入（录入多门课成绩，批量提交）， 本例子需求：批量商品修改，在页面输入多个商品信息，将多个商品信息提交到controller方法中。 表现层实现 controller方法定义： 1、进入批量商品修改页面(页面样式参考商品列表实现) 2、批量修改商品提交 使用List接收页面提交的批量数据，通过包装pojo接收，在包装pojo中定义list&lt;pojo&gt;属性 12345678910public class ItemsQueryVo &#123; //商品信息 private Items items; //为了系统 可扩展性，对原始生成的po进行扩展 private ItemsCustom itemsCustom; //批量商品信息 private List&lt;ItemsCustom&gt; itemsList; 1234567// 批量修改商品提交// 通过ItemsQueryVo接收批量提交的商品信息，将商品信息存储到itemsQueryVo中itemsList属性中。@RequestMapping(\"/editItemsAllSubmit\")public String editItemsAllSubmit(ItemsQueryVo itemsQueryVo) throws Exception &#123; return \"success\";&#125; 页面定义： 12345678910&lt;c:forEach items=\"$&#123;itemsList &#125;\" var=\"item\" varStatus=\"status\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input name=\"itemsList[$&#123;status.index &#125;].name\" value=\"$&#123;item.name &#125;\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=\"itemsList[$&#123;status.index &#125;].price\" value=\"$&#123;item.price &#125;\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=\"itemsList[$&#123;status.index &#125;].createtime\" value=\"&lt;fmt:formatDate value=\"$&#123;item.createtime&#125;\" pattern=\"yyyy-MM-dd HH:mm:ss\"/&gt;\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input name=\"itemsList[$&#123;status.index &#125;].detail\" value=\"$&#123;item.detail &#125;\"/&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; name的格式： 对应包装pojo中的list类型属性名[下标(从0开始)].包装pojo中List类型的属性中pojo的属性名 例子： &quot;name=&quot;itemsList[${status.index }].price&quot; 可以和包装类型的参数绑定归纳对比一下，其实就是在包装类的pojo基础上多了个下标。只不过包装类参数绑定时，要和包装pojo中的pojo类性的属性名一致，而list参数绑定时，要和包装pojo中的list类型的属性名一致。 map绑定也通过在包装pojo中定义map类型属性。 在包装类中定义Map对象，并添加get/set方法，action使用包装对象接收。 包装类中定义Map对象如下： 1234Public class QueryVo &#123;private Map&lt;String, Object&gt; itemInfo = new HashMap&lt;String, Object&gt;(); //get/set方法..&#125; 页面定义如下： 12345678&lt;tr&gt;&lt;td&gt;学生信息：&lt;/td&gt;&lt;td&gt;姓名：&lt;inputtype=\"text\"name=\"itemInfo['name']\"/&gt;年龄：&lt;inputtype=\"text\"name=\"itemInfo['price']\"/&gt;.. .. ..&lt;/td&gt;&lt;/tr&gt; Contrller方法定义如下： 123public String useraddsubmit(Model model,QueryVo queryVo)throws Exception&#123;System.out.println(queryVo.getStudentinfo());&#125;","tags":[{"name":"注解","slug":"注解","permalink":"https://brianway.github.io/tags/注解/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(12)-springmvc注解开发之包装类型参数绑定","date":"2016-03-29T22:28:12.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-12-annotation-pack-param-binding/","text":"本文主要介绍注解开发的介绍包装类型的参数绑定 需求商品查询controller方法中实现商品查询条件传入。 实现方法 第一种方法：在形参中添加HttpServletRequest request参数，通过request接收查询条件参数。 第二种方法：在形参中让包装类型的pojo接收查询条件参数。 分析： 页面传参数的特点：复杂，多样性。条件包括：用户账号、商品编号、订单信息。。。 如果将用户账号、商品编号、订单信息等放在简单pojo（属性是简单类型）中，pojo类属性比较多，比较乱。建议使用包装类型的pojo，pojo中属性是pojo。 页面参数和controller方法形参定义 页面参数： 商品名称：&lt;input name=&quot;itemsCustom.name&quot; /&gt; 注意：itemsCustom和包装pojo中的属性名一致即可。 controller方法形参： public ModelAndView queryItems(HttpServletRequest request, ItemsQueryVo itemsQueryVo) throws Exception 包装类ItemsQueryVo中部分属性： 1234567public class ItemsQueryVo &#123; //商品信息 private Items items; //为了系统 可扩展性，对原始生成的po进行扩展 private ItemsCustom itemsCustom; 可见，ItemsQueryVo中属性itemsCustom和页面参数中一致","tags":[{"name":"注解","slug":"注解","permalink":"https://brianway.github.io/tags/注解/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(11)-springmvc注解开发之简单参数绑定","date":"2016-03-29T22:28:11.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-11-annotation-simple-param-binding/","text":"本文主要介绍注解开发的简单参数绑定，包括简单类型、简单pojo以及自定义绑定实现类型转换 spring参数绑定过程从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。 springmvc中，接收页面提交的数据是通过方法形参来接收。而不是在controller类定义成员变更接收！！！！ 参数绑定过程 默认支持的类型直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接进行绑定。 HttpServletRequest：通过request对象获取请求信息 HttpServletResponse：通过response处理响应信息 HttpSession：通过session对象得到session中存放的对象 Model/ModelMap：model是一个接口，modelMap是一个接口实现。作用：将model数据填充到request域。 简单类型通过@RequestParam对简单类型的参数进行绑定。如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。 如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。 通过required属性指定参数是否必须要传入，如果设置为true，没有传入参数，报下边错误： 指定传入参数未传入报错 12345@RequestMapping(value=\"/editItems\",method=&#123;RequestMethod.POST,RequestMethod.GET&#125;)//@RequestParam里边指定request传入参数名称和形参进行绑定。//通过required属性指定参数是否必须要传入//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。public String editItems(Model model,@RequestParam(value=\"id\",required=true) Integer items_id)throws Exception &#123; pojo绑定页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo。 注意:这里只是要求name和形参的属性名一致，而不是要求和形参的名称一致，这点不要混淆了，框架会进入形参内部自动匹配pojo类的属性名。(我没看源码，但应该是用反射实现的) 页面定义： 123456789&lt;table width=\"100%\" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"name\" value=\"$&#123;itemsCustom.name &#125;\"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"price\" value=\"$&#123;itemsCustom.price &#125;\"/&gt;&lt;/td&gt;&lt;/tr&gt; controller的pojo形参的定义： 123456789101112public class Items &#123; private Integer id; private String name; private Float price; private String pic; private Date createtime; private String detail; 自定义参数绑定实现日期类型绑定对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。 将请求日期数据串传成日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。本文示例中，自定义参数绑定将日期串转成java.util.Date类型。 需要向处理器适配器中注入自定义的参数绑定组件。 自定义日期类型绑定 123456789101112131415161718public class CustomDateConverter implements Converter&lt;String,Date&gt;&#123; public Date convert(String s) &#123; //实现 将日期串转成日期类型(格式是yyyy-MM-dd HH:mm:ss) SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); try &#123; //转成直接返回 return simpleDateFormat.parse(s); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //如果参数绑定失败返回null return null; &#125;&#125; 配置方式 1&lt;mvc:annotation-driven conversion-service=\"conversionService\"&gt;&lt;/mvc:annotation-driven&gt; 12345678910&lt;!-- 自定义参数绑定 --&gt; &lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;!-- 转换器 --&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;!-- 日期类型转换 --&gt; &lt;bean class=\"com.iot.learnssm.firstssm.controller.converter.CustomDateConverter\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; springmvc和struts2的区别 1.springmvc基于方法开发的，struts2基于类开发的。 springmvc将url和controller方法映射。映射成功后springmvc生成一个Handler对象，对象中只包括了一个method。方法执行结束，形参数据销毁。springmvc的controller开发类似service开发。 2.springmvc可以进行单例开发，并且建议使用单例开发，struts2通过类的成员变量接收参数，无法使用单例，只能使用多例。 3.经过实际测试，struts2速度慢，在于使用struts标签，如果使用struts建议使用jstl。","tags":[{"name":"注解","slug":"注解","permalink":"https://brianway.github.io/tags/注解/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(10)-springmvc注解开发之商品修改功能","date":"2016-03-29T22:28:10.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-10-annotation-sample/","text":"本文以商品修改为例，记录springmvc的注解开发，包括mapper,service,controller,@RequestMapping,controller方法的返回值等 需求操作流程： 1.进入商品查询列表页面 2.点击修改，进入商品修改页面，页面中显示了要修改的商品。要修改的商品从数据库查询，根据商品id(主键)查询商品信息 3.在商品修改页面，修改商品信息，修改后，点击提交 开发mappermapper： 根据id查询商品信息 根据id更新Items表的数据 不用开发了，使用逆向工程生成的代码。 开发service在com.iot.learnssm.firstssm.service.ItemsService中添加两个接口 123456789101112131415161718192021//根据id查询商品信息 /** * * &lt;p&gt;Title: findItemsById&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param id 查询商品的id * @return * @throws Exception */ ItemsCustom findItemsById(Integer id) throws Exception; //修改商品信息 /** * * &lt;p&gt;Title: updateItems&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param id 修改商品的id * @param itemsCustom 修改的商品信息 * @throws Exception */ void updateItems(Integer id,ItemsCustom itemsCustom) throws Exception; 在com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl中实现接口，增加itemsMapper属性 123456789101112131415161718192021222324@Autowiredprivate ItemsMapper itemsMapper;public ItemsCustom findItemsById(Integer id) throws Exception &#123; Items items = itemsMapper.selectByPrimaryKey(id); //中间对商品信息进行业务处理 //.... //返回ItemsCustom ItemsCustom itemsCustom = new ItemsCustom(); //将items的属性值拷贝到itemsCustom BeanUtils.copyProperties(items, itemsCustom); return itemsCustom;&#125;public void updateItems(Integer id, ItemsCustom itemsCustom) throws Exception &#123; //添加业务校验，通常在service接口对关键参数进行校验 //校验 id是否为空，如果为空抛出异常 //更新商品信息使用updateByPrimaryKeyWithBLOBs根据id更新items表中所有字段，包括 大文本类型字段 //updateByPrimaryKeyWithBLOBs要求必须转入id itemsCustom.setId(id); itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);&#125; 开发controller方法： 商品信息修改页面显示 商品信息修改提交 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action//@RequestMapping(\"/items\")public class ItemsController &#123; @Autowired private ItemsService itemsService; //商品查询列表 @RequestMapping(\"/queryItems\") //实现 对queryItems方法和url进行映射，一个方法对应一个url //一般建议将url和方法写成一样 public ModelAndView queryItems() throws Exception&#123; //调用service查找数据库，查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据 modelAndView.addObject(\"itemsList\",itemsList); //指定视图 //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList //modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\"); //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀 modelAndView.setViewName(\"items/itemsList\"); return modelAndView; &#125; //商品信息修改页面显示 @RequestMapping(\"/editItems\") //限制http请求方法，可以post和get //@RequestMapping(value=\"/editItems\",method=&#123;RequestMethod.POST, RequestMethod.GET&#125;) public ModelAndView editItems()throws Exception &#123; //调用service根据商品id查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(1); // 返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //将商品信息放到model modelAndView.addObject(\"itemsCustom\", itemsCustom); //商品修改页面 modelAndView.setViewName(\"items/editItems\"); return modelAndView; &#125; //商品信息修改提交 @RequestMapping(\"/editItemsSubmit\") public ModelAndView editItemsSubmit(HttpServletRequest request, Integer id, ItemsCustom itemsCustom)throws Exception &#123; //调用service更新商品信息，页面需要将商品信息传到此方法 itemsService.updateItems(id, itemsCustom); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //返回一个成功页面 modelAndView.setViewName(\"success\"); return modelAndView; &#125;&#125; @RequestMapping url映射 定义controller方法对应的url，进行处理器映射使用。 窄化请求映射 123456//使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.action@RequestMapping(\"/items\")public class ItemsController &#123; 限制http请求方法 出于安全性考虑，对http的链接进行方法限制。 12345//商品信息修改页面显示 //@RequestMapping(\"/editItems\") //限制http请求方法，可以post和get @RequestMapping(value=\"/editItems\",method=&#123;RequestMethod.POST, RequestMethod.GET&#125;) public ModelAndView editItems()throws Exception &#123; 如果限制请求为post方法，进行get请求，即将上面代码的注解改为@RequestMapping(value=&quot;/editItems&quot;,method={RequestMethod.POST}) 报错，状态码405： controller方法的返回值 返回ModelAndView 需要方法结束时，定义ModelAndView，将model和view分别进行设置。 返回string 如果controller方法返回string 1.表示返回逻辑视图名。 真正视图(jsp路径)=前缀+逻辑视图名+后缀 12345678910111213141516@RequestMapping(value=\"/editItems\",method=&#123;RequestMethod.POST,RequestMethod.GET&#125;)//@RequestParam里边指定request传入参数名称和形参进行绑定。//通过required属性指定参数是否必须要传入//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定。//public String editItems(Model model, @RequestParam(value=\"id\",required=true) Integer items_id)throws Exception &#123;public String editItems(Model model)throws Exception &#123; //调用service根据商品id查询商品信息 ItemsCustom itemsCustom = itemsService.findItemsById(1); //通过形参中的model将model数据传到页面 //相当于modelAndView.addObject方法 model.addAttribute(\"itemsCustom\", itemsCustom); return \"items/editItems\";&#125; 2.redirect重定向 商品修改提交后，重定向到商品查询列表。 redirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无法传到重定向的地址。因为重定向后重新进行request（request无法共享） 12//重定向到商品查询列表//return \"redirect:queryItems.action\"; 3.forward页面转发 通过forward进行页面转发，浏览器地址栏url不变，request可以共享。 12//页面转发return \"forward:queryItems.action\"; 返回void 在controller方法形参上可以定义request和response，使用request或response指定响应结果： 1.使用request转向页面，如下： request.getRequestDispatcher(&quot;页面路径&quot;).forward(request, response); 2.也可以通过response页面重定向： response.sendRedirect(&quot;url&quot;) 3.也可以通过response指定响应结果，例如响应json数据如下： 123response.setCharacterEncoding(\"utf-8\");response.setContentType(\"application/json;charset=utf-8\");response.getWriter().write(\"json串\");","tags":[{"name":"注解","slug":"注解","permalink":"https://brianway.github.io/tags/注解/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(9)-springmvc整合mybatis之controller","date":"2016-03-29T22:28:09.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-9-controller/","text":"本文介绍如何配置springmvc配置文件和web.xml，以及如何编写controller,jsp springmvc.xml在resources/spring文件下下创建springmvc.xml文件，配置处理器映射器、适配器、视图解析器。 1234567891011121314151617181920212223242526272829303132333435&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 对于注解的Handler 可以单个配置 实际开发中加你使用组件扫描 --&gt; &lt;!-- 可以扫描controller、service、... 这里让扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package=\"com.iot.learnssm.firstssm.controller\"&gt;&lt;/context:component-scan&gt; &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 视图解析器 解析jsp,默认使用jstl,classpath下要有jstl的包 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置web.xml参考入门程序，web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;display-name&gt;firstssm&lt;/display-name&gt; &lt;!-- 加载spring容器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/classes/spring/applicationContext-*.xml&lt;/param-value&gt; &lt;!-- &lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;--&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- springmvc 前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等) 若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml) --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 第一种:*.action,访问以.action三结尾，由DispatcherServlet进行解析 第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析， 使用此种方式和实现RESTful风格的url 第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址， 不能根据jsp页面找到handler，会报错 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 这个文件有两个作用： 配置前端控制器(DispatcherServlet) 加载spring容器：添加spring容器监听器，加载spring容器，使用通配符加载spring/下的配置文件 applicationContext-dao.xml applicationContext-service.xml applicationContext-transaction.xml 编写Controller(就是Handler)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.iot.learnssm.firstssm.controller;import com.iot.learnssm.firstssm.po.Items;import com.iot.learnssm.firstssm.po.ItemsCustom;import com.iot.learnssm.firstssm.service.ItemsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import java.util.ArrayList;import java.util.List;/** * Created by brian on 2016/3/2. *///使用@Controller来标识它是一个控制器@Controller//为了对url进行分类管理 ，可以在这里定义根路径，最终访问url是根路径+子路径//比如：商品列表：/items/queryItems.actionpublic class ItemsController &#123; @Autowired private ItemsService itemsService; //商品查询列表 @RequestMapping(\"/queryItems\") //实现 对queryItems方法和url进行映射，一个方法对应一个url //一般建议将url和方法写成一样 public ModelAndView queryItems() throws Exception&#123; //调用service查找数据库，查询商品列表 List&lt;ItemsCustom&gt; itemsList = itemsService.findItemsList(null); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据 modelAndView.addObject(\"itemsList\",itemsList); //指定视图 //下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList //modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\"); //下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀 modelAndView.setViewName(\"items/itemsList\"); return modelAndView; &#125;&#125; 编写jsp服务器路径为WEB-INF/jsp/items/itemsList.jsp 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/fmt\" prefix=\"fmt\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"$&#123;pageContext.request.contextPath &#125;/item/queryItem.action\" method=\"post\"&gt;查询条件：&lt;table width=\"100%\" border=1&gt;&lt;tr&gt;&lt;td&gt;&lt;input type=\"submit\" value=\"查询\"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;商品列表：&lt;table width=\"100%\" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items=\"$&#123;itemsList &#125;\" var=\"item\"&gt;&lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=\"$&#123;item.createtime&#125;\" pattern=\"yyyy-MM-dd HH:mm:ss\"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"$&#123;pageContext.request.contextPath &#125;/item/editItem.action?id=$&#123;item.id&#125;\"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(8)-springmvc整合mybatis之service","date":"2016-03-29T22:28:08.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-8-service/","text":"本文记录如何整合service,包括定义spring接口，在spring容器配置service以及事务控制。让spring管理service接口。 定义service接口12345public interface ItemsService &#123; //商品查询列表 List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;&#125; 123456789public class ItemsServiceImpl implements ItemsService &#123; @Autowired private ItemsMapperCustom itemsMapperCustom; public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception &#123; return itemsMapperCustom.findItemsList(itemsQueryVo); &#125;&#125; 在spring容器配置service在resources/spring下创建applicationContext-service.xml，文件中配置service。 12345678&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\"&gt; &lt;!-- 商品管理的service --&gt; &lt;bean id=\"itemsService\" class=\"com.iot.learnssm.firstssm.service.impl.ItemsServiceImpl\"/&gt;&lt;/beans&gt; 事务控制在resources/spring下创建applicationContext-transaction.xml，在applicationContext-transaction.xml中使用spring声明式事务控制方法。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;!-- 事务管理器 对mybatis操作数据库事务控制，spring使用jdbc的事务控制类 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 数据源 dataSource在applicationContext-dao.xml中配置了 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.iot.learnssm.firstssm.service.impl.*.*(..))\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(7)-springmvc整合mybatis之mapper","date":"2016-03-29T22:28:07.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-7-mapper/","text":"本文记录springmvc整合dao的配置 整合dao首先在resource文件夹下添加两个文件：数据库配置文件和日志配置文件 数据库配置文件db.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8jdbc.username=rootjdbc.password=123 日志配置文件log4j.properties 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n sqlMapConfig.xmlmybatis自己的配置文件 在resources目录下新建mybatis文件夹，并新建sqlMapConfig.xml文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 全局setting配置，根据需要添加 --&gt; &lt;!-- 配置别名 --&gt; &lt;typeAliases&gt; &lt;!-- 批量扫描别名 --&gt; &lt;package name=\"com.iot.learnssm.firstssm.po\"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置mapper 由于使用spring和mybatis的整合包进行mapper扫描，这里不需要配置了。 必须遵循：mapper.xml和mapper.java文件同名且在一个目录 --&gt; &lt;!-- &lt;mappers&gt; &lt;/mappers&gt; --&gt;&lt;/configuration&gt; applicationContext-dao.xml在resources目录下新建spring文件夹，并新建applicationContext-dao.xml文件 配置： 数据源 SqlSessionFactory mapper扫描器 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 加载db.properties文件中的内容，db.properties文件中key命名要有一定的特殊规则 --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\" /&gt; &lt;!-- 配置数据源 ，dbcp --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;property name=\"maxActive\" value=\"30\" /&gt; &lt;property name=\"maxIdle\" value=\"5\" /&gt; &lt;/bean&gt; &lt;!-- 从整合包里找，org.mybatis:mybatis-spring:1.2.4 --&gt; &lt;!-- sqlSessionFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis/sqlMapConfig.xml\" /&gt; &lt;/bean&gt; &lt;!-- mapper扫描器 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 --&gt; &lt;property name=\"basePackage\" value=\"com.iot.learnssm.firstssm.mapper\"/&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;!-- &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt; 会导致数据源配置不管用，数据库连接不上。 且spring 4弃用 --&gt; &lt;/bean&gt;&lt;/beans&gt; 逆向工程生成po类及mapper(单表增删改查)方法参见《mybatis学习笔记(18)-mybatis逆向工程》 手动定义商品查询mapper针对综合查询mapper，一般情况会有关联查询，建议自定义mapper ItemsMapperCustom.xml 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.iot.learnssm.firstssm.mapper.ItemsMapperCustom\" &gt; &lt;!-- 定义商品查询的sql片段，就是商品查询条件 --&gt; &lt;sql id=\"query_items_where\"&gt; &lt;!-- 使用动态sql，通过if判断，满足条件进行sql拼接 --&gt; &lt;!-- 商品查询条件通过ItemsQueryVo包装对象 中itemsCustom属性传递 --&gt; &lt;if test=\"itemsCustom!=null\"&gt; &lt;if test=\"itemsCustom.name!=null and itemsCustom.name!=''\"&gt; items.name LIKE '%$&#123;itemsCustom.name&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; &lt;!-- 商品列表查询 --&gt; &lt;!-- parameterType传入包装对象(包装了查询条件) resultType建议使用扩展对象 --&gt; &lt;select id=\"findItemsList\" parameterType=\"com.iot.learnssm.firstssm.po.ItemsQueryVo\" resultType=\"com.iot.learnssm.firstssm.po.ItemsCustom\"&gt; SELECT items.* FROM items &lt;where&gt; &lt;include refid=\"query_items_where\"&gt;&lt;/include&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; ItemsMapperCustom.java 1234public interface ItemsMapperCustom &#123; //商品查询列表 List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo)throws Exception;&#125; po类ItemsCustom 123456789package com.iot.learnssm.firstssm.po;/** * Created by Brian on 2016/3/2. * 商品信息的扩展类 */public class ItemsCustom extends Items&#123; //添加商品信息的扩展属性&#125; 输入pojo的包装类 1234567891011121314151617181920212223242526272829package com.iot.learnssm.firstssm.po;/** * Created by Brian on 2016/3/2. */public class ItemsQueryVo &#123; //商品信息 private Items items; //为了系统 可扩展性，对原始生成的po进行扩展 private ItemsCustom itemsCustom; public Items getItems() &#123; return items; &#125; public void setItems(Items items) &#123; this.items = items; &#125; public ItemsCustom getItemsCustom() &#123; return itemsCustom; &#125; public void setItemsCustom(ItemsCustom itemsCustom) &#123; this.itemsCustom = itemsCustom; &#125;&#125; 整合好dao后的工程目录如图 springmvc_整合工程-2","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(6)-springmvc整合mybatis(IDEA中通过maven构建)","date":"2016-03-29T22:28:06.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-6-integrate-mybatis/","text":"本文主要展示如何在intellij IDEA中通过maven构建springmvc+mybatis框架的开发环境。 需求：使用springmvc和mybatis完成商品列表查询 整合思路 springmvc_整合mybatis思路 第一步：整合dao层 mybatis和spring整合，通过spring管理mapper接口。 使用mapper的扫描器自动扫描mapper接口在spring中进行注册。 第二步：整合service层 通过spring管理service接口。 使用配置方式将service接口配置在spring配置文件中。 实现事务控制。 第三步：整合springmvc 由于springmvc是spring的模块，不需要整合。 工程结构不同于《mybatis学习笔记(17)-spring和mybatis整合》中的示例demo,本文的整合采用maven构建。 如何创建使用maven构建的web应用可以参考前面的一篇《springmvc学习笔记(1)-框架原理和入门配置》 new-&gt;project-&gt;maven，建一个裸的maven工程，手动建webapp的目录 在src/main下新建文件夹webapp 添加依赖pom.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.iot.learnssm&lt;/groupId&gt; &lt;artifactId&gt;learnssm-firstssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- jar 版本设置 --&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSP tag --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 这里添加的依赖可能有多的,但总比少包好，我开始就是引少了依赖(springframework的依赖只引用了spring-mvc,连spring-core都没引)，导致报错,以后会出一篇博客专门讲这个系列笔记中debug相关问题。 建包在java目录下建各个package,按照maven的命名习惯: com.公司名.项目名.模块名 这里我的包为： com.iot.learnssm.firstssm 包含几个子包： controller mapper po service impl 项目结构如图： springmvc_整合工程-1 后面几篇笔记会依次记录mapper,service,controller各个部分的整合","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"IntelliJ-IDEA","slug":"IntelliJ-IDEA","permalink":"https://brianway.github.io/tags/IntelliJ-IDEA/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"},{"name":"Maven","slug":"Maven","permalink":"https://brianway.github.io/tags/Maven/"}]},{"title":"springmvc学习笔记(5)-入门程序小结","date":"2016-03-29T22:28:05.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-5-Start-Summary/","text":"通过入门程序理解springmvc前端控制器、处理器映射器、处理器适配器、视图解析器用法。并附上入门程序的非注解的完整的配置文件，注解的完整配置文件。 入门程序配置小结前端控制器配置： 第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析 第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析,使用此种方式可以实现RESTful风格的url 处理器映射器： 非注解处理器映射器（了解） 注解的处理器映射器（掌握） 对标记@Controller类中标识有@RequestMapping的方法进行映射。在@RequestMapping里边定义映射的url。使用注解的映射器不用在xml中配置url和Handler的映射关系。 处理器适配器： 非注解处理器适配器（了解）注解的处理器适配器（掌握）注解处理器适配器和注解的处理器映射器是配对使用。理解为不能使用非注解映射器进行映射。 1&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 可以代替下边的配置： 1234&lt;!--注解映射器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/&gt; &lt;!--注解适配器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/&gt; 非注解的完整的配置文件src/main/resources/springmvc.xml 123456789101112131415161718192021222324252627&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 配置Handler --&gt; &lt;bean name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/&gt; &lt;!-- 处理器映射器 将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url) --&gt; &lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; &lt;!-- 处理器适配器 所有处理器适配器都实现了HandlerAdapter接口 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"/&gt; &lt;!-- 视图解析器 解析jsp,默认使用jstl,classpath下要有jstl的包 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/&gt;&lt;/beans&gt; 注解的完整配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd\"&gt; &lt;!-- 对于注解的Handler 可以单个配置 实际开发中加你使用组件扫描 --&gt; &lt;!-- &lt;bean class=\"com.iot.ssm.controller.ItemsController3\"/&gt; --&gt; &lt;!-- 可以扫描controller、service、... 这里让扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package=\"com.iot.ssm.controller\"&gt;&lt;/context:component-scan&gt; &lt;!-- 注解的映射器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/&gt; &lt;!-- 注解的适配器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/&gt; &lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 视图解析器 解析jsp,默认使用jstl,classpath下要有jstl的包 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt;","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(4)-前端控制器","date":"2016-03-29T22:28:04.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-4-Front-controller/","text":"本文通过前端控制器源码分析springmvc执行过程 1.前端控制器接收请求 调用doDispatch方法 1234567protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; 。。。。。&#125; 2.前端控制器调用HandlerMapping（处理器映射器）根据url查找Handler 12// Determine handler for the current request.mappedHandler = getHandler(processedRequest); 12345678910111213141516171819/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found */ protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\"); &#125; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null; &#125; 3.调用处理器适配器执行Handler,得到执行的结果ModelAndView mv 在doDispatch方法中 12// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 4.视图渲染，将model数据填充到request域 doDispatch-&gt;processDispatchResult-&gt;render 在render方法中,视图解析得到view 12// We need to resolve the view name.view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request); 调用view的渲染方法，将model数据填充到request域 在render方法中,调用View接口的render方法 1view.render(mv.getModelInternal(), request, response); 程序我也没细读，感觉分析比较浅，很多还没弄懂，等我系统阅读源码后会整理一篇好点的。","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(3)-注解的处理器映射器和适配器","date":"2016-03-29T22:28:03.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-3-Annotation/","text":"本文主要介绍注解的处理器映射器和适配器相关配置 默认加载前端控制器从\\org\\springframework\\web\\servlet\\DispatcherServlet.properties件中加载处理器映射器、适配器、视图解析器等组件，如果不在springmvc.xml中配置，则使用默认加载的 注解的处理器映射器和适配器 在spring3.1之前使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping注解映射器。 在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping注解映射器。 在spring3.1之前使用org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter注解适配器。 在spring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter注解适配器 注解的处理器映射器和适配器12345&lt;!-- 注解的映射器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/&gt;&lt;!-- 注解的适配器 --&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/&gt; 或者 123456&lt;!-- 使用mvc:annotation-driven代替上面两个注解映射器和注解适配的配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器默认加载了，如果使用mvc:annotation-driven则不用配置上面的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; 开发注解Handler使用注解的映射器和注解的适配器。(使用注解的映射器和注解的适配器必须配对使用) 123456789101112131415161718192021222324252627282930313233343536//使用@Controller来标识它是一个控制器@Controllerpublic class ItemsController3 &#123; //商品查询列表 @RequestMapping(\"/queryItems\") //实现 对queryItems方法和url进行映射，一个方法对应一个url //一般建议将url和方法写成一样 public ModelAndView queryItems() throws Exception&#123; //调用service查找数据库，查询商品列表，这里使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName(\"联想笔记本\"); items_1.setPrice(6000f); items_1.setDetail(\"ThinkPad T430 c3 联想笔记本电脑！\"); Items items_2 = new Items(); items_2.setName(\"苹果手机\"); items_2.setPrice(5000f); items_2.setDetail(\"iphone6苹果手机！\"); itemsList.add(items_1); itemsList.add(items_2); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute方法,在jsp页面中通过itemsList取数据 modelAndView.addObject(\"itemsList\",itemsList); //指定视图 modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\"); return modelAndView; &#125;&#125; 在spring容器中加载Handler12345678&lt;!-- 对于注解的Handler 可以单个配置 实际开发中加你使用组件扫描 --&gt; &lt;!-- &lt;bean class=\"com.iot.ssm.controller.ItemsController3\"/&gt; --&gt; &lt;!-- 可以扫描controller、service、... 这里让扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package=\"com.iot.ssm.controller\"&gt;&lt;/context:component-scan&gt; 参考资料 SpringMVC框架】注解的处理器映射器和适配器配置","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(2)-非注解的处理器映射器和适配器","date":"2016-03-29T22:28:02.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-2-Non-annotation/","text":"本文主要介绍非注解的处理器映射器和适配器配置 非注解的处理器映射器123456789101112131415161718 &lt;!-- 配置Handler --&gt;&lt;bean id=\"itemsController\" name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/&gt;&lt;!-- 处理器映射器将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url) --&gt;&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt;&lt;!-- 简单url映射--&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;!-- 对 itemsController进行url映射--&gt; &lt;prop key=\"/queryItems1.action\"&gt;itemsController&lt;/prop&gt; &lt;prop key=\"/queryItems2.action\"&gt;itemsController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 多个映射器可并存，前端控制器判断url能让哪些映射器处理就让正确的映射器处理 非注解的处理器适配器1234&lt;!-- 处理器适配器 所有处理器适配器都实现了HandlerAdapter接口 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; 要求编写的Handler实现Controller接口 &lt;bean class=&quot;org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter&quot;/&gt; 要求编写的Handler实现HttpRequestHandler接口 123456789101112131415161718192021222324252627282930313233343536373839404142package com.iot.ssm.controller;import com.iot.ssm.po.Items;import org.springframework.web.HttpRequestHandler;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.List;/** * Created by brian on 2016/2/19. */public class ItemsController2 implements HttpRequestHandler&#123; public void handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException &#123; //调用service查找数据库，查询商品列表，这里使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName(\"联想笔记本\"); items_1.setPrice(6000f); items_1.setDetail(\"ThinkPad T430 联想笔记本电脑！\"); Items items_2 = new Items(); items_2.setName(\"苹果手机\"); items_2.setPrice(5000f); items_2.setDetail(\"iphone6苹果手机！\"); itemsList.add(items_1); itemsList.add(items_2); //设置模型数据 httpServletRequest.setAttribute(\"itemsList\",itemsList); //设置转发的视图 httpServletRequest.getRequestDispatcher(\"/WEB-INF/jsp/items/itemsList.jsp\").forward(httpServletRequest,httpServletResponse); &#125;&#125; HttpRequestHandler适配器的handleRequest方法返回为void,没有返回ModelAndView，可通过response修改响应内容,比如返回json数据： 123response.setCharacterEncoding(\"utf-8\");response.setContentType(\"application/json;charset=utf-8\");response.getWriter().write(\"json串\");","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"springmvc学习笔记(1)-框架原理和入门配置","date":"2016-03-29T22:28:01.000Z","path":"2016/03/30/2016-03-30-springmvc-learn-1-Frame-start/","text":"本文主要介绍springmvc的框架原理，并通过一个入门程序展示环境搭建，配置以及部署调试。 springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。 springmvc框架原理给个官网示意图 The request processing workflow in Spring Web MVC 组件及其作用 前端控制器(DispatcherServlet)：接收请求，响应结果，相当于转发器，中央处理器。减少了其他组件之间的耦合度 处理器映射器(HandlerMapping)：根据请求的url查找Handler Handler处理器：按照HandlerAdapter的要求编写 处理器适配器(HandlerAdapter)：按照特定规则(HandlerAdapter要求的规则)执行Handler。 视图解析器(ViewResolver)：进行视图解析，根据逻辑视图解析成真正的视图(View) 视图(View)：View是一个接口实现类试吃不同的View类型（jsp,pdf等等） 注：其中加粗的为需要程序员开发的，没加粗的为不需要程序员开发的 文末参考链接中《跟开涛学SpringMVC》里面有张图挺好的，感觉很详细. springmvc_核心架构图 步骤： 1.发起请求到前端控制器(DispatcherServlet) 2.前端控制器请求处理器映射器(HandlerMapping)查找Handler(可根据xml配置、注解进行查找) 3.处理器映射器(HandlerMapping)向前端控制器返回Handler 4.前端控制器调用处理器适配器(HandlerAdapter)执行Handler 5.处理器适配器(HandlerAdapter)去执行Handler 6.Handler执行完，给适配器返回ModelAndView(Springmvc框架的一个底层对象) 7.处理器适配器(HandlerAdapter)向前端控制器返回ModelAndView 8.前端控制器(DispatcherServlet)请求视图解析器(ViewResolver)进行视图解析，根据逻辑视图名解析成真正的视图(jsp) 9.视图解析器(ViewResolver)向前端控制器(DispatcherServlet)返回View 10.前端控制器进行视图渲染，即将模型数据(在ModelAndView对象中)填充到request域 11.前端控制器向用户响应结果 springmvc入门程序一个展示商品列表的小页面 环境搭建intellij IDEA 15.0.2 A方法(有待商榷) new-&gt;project-&gt;maven-&gt;勾选create from archetype-&gt;选中webapp 在src/main下新建java文件夹，标记为Sources Root 这样建出来的工程感觉有问题，点开一些xml文件一片红，心里不是很踏实，所以放弃这个方法了 B方法 new-&gt;project-&gt;maven，建一个裸的maven工程，手动建webapp的目录 在src/main下新建文件夹webapp pom.xml文件 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; 加上下面的标签会生成Artifacts 1&lt;packaging&gt;war&lt;/packaging&gt; build标签的finalName要和Artifacts的output directory一致 123&lt;build&gt; &lt;finalName&gt;springmvc-2nd-1.0-SNAPSHOT&lt;/finalName&gt;&lt;/build&gt; 配置文件 配置前端控制器 web.xml 1234567891011&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- contextConfigLocation配置springmvc加载的配置文件(配置处理器映射器、适配器等等) 若不配置，默认加载WEB-INF/servlet名称-servlet(springmvc-servlet.xml) --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 1234567891011&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- 第一种:*.action,访问以.action结尾，由DispatcherServlet进行解析 第二种:/,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析， 使用此种方式和实现RESTful风格的url 第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址， 不能根据jsp页面找到handler，会报错 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置Handler 将编写Handler在spring容器加载 12&lt;!-- 配置Handler --&gt;&lt;bean name=\"/queryItems.action\" class=\"com.iot.ssm.controller.ItemsController\"/&gt; 配置处理器映射器 在classpath下的springmvc.xml中配置处理器映射器 1234&lt;!-- 处理器映射器 将bean的name作为url进行查找，需要在配置Handler时指定beanname(就是url)--&gt;&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt; 配置处理器适配器 所有处理器适配器都实现了HandlerAdapter接口 &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt; 源码 123public boolean supports(Object handler) &#123; return handler instanceof Controller;&#125; 此适配器能执行实现Controller接口的Handler 配置视图解析器 需要配置解析jsp的视图解析器 1234&lt;!-- 视图解析器 解析jsp,默认使用jstl,classpath下要有jstl的包 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"/&gt; 在springmvc.xml中视图解析器配置前缀和后缀： 123456&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; 程序中不用指定前缀和后缀： 123456//指定视图//下边的路径，如果在视图解析器中配置jsp的路径前缀和后缀，修改为items/itemsList//modelAndView.setViewName(\"/WEB-INF/jsp/items/itemsList.jsp\");//下边的路径配置就可以不在程序中指定jsp路径的前缀和后缀modelAndView.setViewName(\"items/itemsList\"); 部署调试HTTP Status 404 -处理器映射器根据url找不到Handler,说明url错误 HTTP Status 404 -/springmvc/WEB-INF/jsp/items/itemsLists.jsp处理器映射器根据url找到了Handler，转发的jsp页面找不到 参考链接 第二章 Spring MVC入门 —— 跟开涛学SpringMVC Spring MVC Framework Tutorial - TutorialsPoint Web MVC framework","tags":[{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"在intellij IDEA中为web应用创建图片虚拟目录(详细截图)","date":"2016-03-29T22:28:00.000Z","path":"2016/03/30/2016-03-30-IDEA-web-virtua-directory/","text":"本文主要展示如何在intellij IDEA中为web应用添加虚拟目录映射,并附上步骤截图 工程配置和环境我使用的版本为 tomcat 8.0.30 intellij 15.0.2 jdk 1.8.0_25 已经部署好了一个web应用，并且已经在IDEA中添加好了tomcat容器，现在想为这个web应用添加一个图片虚拟目录 操作步骤 1.点击工具栏的运行配置Edit Configurations Edit Configurations 2.在弹出的Run/debug Configurations中选中tomcat容器，选择deployment这个tab deployment 3.添加物理目录和并设置虚拟目录路径 添加物理目录和并设置虚拟目录路径 这里我选择了D盘下面的tmp文件夹作为物理目录，虚拟目录设为了/pic,我试了下，虽然斜杠少了也没什么影响，一样能访问，不过还是建议加上吧。 4.运行web应用，访问图片资源 附上博主帅照一张 访问图片资源 这里需要接上具体访问资源的文件名，不然后访问不到的，如下图 访问不到 在非IDE环境下配置虚拟目录怎么为tomcat配置虚拟目录映射可以参考下面的博客： tomcat配置虚拟目录映射","tags":[{"name":"IntelliJ-IDEA","slug":"IntelliJ-IDEA","permalink":"https://brianway.github.io/tags/IntelliJ-IDEA/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"mybatis学习笔记(18)-mybatis逆向工程","date":"2016-03-07T18:39:18.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-18-Reverse-Engineering/","text":"mybaits需要程序员自己编写sql语句,mybatis官方提供逆向工程,可以针对单表自动生成mybatis执行所需要的代码（mapper.java,mapper.xml、po..） 企业实际开发中，常用的逆向工程方式：由数据库的表生成java代码。 先附上官网链接： MyBatis Generator A code generator for MyBatis and iBATIS. - GitHub 下载逆向工程这里其实可以添加Maven依赖的，因为跟着视频做的，所以我就建了个普通工程，直接添加了个lib文件夹，把要用的jar包直接copy进来了。 maven中央仓库MyBatis-Generator下载地址：【MyBatis Generator Core】 使用方法运行逆向工程根据官网说的（Running MyBatis Generator）： Running MyBatis Generator MyBatis Generator (MBG) can be run in the following ways: From the command prompt with an XML configuration As an Ant task with an XML configuration As a Maven Plugin From another Java program with an XML configuration From another Java program with a Java based configuration 还可以通过eclipse的插件生成代码 建议使用java程序方式，不依赖开发工具。 生成代码配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"testTables\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=\"suppressAllComments\" value=\"true\" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\" userId=\"root\" password=\"123\"&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\" connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:yycg\" userId=\"yycg\" password=\"yycg\"&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=\"com.iot.ssm.po\" targetProject=\".\\src\"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=\"com.iot.ssm.mapper\" targetProject=\".\\src\"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.iot.ssm.mapper\" targetProject=\".\\src\"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=\"enableSubPackages\" value=\"false\" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName=\"items\"&gt;&lt;/table&gt; &lt;table tableName=\"orders\"&gt;&lt;/table&gt; &lt;table tableName=\"orderdetail\"&gt;&lt;/table&gt; &lt;table tableName=\"user\"&gt;&lt;/table&gt; &lt;!-- &lt;table schema=\"\" tableName=\"sys_user\"&gt;&lt;/table&gt; &lt;table schema=\"\" tableName=\"sys_role\"&gt;&lt;/table&gt; &lt;table schema=\"\" tableName=\"sys_permission\"&gt;&lt;/table&gt; &lt;table schema=\"\" tableName=\"sys_user_role\"&gt;&lt;/table&gt; &lt;table schema=\"\" tableName=\"sys_role_permission\"&gt;&lt;/table&gt; --&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema=\"\" tableName=\"\"&gt; &lt;columnOverride column=\"\" javaType=\"\" /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 需要注意的位置： javaModelGenerator,生成PO类的位置 sqlMapGenerator,mapper映射文件生成的位置 javaClientGenerator,mapper接口生成的位置 table,指定数据库表 执行生成程序1234567891011121314public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; //指定逆向工程配置文件 File configFile = new File(\"generatorConfig.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 日志输出： 1234567891011121314151617181920212223242016-02-27 16:29:46,419 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Retrieving column information for table &quot;items&quot;2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;id&quot;, data type 4, in table &quot;mybatis001..items&quot;2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;name&quot;, data type 12, in table &quot;mybatis001..items&quot;2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;price&quot;, data type 7, in table &quot;mybatis001..items&quot;2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;detail&quot;, data type -1, in table &quot;mybatis001..items&quot;2016-02-27 16:29:46,477 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;pic&quot;, data type 12, in table &quot;mybatis001..items&quot;2016-02-27 16:29:46,478 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;createtime&quot;, data type 93, in table &quot;mybatis001..items&quot;2016-02-27 16:29:46,503 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Retrieving column information for table &quot;orders&quot;2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;id&quot;, data type 4, in table &quot;mybatis001..orders&quot;2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;user_id&quot;, data type 4, in table &quot;mybatis001..orders&quot;2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;number&quot;, data type 12, in table &quot;mybatis001..orders&quot;2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;createtime&quot;, data type 93, in table &quot;mybatis001..orders&quot;2016-02-27 16:29:46,551 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;note&quot;, data type 12, in table &quot;mybatis001..orders&quot;2016-02-27 16:29:46,577 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Retrieving column information for table &quot;orderdetail&quot;2016-02-27 16:29:46,630 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;id&quot;, data type 4, in table &quot;mybatis001..orderdetail&quot;2016-02-27 16:29:46,630 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;orders_id&quot;, data type 4, in table &quot;mybatis001..orderdetail&quot;2016-02-27 16:29:46,631 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;items_id&quot;, data type 4, in table &quot;mybatis001..orderdetail&quot;2016-02-27 16:29:46,631 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;items_num&quot;, data type 4, in table &quot;mybatis001..orderdetail&quot;2016-02-27 16:29:46,656 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Retrieving column information for table &quot;user&quot;2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;id&quot;, data type 4, in table &quot;mybatis001..user&quot;2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;username&quot;, data type 12, in table &quot;mybatis001..user&quot;2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;birthday&quot;, data type 91, in table &quot;mybatis001..user&quot;2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;sex&quot;, data type 1, in table &quot;mybatis001..user&quot;2016-02-27 16:29:46,706 [main] DEBUG [org.mybatis.generator.internal.db.DatabaseIntrospector] - Found column &quot;address&quot;, data type 12, in table &quot;mybatis001..user&quot; 生成后的代码： 逆向工程 使用生成的代码需要将生成工程中所生成的代码拷贝到自己的工程中。 测试ItemsMapper中的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.iot.ssm.mapper;import static org.junit.Assert.*;import java.util.Date;import java.util.List;import com.iot.ssm.po.Items;import com.iot.ssm.po.ItemsExample;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ItemsMapperTest &#123; private ApplicationContext applicationContext; private ItemsMapper itemsMapper; //在setUp这个方法得到spring容器 @Before public void setUp() throws Exception &#123; applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext.xml\"); itemsMapper = (ItemsMapper) applicationContext.getBean(\"itemsMapper\"); &#125; //根据主键删除 @Test public void testDeleteByPrimaryKey() &#123; &#125; //插入 @Test public void testInsert() &#123; //构造 items对象 Items items = new Items(); items.setName(\"手机\"); items.setPrice(999f); items.setCreatetime(new Date()); itemsMapper.insert(items); &#125; //自定义条件查询 @Test public void testSelectByExample() &#123; ItemsExample itemsExample = new ItemsExample(); //通过criteria构造查询条件 ItemsExample.Criteria criteria = itemsExample.createCriteria(); criteria.andNameEqualTo(\"笔记本\"); //可能返回多条记录 List&lt;Items&gt; list = itemsMapper.selectByExample(itemsExample); System.out.println(list); &#125; //根据主键查询 @Test public void testSelectByPrimaryKey() &#123; Items items = itemsMapper.selectByPrimaryKey(1); System.out.println(items); &#125; //更新数据 @Test public void testUpdateByPrimaryKey() &#123; //对所有字段进行更新，需要先查询出来再更新 Items items = itemsMapper.selectByPrimaryKey(1); items.setName(\"手机\"); itemsMapper.updateByPrimaryKey(items); //如果传入字段不空为才更新，在批量更新中使用此方法，不需要先查询再更新 //itemsMapper.updateByPrimaryKeySelective(record); &#125;&#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(17)-spring和mybatis整合","date":"2016-03-07T18:39:17.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-17-integrate-spring/","text":"本文主要将如何将spring和mybatis整合，只是作简单的示例，没有使用Maven构建。并展示mybatis与spring整合后如何进行原始dao开发和mapper代理开发。 整合思路需要spring通过单例方式管理SqlSessionFactory。 spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession。（spring和mybatis整合自动完成） 持久层的mapper都需要由spring进行管理。 整合环境创建一个新的java工程（接近实际开发的工程结构） jar包： mybatis3.2.7的jar包 spring3.2.0的jar包 mybatis和spring的整合包：早期ibatis和spring整合是由spring官方提供，mybatis和spring整合由mybatis提供。 mybatis与spring整合工程结构图 sqlSessionFactory在applicationContext.xml配置sqlSessionFactory和数据源 sqlSessionFactory在mybatis和spring的整合包下。 1234567891011121314151617181920212223242526272829303132333435363738&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \"&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=\"classpath:db.properties\" /&gt; &lt;!-- 数据源，使用dbcp --&gt; &lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;property name=\"maxActive\" value=\"10\" /&gt; &lt;property name=\"maxIdle\" value=\"5\" /&gt; &lt;/bean&gt; &lt;!-- sqlSessinFactory --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 加载mybatis的配置文件 --&gt; &lt;property name=\"configLocation\" value=\"mybatis/SqlMapConfig.xml\" /&gt; &lt;!-- 数据源 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 原始dao开发(和spring整合后) User.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=\"test\"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!--需求:通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id:标识映射文件中的sql，称为statement的id 将sql语句封装到mappedStatement对象中，所以将id称为statement的id parameterType:指定输入参数的类型 #&#123;&#125;标示一个占位符, #&#123;value&#125;其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#&#123;&#125;中的值可以任意。 resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.ssm.po.User\"&gt; SELECT * FROM user WHERE id=#&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; 在SqlMapconfig.xml中加载User.xml 1234 &lt;!-- 加载映射文件--&gt;&lt;mappers&gt; &lt;mapper resource=\"sqlmap/User.xml\"/&gt;&lt;/mappers&gt; dao(实现类继承SqlSessionDaoSupport) 1234public interface UserDao &#123; //根据id查询用户信息 public User findUserById(int id) throws Exception;&#125; dao接口实现类需要注入SqlSessoinFactory，通过spring进行注入。这里spring声明配置方式，配置dao的bean 让UserDaoImpl实现类继承SqlSessionDaoSupport 12345678910111213public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao&#123; @Override public User findUserById(int id) throws Exception &#123; //继承SqlSessionDaoSupport，通过this.getSqlSession()得到sqlSessoin SqlSession sqlSession = this.getSqlSession(); User user = sqlSession.selectOne(\"test.findUserById\",id); return user; &#125;&#125; 配置dao 在applicationContext.xml中配置dao 1234&lt;!-- 原始dao接口 --&gt;&lt;bean id=\"userDao\" class=\"com.iot.ssm.dao.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; 测试程序 12345678910111213141516171819202122public class UserDaoImplTest &#123; private ApplicationContext applicationContext; //在setUp这个方法得到spring容器 @Before public void setUp() throws Exception &#123; applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext.xml\"); &#125; @Test public void testFindUserById() throws Exception &#123; // 创建UserDao的对象 UserDao userDao = (UserDao)applicationContext.getBean(\"userDao\"); // 调用UserDao的方法 User user = userDao.findUserById(1); System.out.println(user); &#125;&#125; mapper代理开发 mapper.java 12345public interface UserMapper &#123; //根据id查询用户信息 User findUserById(int id) throws Exception;&#125; mapper.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=\"com.iot.ssm.mapper.UserMapper\"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"user\"&gt; SELECT * FROM user WHERE id=#&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; 通过MapperFactoryBean创建代理对象 123456789 &lt;!-- mapper配置 MapperFactoryBean：根据mapper接口生成代理对象 --&gt;&lt;bean id=\"userMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; //mapperInterface指定mapper接口 &lt;property name=\"mapperInterface\" value=\"com.iot.ssm.mapper.UserMapper\"/&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; 此方法问题：需要针对每个mapper进行配置，麻烦。 通过MapperScannerConfigurer进行mapper扫描（建议使用） 123456789101112&lt;!-- mapper批量扫描，从mapper包中扫描出mapper接口，自动创建代理对象并且在spring容器中注册 遵循规范：将mapper.java和mapper.xml映射文件名称保持一致，且在一个目录 中 自动扫描出来的mapper的bean的id为mapper类名（首字母小写） --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 指定扫描的包名 如果扫描多个包，每个包中间使用半角逗号分隔 --&gt; &lt;property name=\"basePackage\" value=\"com.iot.ssm.mapper\"/&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; 测试代码 123456789101112131415161718192021222324252627282930313233343536package com.iot.mybatis.mapper;import com.iot.ssm.mapper.UserMapper;import com.iot.ssm.po.User;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class UserMapperTest &#123; private ApplicationContext applicationContext; //在setUp这个方法得到spring容器 @Before public void setUp() throws Exception &#123; applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext.xml\"); &#125; @Test public void testFindUserById() throws Exception &#123; UserMapper userMapper = (UserMapper)applicationContext.getBean(\"userMapper\"); //调用userMapper的方法 User user = userMapper.findUserById(1); System.out.println(user); &#125;&#125; 遇到的问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647org.springframework.beans.factory.BeanDefinitionStoreException: Failed to read candidate component class: file [D:\\intellij\\workspace\\spring-mybatis\\out\\production\\spring-mybatis\\com\\iot\\ssm\\mapper\\UserMapper.class]; nested exception is java.lang.IllegalArgumentException at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:281) at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.doScan(ClassPathBeanDefinitionScanner.java:242) at org.mybatis.spring.mapper.ClassPathMapperScanner.doScan(ClassPathMapperScanner.java:155) at org.springframework.context.annotation.ClassPathBeanDefinitionScanner.scan(ClassPathBeanDefinitionScanner.java:220) at org.mybatis.spring.mapper.MapperScannerConfigurer.postProcessBeanDefinitionRegistry(MapperScannerConfigurer.java:315) at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:630) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:461) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83) at com.iot.mybatis.mapper.UserMapperTest.setUp(UserMapperTest.java:17) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:27) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:69) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:48) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222) at org.junit.runners.ParentRunner.run(ParentRunner.java:292) at org.junit.runner.JUnitCore.run(JUnitCore.java:157) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)Caused by: java.lang.IllegalArgumentException at org.springframework.asm.ClassReader.&lt;init&gt;(Unknown Source) at org.springframework.asm.ClassReader.&lt;init&gt;(Unknown Source) at org.springframework.asm.ClassReader.&lt;init&gt;(Unknown Source) at org.springframework.core.type.classreading.SimpleMetadataReader.&lt;init&gt;(SimpleMetadataReader.java:52) at org.springframework.core.type.classreading.SimpleMetadataReaderFactory.getMetadataReader(SimpleMetadataReaderFactory.java:80) at org.springframework.core.type.classreading.CachingMetadataReaderFactory.getMetadataReader(CachingMetadataReaderFactory.java:101) at org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:257) ... 35 more 搜到的答案 BeanDefinitionStoreException Failed to read candidate component class Failed to read candidate component错误 总结起来就是java 8 和spring 3 不能一起用，我在IDEA的project settings里把project language level换成7就好了。具体原因还不清楚","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://brianway.github.io/tags/SpringMVC/"}]},{"title":"mybatis学习笔记(16)-mybatis整合ehcache","date":"2016-03-07T18:39:16.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-16-ehcache/","text":"ehcache是一个分布式缓存框架 分布缓存我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式） 分布缓存 不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统开发。所以要使用分布式缓存对缓存数据进行集中管理。 mybatis无法实现分布式缓存，需要和其它分布式缓存框架进行整合。 整合方法(掌握)mybatis提供了一个cache接口，如果要实现自己的缓存逻辑，实现cache接口开发即可。 mybatis和ehcache整合，mybatis和ehcache整合包中提供了一个cache接口的实现类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package org.apache.ibatis.cache;import java.util.concurrent.locks.ReadWriteLock;/** * SPI for cache providers. * * One instance of cache will be created for each namespace. * * The cache implementation must have a constructor that receives the cache id as an String parameter. * * MyBatis will pass the namespace as id to the constructor. * * &lt;pre&gt; * public MyCache(final String id) &#123; * if (id == null) &#123; * throw new IllegalArgumentException(\"Cache instances require an ID\"); * &#125; * this.id = id; * initialize(); * &#125; * &lt;/pre&gt; * * @author Clinton Begin */public interface Cache &#123; /** * @return The identifier of this cache */ String getId(); /** * @param key Can be any object but usually it is a &#123;@link CacheKey&#125; * @param value The result of a select. */ void putObject(Object key, Object value); /** * @param key The key * @return The object stored in the cache. */ Object getObject(Object key); /** * Optional. It is not called by the core. * * @param key The key * @return The object that was removed */ Object removeObject(Object key); /** * Clears this cache instance */ void clear(); /** * Optional. This method is not called by the core. * * @return The number of elements stored in the cache (not its capacity). */ int getSize(); /** * Optional. As of 3.2.6 this method is no longer called by the core. * * Any locking needed by the cache must be provided internally by the cache provider. * * @return A ReadWriteLock */ ReadWriteLock getReadWriteLock();&#125; mybatis默认实现cache类是： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package org.apache.ibatis.cache.impl;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.ReadWriteLock;import org.apache.ibatis.cache.Cache;import org.apache.ibatis.cache.CacheException;/** * @author Clinton Begin */public class PerpetualCache implements Cache &#123; private String id; private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); public PerpetualCache(String id) &#123; this.id = id; &#125; public String getId() &#123; return id; &#125; public int getSize() &#123; return cache.size(); &#125; public void putObject(Object key, Object value) &#123; cache.put(key, value); &#125; public Object getObject(Object key) &#123; return cache.get(key); &#125; public Object removeObject(Object key) &#123; return cache.remove(key); &#125; public void clear() &#123; cache.clear(); &#125; public ReadWriteLock getReadWriteLock() &#123; return null; &#125; public boolean equals(Object o) &#123; if (getId() == null) throw new CacheException(\"Cache instances require an ID.\"); if (this == o) return true; if (!(o instanceof Cache)) return false; Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); &#125; public int hashCode() &#123; if (getId() == null) throw new CacheException(\"Cache instances require an ID.\"); return getId().hashCode(); &#125;&#125; 整合ehcache 加入ehcache包 ehcache-core-2.6.5.jar mybatis-ehcache-1.0.2.jar 配置mapper中cache中的type为ehcache对cache接口的实现类型 123456&lt;!-- 开启本mapper的namespace下的二级缓存 type：指定cache接口的实现类的类型，mybatis默认使用PerpetualCache 要和ehcache整合，需要配置type为ehcache实现cache接口的类型 &lt;cache /&gt; --&gt; &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/&gt; 加入ehcache的配置文件在classpath下配置ehcache.xml 1234567891011121314&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../config/ehcache.xsd\"&gt; &lt;diskStore path=\"F:\\develop\\ehcache\" /&gt; &lt;defaultCache maxElementsInMemory=\"1000\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"缓存","slug":"缓存","permalink":"https://brianway.github.io/tags/缓存/"}]},{"title":"mybatis学习笔记(15)-查询缓存之二级缓存","date":"2016-03-07T18:39:15.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-15-Secondary-Cache/","text":"本文主要讲mybatis的二级缓存，二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 二级缓存原理 首先开启mybatis的二级缓存. sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中。 如果SqlSession3去执行相同mapper下sql，执行commit提交，清空该mapper下的二级缓存区域的数据。 sqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据。 二级缓存与一级缓存区别，二级缓存的范围更大，多个sqlSession可以共享一个UserMapper的二级缓存区域。 UserMapper有一个二级缓存区域（按namespace分），其它mapper也有自己的二级缓存区域（按namespace分）。每一个namespace的mapper都有一个二缓存区域，两个mapper的namespace如果相同，这两个mapper执行sql查询到数据将存在相同的二级缓存区域中。 开启二级缓存mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。 在核心配置文件SqlMapConfig.xml中加入&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 设置项 描述 允许值 默认值 cacheEnabled 对在此配置文件下的所有cache 进行全局性开/关设置。 true/false true 12&lt;!-- 开启二级缓存 --&gt;&lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; 在UserMapper.xml中开启二缓存，UserMapper.xml下的sql执行完成会存储到它的缓存区域（HashMap）。 1234567&lt;mapper namespace=\"com.iot.mybatis.mapper.UserMapper\"&gt;&lt;!-- 开启本mapper的namespace下的二级缓存--&gt;&lt;cache /&gt;...&lt;/mapper&gt; 调用pojo类实现序列化接口123public class User implements Serializable&#123; ....&#125; 为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存。 测试方法12345678910111213141516171819202122232425262728293031323334// 二级缓存测试@Testpublic void testCache2() throws Exception &#123; SqlSession sqlSession1 = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); SqlSession sqlSession3 = sqlSessionFactory.openSession(); // 创建代理对象 UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class); // 第一次发起请求，查询id为1的用户 User user1 = userMapper1.findUserById(1); System.out.println(user1); //这里执行关闭操作，将sqlsession中的数据写到二级缓存区域 sqlSession1.close();// //使用sqlSession3执行commit()操作// UserMapper userMapper3 = sqlSession3.getMapper(UserMapper.class);// User user = userMapper3.findUserById(1);// user.setUsername(\"张明明\");// userMapper3.updateUser(user);// //执行提交，清空UserMapper下边的二级缓存// sqlSession3.commit();// sqlSession3.close(); UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class); // 第二次发起请求，查询id为1的用户 User user2 = userMapper2.findUserById(1); System.out.println(user2); sqlSession2.close();&#125; 1.无更新，输出 12345678910111213DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.0DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 103887628.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User [id=1, username=测试用户22, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Returned connection 103887628 to pool.DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.5User [id=1, username=测试用户22, sex=2, birthday=null, address=null] 2.有更新，输出 123456789101112131415161718192021222324252627282930313233DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.0DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 103887628.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User [id=1, username=测试用户22, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Returned connection 103887628 to pool.DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.5DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Checked out connection 103887628 from pool.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - ==&gt; Preparing: update user set username=?,birthday=?,sex=?,address=? where id=?DEBUG [main] - ==&gt; Parameters: 张明明(String), null, 2(String), null, 1(Integer)DEBUG [main] - &lt;== Updates: 1DEBUG [main] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Returned connection 103887628 to pool.DEBUG [main] - Cache Hit Ratio [com.iot.mybatis.mapper.UserMapper]: 0.3333333333333333DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Checked out connection 103887628 from pool.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User [id=1, username=张明明, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@631330c]DEBUG [main] - Returned connection 103887628 to pool. useCache配置在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。 &lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt; 总结：针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。 刷新缓存（就是清空缓存）刷新缓存就是清空缓存。在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。 设置statement配置中的flushCache=&quot;true&quot;属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。如下： &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot; flushCache=&quot;true&quot;&gt; 总结：一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。 应用场景和局限性 应用场景 对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。 实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。 局限性 mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"缓存","slug":"缓存","permalink":"https://brianway.github.io/tags/缓存/"}]},{"title":"mybatis学习笔记(14)-查询缓存之一级缓存","date":"2016-03-07T18:39:14.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-14-Cache/","text":"本文主要讲mybatis的一级缓存，一级缓存是SqlSession级别的缓存。 查询缓存mybatis提供查询缓存，用于减轻数据压力，提高数据库性能。 mybaits提供一级缓存，和二级缓存。 查询缓存 一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。 二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 为什么要用缓存？ 如果缓存中有数据就不用从数据库中获取，大大提高系统性能。 一级缓存一级缓存工作原理 一级缓存工作原理 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。 一级缓存测试mybatis默认支持一级缓存，不需要在配置文件去配置。 按照上边一级缓存原理步骤去测试。 测试代码 1234567891011121314151617181920212223242526// 一级缓存测试@Testpublic void testCache1() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession();// 创建代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); // 下边查询使用一个SqlSession // 第一次发起请求，查询id为1的用户 User user1 = userMapper.findUserById(1); System.out.println(user1); // 如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 // 更新user1的信息 // user1.setUsername(\"测试用户22\"); // userMapper.updateUser(user1); // //执行commit操作去清空缓存 // sqlSession.commit(); // 第二次发起请求，查询id为1的用户 User user2 = userMapper.findUserById(1); System.out.println(user2); sqlSession.close();&#125; 1.不执行更新操作，输出: 1234567891011DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 110771485.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User [id=1, username=王五, sex=2, birthday=null, address=null]User [id=1, username=王五, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - Returned connection 110771485 to pool. 2.取消测试代码中更新的的注释，输出： 123456789101112131415161718DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 110771485.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User [id=1, username=王五, sex=2, birthday=null, address=null]DEBUG [main] - ==&gt; Preparing: update user set username=?,birthday=?,sex=?,address=? where id=?DEBUG [main] - ==&gt; Parameters: 测试用户22(String), null, 2(String), null, 1(Integer)DEBUG [main] - &lt;== Updates: 1DEBUG [main] - Committing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User [id=1, username=测试用户22, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - Returned connection 110771485 to pool. 一级缓存应用正式开发，是将mybatis和spring进行整合开发，事务控制在service中。 一个service方法中包括 很多mapper方法调用。 1234567service&#123; //开始执行时，开启事务，创建SqlSession对象 //第一次调用mapper的方法findUserById(1) //第二次调用mapper的方法findUserById(1)，从一级缓存中取数据 //方法结束，sqlSession关闭&#125; 如果是执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"缓存","slug":"缓存","permalink":"https://brianway.github.io/tags/缓存/"}]},{"title":"mybatis学习笔记(13)-延迟加载","date":"2016-03-07T18:39:13.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-13-lazeloading/","text":"resultMap可以实现高级映射（使用association、collection实现一对一及一对多映射），association、collection具备延迟加载功能。 延迟加载：先从单表查询、需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。 需求： 如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载。 使用association实现延迟加载 mapper.xml 需要定义两个mapper的方法对应的statement。 1.只查询订单信息 SELECT * FROM orders 在查询订单的statement中使用association去延迟加载（执行）下边的satatement(关联查询用户信息) 1234&lt;!-- 查询订单关联查询用户，用户信息需要延迟加载 --&gt;&lt;select id=\"findOrdersUserLazyLoading\" resultMap=\"OrdersUserLazyLoadingResultMap\"&gt; SELECT * FROM orders&lt;/select&gt; 2.关联查询用户信息 通过上边查询到的订单信息中user_id去关联查询用户信息,使用UserMapper.xml中的findUserById 123&lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.mybatis.po.User\"&gt; SELECT * FROM user WHERE id=#&#123;value&#125;&lt;/select&gt; 上边先去执行findOrdersUserLazyLoading，当需要去查询用户的时候再去执行findUserById，通过resultMap的定义将延迟加载执行配置起来。 延迟加载resultMap 1234567891011121314151617181920212223242526&lt;!-- 延迟加载的resultMap --&gt;&lt;resultMap type=\"com.iot.mybatis.po.Orders\" id=\"OrdersUserLazyLoadingResultMap\"&gt; &lt;!--对订单信息进行映射配置 --&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;result column=\"createtime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;!-- 实现对用户信息进行延迟加载 select：指定延迟加载需要执行的statement的id（是根据user_id查询用户信息的statement） 要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询，如果findUserById不在本mapper中需要前边加namespace column：订单信息中关联用户信息查询的列，是user_id 关联查询的sql理解为： SELECT orders.*, (SELECT username FROM USER WHERE orders.user_id = user.id)username, (SELECT sex FROM USER WHERE orders.user_id = user.id)sex FROM orders --&gt; &lt;association property=\"user\" javaType=\"com.iot.mybatis.po.User\" select=\"com.iot.mybatis.mapper.UserMapper.findUserById\" column=\"user_id\"&gt; &lt;!-- 实现对用户信息进行延迟加载 --&gt; &lt;/association&gt;&lt;/resultMap&gt; 与非延迟加载的主要区别就在association标签属性多了select和column 123&lt;association property=\"user\" javaType=\"com.iot.mybatis.po.User\" select=\"com.iot.mybatis.mapper.UserMapper.findUserById\" column=\"user_id\"&gt; mapper.java 12//查询订单关联查询用户，用户信息是延迟加载public List&lt;Orders&gt; findOrdersUserLazyLoading()throws Exception; 测试思路 执行上边mapper方法(findOrdersUserLazyLoading)，内部去调用com.iot.mybatis.mapper.OrdersMapperCustom中的findOrdersUserLazyLoading只查询orders信息（单表）。 在程序中去遍历上一步骤查询出的List，当我们调用Orders中的getUser方法时，开始进行延迟加载。 延迟加载，去调用UserMapper.xml中findUserbyId这个方法获取用户信息。 延迟加载配置 mybatis默认没有开启延迟加载，需要在SqlMapConfig.xml中setting配置。 在mybatis核心配置文件中配置：lazyLoadingEnabled、aggressiveLazyLoading 设置项 描述 允许值 默认值 lazyLoadingEnabled 全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载 true/false false aggressiveLazyLoading 当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。 true/false true 在SqlMapConfig.xml中配置： 12345678&lt;settings&gt; &lt;!-- 打开延迟加载 的开关 --&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!-- 将积极加载改为消极加载即按需要加载 --&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;!-- 开启二级缓存 --&gt; &lt;!-- &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;--&gt;&lt;/settings&gt; 测试代码 12345678910111213141516// 查询订单关联查询用户，用户信息使用延迟加载@Testpublic void testFindOrdersUserLazyLoading() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession();// 创建代理对象 OrdersMapperCustom ordersMapperCustom = sqlSession .getMapper(OrdersMapperCustom.class); // 查询订单信息（单表） List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserLazyLoading(); // 遍历上边的订单列表 for (Orders orders : list) &#123; // 执行getUser()去查询用户信息，这里实现按需加载 User user = orders.getUser(); System.out.println(user); &#125;&#125; 延迟加载思考不使用mybatis提供的association及collection中的延迟加载功能，如何实现延迟加载？？ 实现方法如下： 定义两个mapper方法： 查询订单列表 根据用户id查询用户信息 实现思路： 先去查询第一个mapper方法，获取订单信息列表；在程序中（service），按需去调用第二个mapper方法去查询用户信息。 总之，使用延迟加载方法，先去查询简单的sql（最好单表，也可以关联查询），再去按需要加载关联查询的其它信息。 IDEA的debug小现象使用的是intellij IDEA 15.0.2 先说一下结果吧，IDEA在debug和run条件下，打印结果不同 我为了验证延迟加载前的user是否为空，在Orders类中加入了 123public void print()&#123; System.out.println(\"----test-print-----\"+user+\" user==null: \"+(user==null));&#125; 测试代码如下： 123456789101112131415161718// 查询订单关联查询用户，用户信息使用延迟加载@Testpublic void testFindOrdersUserLazyLoading() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession();// 创建代理对象 OrdersMapperCustom ordersMapperCustom = sqlSession .getMapper(OrdersMapperCustom.class); // 查询订单信息（单表） List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserLazyLoading(); // 遍历上边的订单列表 for (Orders orders : list) &#123; // 执行getUser()去查询用户信息，这里实现按需加载 //User user = orders.getUser(); //System.out.println(user); orders.print(); &#125;&#125; 然后分别run和debug run输出 123456789DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 110771485.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@69a3d1d]DEBUG [main] - ==&gt; Preparing: SELECT * FROM ordersDEBUG [main] - ==&gt; Parameters:DEBUG [main] - &lt;== Total: 3----test-print-----null user==null: true----test-print-----null user==null: true----test-print-----null user==null: true debug输出 在List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserLazyLoading();打断点，运行完这句,日志输出为： 123456DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 1219273867.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@48aca48b]DEBUG [main] - ==&gt; Preparing: SELECT * FROM ordersDEBUG [main] - ==&gt; Parameters:DEBUG [main] - &lt;== Total: 3 但是当你点开list属性时，控制台又输出了，而且可以看到list里的user是有内容的 123456DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 10(Integer)DEBUG [main] - &lt;== Total: 1 运行完所有程序，控制台输出为： 123456789101112131415DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 1219273867.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@48aca48b]DEBUG [main] - ==&gt; Preparing: SELECT * FROM ordersDEBUG [main] - ==&gt; Parameters:DEBUG [main] - &lt;== Total: 3DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 10(Integer)DEBUG [main] - &lt;== Total: 1----test-print-----User [id=1, username=王五, sex=2, birthday=null, address=null] user==null: false----test-print-----User [id=1, username=王五, sex=2, birthday=null, address=null] user==null: false----test-print-----User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市] user==null: false 所以，我觉得应该是在debug时，查看属性的话，IDEA会自动调用get相应的方法，从而触发user的查询。延迟加载的源码实现以后我会阅读，把这个问题弄清楚。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(12)-多对多查询","date":"2016-03-07T18:39:12.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-12-many-to-many/","text":"本文实现多对多查询，查询用户及用户购买商品信息。 示例查询主表是：用户表 关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：orders、orderdetail、items sql 123456789101112131415161718SELECT orders.*, user.username, user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id, items.name items_name, items.detail items_detail, items.price items_priceFROM orders, user, orderdetail, itemsWHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id 映射思路 将用户信息映射到user中。 在user类中添加订单列表属性List&lt;Orders&gt; orderslist，将用户创建的订单映射到orderslist 在Orders中添加订单明细列表属性List&lt;OrderDetail&gt;orderdetials，将订单的明细映射到orderdetials 在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items mapper.xml 123456789101112131415161718192021&lt;!-- 查询用户及购买的商品信息，使用resultmap --&gt;&lt;select id=\"findUserAndItemsResultMap\" resultMap=\"UserAndItemsResultMap\"&gt; SELECT orders.*, user.username, user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id, items.name items_name, items.detail items_detail, items.price items_price FROM orders, user, orderdetail, items WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id&lt;/select&gt; resultMap 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 查询用户及购买的商品 --&gt;&lt;resultMap type=\"com.iot.mybatis.po.User\" id=\"UserAndItemsResultMap\"&gt; &lt;!-- 用户信息 --&gt; &lt;id column=\"user_id\" property=\"id\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;result column=\"address\" property=\"address\"/&gt; &lt;!-- 订单信息 一个用户对应多个订单，使用collection映射 --&gt; &lt;collection property=\"ordersList\" ofType=\"com.iot.mybatis.po.Orders\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;result column=\"createtime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;!-- 订单明细 一个订单包括 多个明细 --&gt; &lt;collection property=\"orderdetails\" ofType=\"com.iot.mybatis.po.Orderdetail\"&gt; &lt;id column=\"orderdetail_id\" property=\"id\"/&gt; &lt;result column=\"items_id\" property=\"itemsId\"/&gt; &lt;result column=\"items_num\" property=\"itemsNum\"/&gt; &lt;result column=\"orders_id\" property=\"ordersId\"/&gt; &lt;!-- 商品信息 一个订单明细对应一个商品 --&gt; &lt;association property=\"items\" javaType=\"com.iot.mybatis.po.Items\"&gt; &lt;id column=\"items_id\" property=\"id\"/&gt; &lt;result column=\"items_name\" property=\"name\"/&gt; &lt;result column=\"items_detail\" property=\"detail\"/&gt; &lt;result column=\"items_price\" property=\"price\"/&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/collection&gt;&lt;/resultMap&gt; mapper.java 12//查询用户购买商品信息public List&lt;User&gt; findUserAndItemsResultMap()throws Exception; 多对多查询总结将查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量） 针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。 一对多是多对多的特例，如下需求： 查询用户购买的商品信息，用户和商品的关系是多对多关系。 需求1： 查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见) 企业开发中常见明细列表，用户购买商品明细列表， 使用resultType将上边查询列映射到pojo输出。 需求2： 查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细） 使用resultMap将用户购买的商品明细列表映射到user对象中。 总结： 使用resultMap是针对那些对查询结果映射有特殊要求的功能，比如特殊要求映射成list中包括多个list。 resultMap总结 resultType 作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。 场合：常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。 resultMap 使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。 association： 作用：将关联查询信息映射到一个pojo对象中。 场合：为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。 使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。 collection： 作用：将关联查询信息映射到一个list集合中。 场合：为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。如果使用resultType无法将查询结果映射到list集合中。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(11)-一对多查询","date":"2016-03-07T18:39:11.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-11-one-to-many/","text":"本文实现一对多查询，查询订单及订单明细的信息 示例 sql 确定主查询表：订单表确定关联查询表：订单明细表在一对一查询基础上添加订单明细表关联即可。 1234567891011121314SELECT orders.*, user.username, user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_idFROM orders, user, orderdetailWHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id 注意上面的orderdetail.id (AS) orderdetail_id,这里需要取别名，否则由于orders表也有id字段，在后面映射时会冲突 映射思路 使用resultType将上边的查询结果映射到pojo中，订单信息的就是重复。 对orders映射不能出现重复记录。 在orders.java类中添加List&lt;orderDetail&gt; orderDetails属性。最终会将订单信息映射到orders中，订单所对应的订单明细映射到orders中的orderDetails属性中。 映射成的orders记录数为两条（orders信息不重复）,每个orders中的orderDetails属性存储了该订单所对应的订单明细。 在orders中添加list订单明细属性 12//订单明细private List&lt;Orderdetail&gt; orderdetails; mapper.xml 1234567891011121314151617&lt;!-- 查询订单关联查询用户及订单明细，使用resultmap --&gt;&lt;select id=\"findOrdersAndOrderDetailResultMap\" resultMap=\"OrdersAndOrderDetailResultMap\"&gt; SELECT orders.*, user.username, user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id FROM orders, user, orderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id&lt;/select&gt; resultMap定义 1234567891011121314151617181920212223242526&lt;!-- 订单及订单明细的resultMap使用extends继承，不用在中配置订单信息和用户信息的映射 --&gt;&lt;resultMap type=\"com.iot.mybatis.po.Orders\" id=\"OrdersAndOrderDetailResultMap\" extends=\"OrdersUserResultMap\"&gt; &lt;!-- 订单信息 --&gt; &lt;!-- 用户信息 --&gt; &lt;!-- 使用extends继承，不用在中配置订单信息和用户信息的映射 --&gt; &lt;!-- 订单明细信息 一个订单关联查询出了多条明细，要使用collection进行映射 collection：对关联查询到多条记录映射到集合对象中 property：将关联查询到多条记录映射到com.iot.mybatis.po.Orders哪个属性 ofType：指定映射到list集合属性中pojo的类型 --&gt; &lt;collection property=\"orderdetails\" ofType=\"com.iot.mybatis.po.Orderdetail\"&gt; &lt;!-- id：订单明细唯 一标识 property:要将订单明细的唯 一标识 映射到com.iot.mybatis.po.Orderdetail的哪个属性 --&gt; &lt;id column=\"orderdetail_id\" property=\"id\"/&gt; &lt;result column=\"items_id\" property=\"itemsId\"/&gt; &lt;result column=\"items_num\" property=\"itemsNum\"/&gt; &lt;result column=\"orders_id\" property=\"ordersId\"/&gt; &lt;/collection&gt;&lt;/resultMap&gt; mapper.java 12//查询订单(关联用户)及订单明细public List&lt;Orders&gt; findOrdersAndOrderDetailResultMap()throws Exception; 小结mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性中。 使用resultType实现：将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中。 另外，下面这篇文章对一对多的resultMap机制解释的很清楚： MyBatis：一对多表关系详解(从案例中解析)","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(10)-一对一查询","date":"2016-03-07T18:39:10.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-10-one-to-one/","text":"本文使用两种方式(resultType和resultMap)实现一对一查询，查询订单信息，关联查询创建订单的用户信息 resultType实现 sql语句 确定查询的主表：订单表 确定查询的关联表：用户表 关联查询使用内连接？还是外连接？ 由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内连接。 123456789SELECT orders.*, USER.username, USER.sex, USER.addressFROM orders, USERWHERE orders.user_id = user.id 创建pojo 将上边sql查询的结果映射到pojo中，pojo中必须包括所有查询列名。 原始的Orders.java不能映射全部字段，需要新创建的pojo。 创建一个pojo继承包括查询字段较多的po类。 对应数据表的几个pojo类(Items,Orderdetail,Orders)就是把该类的属性名设为和数据表列字段名相同，并为这些属性添加getter和setter，在这里就不贴代码了，只贴出对应于关联查询的自定义pojo类OrdersCustom的代码 123456789101112131415161718192021222324252627282930313233343536373839404142package com.iot.mybatis.po;/** * * &lt;p&gt;Title: OrdersCustom&lt;/p&gt; * &lt;p&gt;Description: 订单的扩展类&lt;/p&gt; *///通过此类映射订单和用户查询的结果，让此类继承包括 字段较多的pojo类public class OrdersCustom extends Orders&#123; //添加用户属性 /*USER.username, USER.sex, USER.address */ private String username; private String sex; private String address; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; mapper.xml 123456789101112 &lt;!-- 查询订单关联查询用户信息 --&gt;&lt;select id=\"findOrdersUser\" resultType=\"com.iot.mybatis.po.OrdersCustom\"&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id&lt;/select&gt; mapper.java 123//查询订单关联查询用户信息public List&lt;OrdersCustom&gt; findOrdersUser()throws Exception;&#125; resultMap实现使用resultMap将查询结果中的订单信息映射到Orders对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到orders对象中的user属性中。 定义resultMap 123456789101112131415161718192021222324252627282930&lt;!-- 订单查询关联用户的resultMap将整个查询的结果映射到com.iot.mybatis.po.Orders中 --&gt;&lt;resultMap type=\"com.iot.mybatis.po.Orders\" id=\"OrdersUserResultMap\"&gt; &lt;!-- 配置映射的订单信息 --&gt; &lt;!-- id：指定查询列中的唯一标识，订单信息的中的唯 一标识，如果有多个列组成唯一标识，配置多个id column：订单信息的唯一标识列 property：订单信息的唯一标识列所映射到Orders中哪个属性 --&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"user_id\" property=\"userId\"/&gt; &lt;result column=\"number\" property=\"number\"/&gt; &lt;result column=\"createtime\" property=\"createtime\"/&gt; &lt;result column=\"note\" property=\"note\"/&gt; &lt;!-- 配置映射的关联的用户信息 --&gt; &lt;!-- association：用于映射关联查询单个对象的信息 property：要将关联查询的用户信息映射到Orders中哪个属性 --&gt; &lt;association property=\"user\" javaType=\"com.iot.mybatis.po.User\"&gt; &lt;!-- id：关联查询用户的唯 一标识 column：指定唯 一标识用户信息的列 javaType：映射到user的哪个属性 --&gt; &lt;id column=\"user_id\" property=\"id\"/&gt; &lt;result column=\"username\" property=\"username\"/&gt; &lt;result column=\"sex\" property=\"sex\"/&gt; &lt;result column=\"address\" property=\"address\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; statement定义 123456789101112&lt;!-- 查询订单关联查询用户信息 --&gt;&lt;select id=\"findOrdersUserResultMap\" resultMap=\"OrdersUserResultMap\"&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id&lt;/select&gt; mapper.java 12//查询订单关联查询用户使用resultMappublic List&lt;Orders&gt; findOrdersUserResultMap()throws Exception; 测试代码 123456789101112131415@Testpublic void testFindOrdersUserResultMap() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); // 创建代理对象 OrdersMapperCustom ordersMapperCustom = sqlSession .getMapper(OrdersMapperCustom.class); // 调用maper的方法 List&lt;Orders&gt; list = ordersMapperCustom.findOrdersUserResultMap(); System.out.println(list); sqlSession.close();&#125; resultType和resultMap实现一对一查询小结实现一对一查询： resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。如果没有查询结果的特殊要求建议使用resultType。 resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。 resultMap可以实现延迟加载，resultType无法实现延迟加载。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(9)-订单商品数据模型分析","date":"2016-03-07T18:39:09.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-9-model-analysis/","text":"本文对接下来几篇博客中用到的数据模型进行分析，并附上建表sql文件和测试数据文件 数据模型分析思路 每张表记录的数据内容 分模块对每张表记录的内容进行熟悉，相当于你学习系统需求（功能）的过程。 每张表重要的字段设置 非空字段、外键字段 数据库级别表与表之间的关系 外键关系 表与表之间的业务关系 在分析表与表之间的业务关系时一定要建立在某个业务意义基础上去分析。 数据模型分析 用户表user：记录了购买商品的用户信息 订单表orders：记录了用户所创建的订单（购买商品的订单） 订单明细表orderdetail：记录了订单的详细信息即购买商品的信息 商品表items：记录了商品信息 表与表之间的业务关系： 在分析表与表之间的业务关系时需要建立在某个业务意义基础上去分析。先分析数据级别之间有关系的表之间的业务关系： usre和orders： user—&gt;orders：一个用户可以创建多个订单，一对多orders—&gt;user：一个订单只由一个用户创建，一对一 orders和orderdetail： orders—&gt;orderdetail：一个订单可以包括多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系 orderdetail—&gt; orders：一个订单明细只能包括在一个订单中，一对一 orderdetail和itesm： orderdetail—&gt;itesms：一个订单明细只对应一个商品信息，一对一 items—&gt; orderdetail:一个商品可以包括在多个订单明细 ，一对多 再分析数据库级别没有关系的表之间是否有业务关系： orders和items： orders和items之间可以通过orderdetail表建立关系。 订单商品数据模型建表sql123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*SQLyog v10.2MySQL - 5.1.72-community : Database - mybatis**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;/*Table structure for table `items` */CREATE TABLE `items` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) NOT NULL COMMENT '商品名称', `price` float(10,1) NOT NULL COMMENT '商品定价', `detail` text COMMENT '商品描述', `pic` varchar(64) DEFAULT NULL COMMENT '商品图片', `createtime` datetime NOT NULL COMMENT '生产日期', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;/*Table structure for table `orderdetail` */CREATE TABLE `orderdetail` ( `id` int(11) NOT NULL AUTO_INCREMENT, `orders_id` int(11) NOT NULL COMMENT '订单id', `items_id` int(11) NOT NULL COMMENT '商品id', `items_num` int(11) DEFAULT NULL COMMENT '商品购买数量', PRIMARY KEY (`id`), KEY `FK_orderdetail_1` (`orders_id`), KEY `FK_orderdetail_2` (`items_id`), CONSTRAINT `FK_orderdetail_1` FOREIGN KEY (`orders_id`) REFERENCES `orders` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION, CONSTRAINT `FK_orderdetail_2` FOREIGN KEY (`items_id`) REFERENCES `items` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;/*Table structure for table `orders` */CREATE TABLE `orders` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL COMMENT '下单用户id', `number` varchar(32) NOT NULL COMMENT '订单号', `createtime` datetime NOT NULL COMMENT '创建订单时间', `note` varchar(100) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`), KEY `FK_orders_1` (`user_id`), CONSTRAINT `FK_orders_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE NO ACTION ON UPDATE NO ACTION) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;/*Table structure for table `user` */CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) NOT NULL COMMENT '用户名称', `birthday` date DEFAULT NULL COMMENT '生日', `sex` char(1) DEFAULT NULL COMMENT '性别', `address` varchar(256) DEFAULT NULL COMMENT '地址', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=utf8;/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 测试数据 1234567891011121314151617181920212223242526272829303132333435/*SQLyog v10.2MySQL - 5.1.72-community : Database - mybatis**********************************************************************//*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;/*Data for the table `items` */insert into `items`(`id`,`name`,`price`,`detail`,`pic`,`createtime`) values (1,'台式机',3000.0,'该电脑质量非常好！！！！',NULL,'2015-02-03 13:22:53'),(2,'笔记本',6000.0,'笔记本性能好，质量好！！！！！',NULL,'2015-02-09 13:22:57'),(3,'背包',200.0,'名牌背包，容量大质量好！！！！',NULL,'2015-02-06 13:23:02');/*Data for the table `orderdetail` */insert into `orderdetail`(`id`,`orders_id`,`items_id`,`items_num`) values (1,3,1,1),(2,3,2,3),(3,4,3,4),(4,4,2,3);/*Data for the table `orders` */insert into `orders`(`id`,`user_id`,`number`,`createtime`,`note`) values (3,1,'1000010','2015-02-04 13:22:35',NULL),(4,1,'1000011','2015-02-03 13:22:41',NULL),(5,10,'1000012','2015-02-12 16:13:23',NULL);/*Data for the table `user` */insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (1,'王五',NULL,'2',NULL),(10,'张三','2014-07-10','1','北京市'),(16,'张小明',NULL,'1','河南郑州'),(22,'陈小明',NULL,'1','河南郑州'),(24,'张三丰',NULL,'1','河南郑州'),(25,'陈小明',NULL,'1','河南郑州'),(26,'王五',NULL,NULL,NULL);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;","tags":[{"name":"examples","slug":"examples","permalink":"https://brianway.github.io/tags/examples/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(8)-动态sql","date":"2016-03-07T18:39:08.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-8-dynamic-sql/","text":"mybatis核心,对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组装。 if判断 mapper.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 用户信息综合查询 #&#123;userCustom.sex&#125;:取出pojo包装对象中性别值 $&#123;userCustom.username&#125;：取出pojo包装对象中用户名称 --&gt;&lt;select id=\"findUserList\" parameterType=\"com.iot.mybatis.po.UserQueryVo\" resultType=\"com.iot.mybatis.po.UserCustom\"&gt; SELECT * FROM user &lt;!-- where 可以自动去掉条件中的第一个and --&gt; &lt;where&gt; &lt;if test=\"userCustom!=null\"&gt; &lt;if test=\"userCustom.sex!=null and userCustom.sex != '' \"&gt; AND user.sex=#&#123;userCustom.sex&#125; &lt;/if&gt; &lt;if test=\"userCustom.username!=null and userCustom.username != '' \"&gt; AND user.username LIKE '%$&#123;userCustom.username&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-- 用户信息综合查询总数 parameterType：指定输入类型和findUserList一样 resultType：输出结果类型--&gt;&lt;select id=\"findUserCount\" parameterType=\"com.iot.mybatis.po.UserQueryVo\" resultType=\"int\"&gt; SELECT count(*) FROM user &lt;where&gt; &lt;if test=\"userCustom!=null\"&gt; &lt;if test=\"userCustom.sex!=null and userCustom.sex != '' \"&gt; AND user.sex=#&#123;userCustom.sex&#125; &lt;/if&gt; &lt;if test=\"userCustom.username!=null and userCustom.username != '' \"&gt; AND user.username LIKE '%$&#123;userCustom.username&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试结果 1.注释掉testFindUserList()方法中的userCustom.setUsername(&quot;张三&quot;); 1234//由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中userCustom.setSex(\"1\");//userCustom.setUsername(\"张三\");userQueryVo.setUserCustom(userCustom); 输出 123456789DEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapper matches criteria [is assignable to Object]DEBUG [main] - Checking to see if class com.iot.mybatis.mapper.UserMapperTest matches criteria [is assignable to Object]DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 352359770.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@1500955a]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE user.sex=?DEBUG [main] - ==&gt; Parameters: 1(String)DEBUG [main] - &lt;== Total: 6[User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]] 可以看到sql语句为reparing: SELECT * FROM user WHERE user.sex=?，没有username的部分 2.userQueryVo设为null,则userCustom为null 12//List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo);List&lt;UserCustom&gt; list = userMapper.findUserList(null); 输出 1234DEBUG [main] - ==&gt; Preparing: SELECT * FROM userDEBUG [main] - ==&gt; Parameters:DEBUG [main] - &lt;== Total: 9[User [id=1, username=王五, sex=2, birthday=null, address=null], User [id=10, username=张三, sex=1, birthday=Thu Jul 10 00:00:00 CST 2014, address=北京市], User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=24, username=张三丰, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=26, username=王五, sex=null, birthday=null, address=null], User [id=27, username=王大军, sex=2, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州], User [id=28, username=王小军, sex=1, birthday=Tue Feb 23 00:00:00 CST 2016, address=河南郑州]] 可以看到sql语句变为了SELECT * FROM user sql片段(重点)将上边实现的动态sql判断代码块抽取出来，组成一个sql片段。其它的statement中就可以引用sql片段。 定义sql片段 12345678910111213141516&lt;!-- 定义sql片段id：sql片段的唯 一标识经验：是基于单表来定义sql片段，这样话这个sql片段可重用性才高在sql片段中不要包括 where --&gt;&lt;sql id=\"query_user_where\"&gt; &lt;if test=\"userCustom!=null\"&gt; &lt;if test=\"userCustom.sex!=null and userCustom.sex!=''\"&gt; AND user.sex = #&#123;userCustom.sex&#125; &lt;/if&gt; &lt;if test=\"userCustom.username!=null and userCustom.username!=''\"&gt; AND user.username LIKE '%$&#123;userCustom.username&#125;%' &lt;/if&gt; &lt;/if&gt;&lt;/sql&gt; 引用sql片段 1234567891011121314&lt;!-- 用户信息综合查询 #&#123;userCustom.sex&#125;:取出pojo包装对象中性别值 $&#123;userCustom.username&#125;：取出pojo包装对象中用户名称 --&gt;&lt;select id=\"findUserList\" parameterType=\"com.iot.mybatis.po.UserQueryVo\" resultType=\"com.iot.mybatis.po.UserCustom\"&gt; SELECT * FROM user &lt;!-- where 可以自动去掉条件中的第一个and --&gt; &lt;where&gt; &lt;!-- 引用sql片段 的id，如果refid指定的id不在本mapper文件中，需要前边加namespace --&gt; &lt;include refid=\"query_user_where\"&gt;&lt;/include&gt; &lt;!-- 在这里还要引用其它的sql片段 --&gt; &lt;/where&gt;&lt;/select&gt; foreach标签向sql传递数组或List，mybatis使用foreach解析 在用户查询列表和查询总数的statement中增加多个id输入查询。两种方法，sql语句如下： SELECT * FROM USER WHERE id=1 OR id=10 OR id=16 SELECT * FROM USER WHERE id IN(1,10,16) 一个使用OR,一个使用IN 在输入参数类型中添加List&lt;Integer&gt; ids传入多个id 12345678public class UserQueryVo &#123; //传入多个id private List&lt;Integer&gt; ids; getter、setter方法 。。。&#125; 修改mapper.xml 1234567891011121314151617181920212223&lt;if test=\"ids!=null\"&gt; &lt;!-- 使用 foreach遍历传入ids collection：指定输入 对象中集合属性 item：每个遍历生成对象中 open：开始遍历时拼接的串 close：结束遍历时拼接的串 separator：遍历的两个对象中需要拼接的串 --&gt; &lt;!-- 使用实现下边的sql拼接： AND (id=1 OR id=10 OR id=16) --&gt; &lt;foreach collection=\"ids\" item=\"user_id\" open=\"AND (\" close=\")\" separator=\"or\"&gt; &lt;!-- 每个遍历需要拼接的串 --&gt; id=#&#123;user_id&#125; &lt;/foreach&gt; &lt;!-- 实现 “ and id IN(1,10,16)”拼接 --&gt; &lt;!-- &lt;foreach collection=\"ids\" item=\"user_id\" open=\"and id IN(\" close=\")\" separator=\",\"&gt; 每个遍历需要拼接的串 #&#123;user_id&#125; &lt;/foreach&gt; --&gt;&lt;/if&gt; 测试代码 在testFindUserList中加入 1234567//传入多个idList&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();ids.add(1);ids.add(10);ids.add(16);//将ids通过userQueryVo传入statement中userQueryVo.setIds(ids);","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(7)-输出映射","date":"2016-03-07T18:39:07.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-7-output-mapping/","text":"本文主要讲解mybatis的输出映射。 输出映射有两种方式 resultType resultMap resultType 使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。 只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。 输出简单类型 mapper.xml 1234567&lt;!-- 用户信息综合查询总数 parameterType：指定输入类型和findUserList一样 resultType：输出结果类型 --&gt; &lt;select id=\"findUserCount\" parameterType=\"com.iot.mybatis.po.UserQueryVo\" resultType=\"int\"&gt; SELECT count(*) FROM user WHERE user.sex=#&#123;userCustom.sex&#125; AND user.username LIKE '%$&#123;userCustom.username&#125;%' &lt;/select&gt; mapper.java 123456789101112131415161718192021222324 //用户信息综合查询总数@Testpublic void testFindUserCount() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); //创建UserMapper对象，mybatis自动生成mapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //创建包装对象，设置查询条件 UserQueryVo userQueryVo = new UserQueryVo(); UserCustom userCustom = new UserCustom(); //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中 userCustom.setSex(\"1\"); userCustom.setUsername(\"小\"); userQueryVo.setUserCustom(userCustom); //调用userMapper的方法 int count = userMapper.findUserCount(userQueryVo); System.out.println(count);&#125; 小结 查询出来的结果集只有一行且一列，可以使用简单类型进行输出映射。 输出pojo对象和pojo列表不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中resultType指定的类型是一样的。 在mapper.java指定的方法返回值类型不一样： 输出单个pojo对象，方法返回值是单个对象类型 12//根据id查询用户信息public User findUserById(int id) throws Exception; 输出pojo对象list，方法返回值是List 12//根据用户名列查询用户列表public List&lt;User&gt; findUserByName(String name) throws Exception; 生成的动态代理对象中是根据mapper方法的返回值类型确定是调用selectOne(返回单个对象调用)还是selectList （返回集合对象调用 ）. resultMapmybatis中使用resultMap完成高级输出结果映射。(一对多，多对多) resultMap使用方法如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。 1.定义resultMap 2.使用resultMap作为statement的输出映射类型 定义reusltMap 12345678910111213141516171819202122&lt;!-- 定义resultMap 将SELECT id id_,username username_ FROM USER 和User类中的属性作一个映射关系 type：resultMap最终映射的java对象类型,可以使用别名 id：对resultMap的唯一标识 --&gt; &lt;resultMap type=\"user\" id=\"userResultMap\"&gt; &lt;!-- id表示查询结果集中唯一标识 column：查询出来的列名 property：type指定的pojo类型中的属性名 最终resultMap对column和property作一个映射关系 （对应关系） --&gt; &lt;id column=\"id_\" property=\"id\"/&gt; &lt;!-- result：对普通名映射定义 column：查询出来的列名 property：type指定的pojo类型中的属性名 最终resultMap对column和property作一个映射关系 （对应关系） --&gt; &lt;result column=\"username_\" property=\"username\"/&gt; &lt;/resultMap&gt; 使用resultMap作为statement的输出映射类型 123456&lt;!-- 使用resultMap进行输出映射 resultMap：指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace --&gt; &lt;select id=\"findUserByIdResultMap\" parameterType=\"int\" resultMap=\"userResultMap\"&gt; SELECT id id_,username username_ FROM USER WHERE id=#&#123;value&#125; &lt;/select&gt; mapper.java 12//根据id查询用户信息，使用resultMap输出public User findUserByIdResultMap(int id) throws Exception; 测试代码 12345678910111213141516@Testpublic void testFindUserByIdResultMap() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); //创建UserMapper对象，mybatis自动生成mapper代理对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用userMapper的方法 User user = userMapper.findUserByIdResultMap(1); System.out.println(user);&#125; 小结使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(6)-输入映射","date":"2016-03-07T18:39:06.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-6-input-mapping/","text":"本文主要讲解mybatis的输入映射。 通过parameterType指定输入参数的类型，类型可以是 简单类型 hashmap pojo的包装类型 传递pojo的包装对象 定义包装类型pojo 123456789101112131415161718192021222324package com.iot.mybatis.po;/** * Created by Brian on 2016/2/24. */public class UserQueryVo &#123; //在这里包装所需要的查询条件 //用户查询条件 private UserCustom userCustom; public UserCustom getUserCustom() &#123; return userCustom; &#125; public void setUserCustom(UserCustom userCustom) &#123; this.userCustom = userCustom; &#125; //可以包装其它的查询条件，订单、商品 //....&#125; 其中，UserCustom类继承User 12public class UserCustom extends User&#123;&#125; mapper.xml 在UserMapper.xml中定义用户信息综合查询（查询条件复杂，通过高级查询进行复杂关联查询）。 12345678&lt;!-- 用户信息综合查询 #&#123;userCustom.sex&#125;:取出pojo包装对象中性别值 $&#123;userCustom.username&#125;：取出pojo包装对象中用户名称 --&gt;&lt;select id=\"findUserList\" parameterType=\"com.iot.mybatis.po.UserQueryVo\" resultType=\"com.iot.mybatis.po.UserCustom\"&gt; SELECT * FROM user WHERE user.sex=#&#123;userCustom.sex&#125; AND user.username LIKE '%$&#123;userCustom.username&#125;%'&lt;/select&gt; 注意不要将#{userCustom.sex}中的userCustom写成UserCustom,前者指属性名(由于使用IDE提示自动补全，所以只是把类型名首字母小写了)，后者指类型名，这里是UserQueryVo类中的userCustom属性，是属性名。写错会报如下异常： 123org.apache.ibatis.exceptions.PersistenceException:### Error querying database. Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;UserCustom&apos; in &apos;class com.iot.mybatis.po.UserQueryVo&apos;### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;UserCustom&apos; in &apos;class com.iot.mybatis.po.UserQueryVo&apos; mapper.java 12//用户信息综合查询public List&lt;UserCustom&gt; findUserList(UserQueryVo userQueryVo) throws Exception; 测试代码 123456789101112131415161718192021222324//用户信息的综合 查询 @Test public void testFindUserList() throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); //创建UserMapper对象，mybatis自动生成mapper代理对象 UserMapper userMapper sqlSession.getMapper(UserMapper.class); //创建包装对象，设置查询条件 UserQueryVo userQueryVo = new UserQueryVo(); UserCustom userCustom = new UserCustom(); //由于这里使用动态sql，如果不设置某个值，条件不会拼接在sql中 userCustom.setSex(\"1\"); userCustom.setUsername(\"张三\"); userQueryVo.setUserCustom(userCustom); //调用userMapper的方法 List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo); System.out.println(list); &#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(5)-配置文件","date":"2016-03-07T18:39:05.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-5-configuration/","text":"本文主要讲解SqlMapConfig配置文件 参考mybatis – MyBatis 3 | Configuration SqlMapConfig.xml中配置的内容和顺序如下 properties（属性） settings（全局配置参数） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境集合属性对象） environment（环境子属性对象） transactionManager（事务管理） dataSource（数据源） mappers（映射器） (注：粗体是重点，斜体不常用) properties(属性)将数据库连接参数单独配置在db.properties中，只需要在SqlMapConfig.xml中加载db.properties的属性值。在SqlMapConfig.xml中就不需要对数据库连接参数硬编码。 将数据库连接参数只配置在db.properties中。原因：方便对参数进行统一管理，其它xml可以引用该db.properties。 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8jdbc.username=rootjdbc.password=123 在sqlMapConfig.xml加载属性文件： 12345678910111213141516171819&lt;properties resource=\"db.properties\"&gt; &lt;!--properties中还可以配置一些属性名和属性值 --&gt; &lt;!-- &lt;property name=\"jdbc.driver\" value=\"\"/&gt; --&gt;&lt;/properties&gt;&lt;!-- 和spring整合后 environments配置将废除--&gt;&lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池,由mybatis管理--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 注意： MyBatis 将按照下面的顺序(优先级)来加载属性： 在properties元素体内定义的属性首先被读取。 然后会读取properties元素中resource或url加载的属性，它会覆盖已读取的同名属性。 最后读取parameterType传递的属性，它会覆盖已读取的同名属性。 建议： 不要在properties元素体内添加任何属性值，只将属性值定义在properties文件中。 在properties文件中定义属性名要有一定的特殊性，如：XXXXX.XXXXX.XXXX settings(全局参数配置)mybatis框架在运行时可以调整一些运行参数,比如：开启二级缓存、开启延迟加载… 全局参数将会影响mybatis的运行行为。具体参考官网： mybatis-settings typeAliases(类型别名)在mapper.xml中，定义很多的statement，statement需要parameterType指定输入参数的类型、需要resultType指定输出结果的映射类型。 如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名定义，方便开发。 mybatis默认支持别名 参考 typeAliases 别名 映射的类型 _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal 自定义别名 单个别名定义 批量定义别名（常用） 1234567891011121314&lt;!-- 别名定义 --&gt;&lt;typeAliases&gt; &lt;!-- 针对单个别名定义 type：类型的路径 alias：别名 --&gt; &lt;!-- &lt;typeAlias type=\"cn.itcast.mybatis.po.User\" alias=\"user\"/&gt; --&gt; &lt;!-- 批量别名定义 指定包名，mybatis自动扫描包中的po类，自动定义别名，别名就是类名（首字母大写或小写都可以） --&gt; &lt;package name=\"com.iot.mybatis.po\"/&gt;&lt;/typeAliases&gt; typeHandlers(类型处理器)mybatis中通过typeHandlers完成jdbc类型和java类型的转换。例如： 123&lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"user\"&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; mybatis自带的类型处理器基本上满足日常需求，不需要单独定义。 mybatis支持类型处理器 参考 typeHandlers 类型处理器 Java类型 JDBC类型 BooleanTypeHandler Boolean，boolean 任何兼容的布尔值 ByteTypeHandler Byte，byte 任何兼容的数字或字节类型 ShortTypeHandler Short，short 任何兼容的数字或短整型 IntegerTypeHandler Integer，int 任何兼容的数字和整型 LongTypeHandler Long，long 任何兼容的数字或长整型 FloatTypeHandler Float，float 任何兼容的数字或单精度浮点型 DoubleTypeHandler Double，double 任何兼容的数字或双精度浮点型 BigDecimalTypeHandler BigDecimal 任何兼容的数字或十进制小数类型 StringTypeHandler String CHAR和VARCHAR类型 ClobTypeHandler String CLOB和LONGVARCHAR类型 NStringTypeHandler String NVARCHAR和NCHAR类型 NClobTypeHandler String NCLOB类型 ByteArrayTypeHandler byte[] 任何兼容的字节流类型 BlobTypeHandler byte[] BLOB和LONGVARBINARY类型 DateTypeHandler Date（java.util） TIMESTAMP类型 DateOnlyTypeHandler Date（java.util） DATE类型 TimeOnlyTypeHandler Date（java.util） TIME类型 SqlTimestampTypeHandler Timestamp（java.sql） TIMESTAMP类型 SqlDateTypeHandler Date（java.sql） DATE类型 SqlTimeTypeHandler Time（java.sql） TIME类型 ObjectTypeHandler 任意 其他或未指定类型 EnumTypeHandler Enumeration类型 VARCHAR-任何兼容的字符串类型，作为代码存储（而不是索引） mappers(映射配置) 通过resource加载单个映射文件 12&lt;!--通过resource方法一次加载一个映射文件 --&gt;&lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; 通过mapper接口加载单个mapper 12345 &lt;!-- 通过mapper接口加载单个 映射文件 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录中 上边规范的前提是：使用的是mapper代理方法 --&gt;&lt;mapper class=\"com.iot.mybatis.mapper.UserMapper\"/&gt; 目录示例 123com.iot.mybatis.mapper------------------package包 |----UserMapper.java |----UserMapper.xml 批量加载mapper(推荐使用) 123456&lt;!-- 批量加载mapper 指定mapper接口的包名，mybatis自动扫描包下边所有mapper接口进行加载 遵循一些规范：需要将mapper接口类名和mapper.xml映射文件名称保持一致，且在一个目录 中 上边规范的前提是：使用的是mapper代理方法 --&gt;&lt;package name=\"com.iot.mybatis.mapper\"/&gt;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(4)-开发dao方法","date":"2016-03-07T18:39:04.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-4-dao/","text":"本文讲解SqlSession，并对两种方法(原始dao开发和mapper代理开发)分别做简单展示 SqlSession使用范围 SqlSessionFactoryBuilder 通过SqlSessionFactoryBuilder创建会话工厂SqlSessionFactory将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例管理SqlSessionFactoryBuilder。在需要创建SqlSessionFactory时候，只需要new一次SqlSessionFactoryBuilder即可。 SqlSessionFactory 通过SqlSessionFactory创建SqlSession，使用单例模式管理sqlSessionFactory（工厂一旦创建，使用一个实例）。将来mybatis和spring整合后，使用单例模式管理sqlSessionFactory。 SqlSession SqlSession是一个面向用户（程序员）的接口。SqlSession中提供了很多操作数据库的方法：如：selectOne(返回单个对象)、selectList（返回单个或多个对象）。 SqlSession是线程不安全的，在SqlSesion实现类中除了有接口中的方法（操作数据库的方法）还有数据域属性。 SqlSession最佳应用场合在方法体内，定义成局部变量使用。 原始dao开发方法程序员需要写dao接口和dao实现类 dao接口12345678910111213public interface UserDao &#123; //根据id查询用户信息 public User findUserById(int id) throws Exception; //根据用户名列查询用户列表 public List&lt;User&gt; findUserByName(String name) throws Exception; //添加用户信息 public void insertUser(User user) throws Exception; //删除用户信息 public void deleteUser(int id) throws Exception;&#125; dao接口实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.iot.mybatis.dao;import com.iot.mybatis.po.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;/** * Created by Brian on 2016/2/24. */public class UserDaoImpl implements UserDao&#123; // 需要向dao实现类中注入SqlSessionFactory // 这里通过构造方法注入 private SqlSessionFactory sqlSessionFactory; public UserDaoImpl(SqlSessionFactory sqlSessionFactory)&#123; this.sqlSessionFactory = sqlSessionFactory; &#125; @Override public User findUserById(int id) throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); User user = sqlSession.selectOne(\"test.findUserById\",id); //释放资源 sqlSession.close(); return user; &#125; @Override public List&lt;User&gt; findUserByName(String name) throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; list = sqlSession.selectList(\"test.findUserByName\", name); // 释放资源 sqlSession.close(); return list; &#125; @Override public void insertUser(User user) throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); //执行插入操作 sqlSession.insert(\"test.insertUser\", user); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); &#125; @Override public void deleteUser(int id) throws Exception &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); //执行插入操作 sqlSession.delete(\"test.deleteUser\", id); // 提交事务 sqlSession.commit(); // 释放资源 sqlSession.close(); &#125;&#125; 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.iot.mybatis.dao;import java.io.InputStream;import com.iot.mybatis.po.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;public class UserDaoImplTest &#123; private SqlSessionFactory sqlSessionFactory; // 此方法是在执行testFindUserById之前执行 @Before public void setUp() throws Exception &#123; // 创建sqlSessionFactory // mybatis配置文件 String resource = \"SqlMapConfig.xml\"; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); &#125; @Test public void testFindUserById() throws Exception &#123; // 创建UserDao的对象 UserDao userDao = new UserDaoImpl(sqlSessionFactory); // 调用UserDao的方法 User user = userDao.findUserById(1); System.out.println(user); &#125;&#125; 总结原始dao开发问题1.dao接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来，大大减轻程序员的工作量。 2.调用sqlsession方法时将statement的id硬编码了 3.调用sqlsession方法时传入的变量，由于sqlsession方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发。 mapper代理方法程序员只需要mapper接口（相当 于dao接口） 程序员还需要编写mapper.xml映射文件 程序员编写mapper接口需要遵循一些开发规范，mybatis可以自动生成mapper接口实现类代理对象。 开发规范 在mapper.xml中namespace等于mapper接口地址 12345&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用,namespace等于mapper接口地址 --&gt;&lt;mapper namespace=\"com.iot.mybatis.mapper.UserMapper\"&gt; mapper.java接口中的方法名和mapper.xml中statement的id一致 mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类型一致。 mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致。 123&lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.mybatis.po.User\"&gt; SELECT * FROM user WHERE id=#&#123;value&#125;&lt;/select&gt; 12//根据id查询用户信息public User findUserById(int id) throws Exception; 总结：以上开发规范主要是对下边的代码进行统一生成： 12User user = sqlSession.selectOne(\"test.findUserById\", id);sqlSession.insert(\"test.insertUser\", user); 代码 mapper.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=\"com.iot.mybatis.mapper.UserMapper\"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!--需求:通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id:标识映射文件中的sql，称为statement的id 将sql语句封装到mappedStatement对象中，所以将id称为statement的id parameterType:指定输入参数的类型 #&#123;&#125;标示一个占位符, #&#123;value&#125;其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#&#123;&#125;中的值可以任意。 resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.mybatis.po.User\"&gt; SELECT * FROM user WHERE id=#&#123;value&#125; &lt;/select&gt; &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条 resultType：指定就是单条记录所映射的java对象类型 $&#123;&#125;:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。 使用$&#123;&#125;拼接sql，引起 sql注入 $&#123;value&#125;：接收输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value --&gt; &lt;select id=\"findUserByName\" parameterType=\"java.lang.String\" resultType=\"com.iot.mybatis.po.User\"&gt; SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 添加用户 parameterType：指定输入 参数类型是pojo（包括 用户信息） #&#123;&#125;中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值 --&gt; &lt;insert id=\"insertUser\" parameterType=\"com.iot.mybatis.po.User\"&gt; &lt;!-- 将插入数据的主键返回，返回到user对象中 SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键 keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性 order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序 resultType：指定SELECT LAST_INSERT_ID()的结果类型 --&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO user (username,birthday,sex,address)values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;!-- 使用mysql的uuid（）生成主键 执行过程： 首先通过uuid()得到主键，将主键设置到user对象的id属性中 其次在insert执行时，从user对象中取出id属性值 --&gt; &lt;!-- &lt;selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\"&gt; SELECT uuid() &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) value(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) --&gt; &lt;/insert&gt; &lt;!-- 删除 用户 根据id删除用户，需要输入 id值 --&gt; &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;!-- 根据id更新用户 分析： 需要传入用户的id 需要传入用户的更新信息 parameterType指定user对象，包括 id和更新信息，注意：id必须存在 #&#123;id&#125;：从输入 user对象中获取id属性值 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.iot.mybatis.po.User\"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 在SqlMapConfig.xml中加载映射文件 123&lt;mappers&gt; &lt;mapper resource=\"mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt; UserMapper.java 12345678910111213141516public interface UserMapper &#123; //根据id查询用户信息 public User findUserById(int id) throws Exception; //根据用户名列查询用户列表 public List&lt;User&gt; findUserByName(String name) throws Exception; //添加用户信息 public void insertUser(User user) throws Exception; //删除用户信息 public void deleteUser(int id) throws Exception; //更新用户 public void updateUser(User user)throws Exception;&#125; UserMapperTest/java 12345678910111213141516171819202122232425262728293031public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory; //注解Before是在执行本类所有测试方法之前先调用这个方法 @Before public void setup() throws Exception&#123; //创建SqlSessionFactory String resource=\"SqlMapConfig.xml\"; //将配置文件加载成流 InputStream inputStream = Resources.getResourceAsStream(resource); //创建会话工厂，传入mybatis配置文件的信息 sqlSessionFactory=new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testFindUserById() throws Exception&#123; SqlSession sqlSession=sqlSessionFactory.openSession(); //创建UserMapper代理对象 UserMapper userMapper=sqlSession.getMapper(UserMapper.class); //调用userMapper的方法 User user=userMapper.findUserById(1); System.out.println(user.getUsername()); &#125; &#125; 一些问题总结 代理对象内部调用selectOne或selectList 如果mapper方法返回单个pojo对象（非集合对象），代理对象内部通过selectOne查询数据库。 如果mapper方法返回集合对象，代理对象内部通过selectList查询数据库。 mapper接口方法参数只能有一个是否影响系统开发 mapper接口方法参数只能有一个，系统是否不利于扩展维护?系统框架中，dao层的代码是被业务层公用的。即使mapper接口只有一个参数，可以使用包装类型的pojo满足不同的业务方法的需求。 注意：持久层方法的参数可以包装类型、map…等，service方法中建议不要使用包装类型（不利于业务层的可扩展）。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(3)-入门程序二","date":"2016-03-07T18:38:04.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-3-starting-2/","text":"添加、删除、更新用户 映射文件 User.xml,在入门程序一基础上增加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 添加用户 parameterType：指定输入 参数类型是pojo（包括 用户信息） #&#123;&#125;中指定pojo的属性名，接收到pojo对象的属性值，mybatis通过OGNL获取对象的属性值 --&gt;&lt;insert id=\"insertUser\" parameterType=\"com.iot.mybatis.po.User\"&gt; &lt;!-- 将插入数据的主键返回，返回到user对象中 SELECT LAST_INSERT_ID()：得到刚insert进去记录的主键值，只适用与自增主键 keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性 order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序 resultType：指定SELECT LAST_INSERT_ID()的结果类型 --&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO user (username,birthday,sex,address)values (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;!-- 使用mysql的uuid（）生成主键 执行过程： 首先通过uuid()得到主键，将主键设置到user对象的id属性中 其次在insert执行时，从user对象中取出id属性值 --&gt; &lt;!-- &lt;selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"java.lang.String\"&gt; SELECT uuid() &lt;/selectKey&gt; insert into user(id,username,birthday,sex,address) value(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) --&gt;&lt;/insert&gt;&lt;!-- 删除 用户 根据id删除用户，需要输入 id值 --&gt;&lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id=#&#123;id&#125;&lt;/delete&gt;&lt;!-- 根据id更新用户分析：需要传入用户的id需要传入用户的更新信息parameterType指定user对象，包括 id和更新信息，注意：id必须存在#&#123;id&#125;：从输入 user对象中获取id属性值 --&gt;&lt;update id=\"updateUser\" parameterType=\"com.iot.mybatis.po.User\"&gt; update user set username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;&lt;/update&gt; (注：这里的birthday字段在mysql表中是DATE类型，在User类中birthday属性是java的java.util.Date类型，并没有进行转换就插入成功了。 看到有的文章说，在字段中有Date和DateTime类型，在插入数据时只要将实体的属性设置成Timestamp就会对应mysql的DateTime类型，Date会对应mysql的Date类型:#{modified_date,jdbcType=TIMESTAMP}、#{date,jdbcType=DATE} 我上面的birthday，配置成#{birthday,jdbcType=TIMESTAMP}，结果也插入成功了，具体实现待查) 程序代码 User.java,在入门程序一基础上增加三个测试方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// 添加用户信息 @Test public void insertUserTest() throws IOException &#123; // mybatis配置文件 String resource = \"SqlMapConfig.xml\"; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 插入用户对象 User user = new User(); user.setUsername(\"王小军\"); user.setBirthday(new Date()); user.setSex(\"1\"); user.setAddress(\"河南郑州\"); sqlSession.insert(\"test.insertUser\", user); // 提交事务 sqlSession.commit(); // 获取用户信息主键 System.out.println(user.getId()); // 关闭会话 sqlSession.close(); &#125; // 根据id删除 用户信息 @Test public void deleteUserTest() throws IOException &#123; // mybatis配置文件 String resource = \"SqlMapConfig.xml\"; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 传入id删除 用户 sqlSession.delete(\"test.deleteUser\", 29); // 提交事务 sqlSession.commit(); // 关闭会话 sqlSession.close(); &#125; // 更新用户信息 @Test public void updateUserTest() throws IOException &#123; // mybatis配置文件 String resource = \"SqlMapConfig.xml\"; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 更新用户信息 User user = new User(); //必须设置id user.setId(27); user.setUsername(\"王大军\"); user.setBirthday(new Date()); user.setSex(\"2\"); user.setAddress(\"河南郑州\"); sqlSession.update(\"test.updateUser\", user); // 提交事务 sqlSession.commit(); // 关闭会话 sqlSession.close(); &#125; 自增主键返回 123&lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; SELECT LAST_INSERT_ID()&lt;/selectKey&gt; 如果没有在上面的配置中配置resultType，则会报下面的异常 1234567891011org.apache.ibatis.exceptions.PersistenceException:### Error updating database. Cause: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement &apos;test.insertUser!selectKey&apos;. It&apos;s likely that neither a Result Type nor a Result Map was specified.### The error may exist in sqlmap/User.xml### The error may involve test.insertUser!selectKey-Inline### The error occurred while setting parameters### SQL: SELECT LAST_INSERT_ID()### Cause: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement &apos;test.insertUser!selectKey&apos;. It&apos;s likely that neither a Result Type nor a Result Map was specified. ...Caused by: org.apache.ibatis.executor.ExecutorException: A query was run and no Result Maps were found for the Mapped Statement &apos;test.insertUser!selectKey&apos;. It&apos;s likely that neither a Result Type nor a Result Map was specified. 总结 #{}和${} #{}表示一个占位符号，#{}接收输入参数，类型可以是简单类型，pojo、hashmap。 如果接收简单类型，#{}中可以写成value或其它名称。 #{}接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性…的方式获取对象属性值。 ${}表示一个拼接符号，会引用sql注入，所以不建议使用${}。 ${}接收输入参数，类型可以是简单类型，pojo、hashmap。 如果接收简单类型，${}中只能写成value。 ${}接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性…的方式获取对象属性值。 mybatis和hibernate本质区别和应用场景 hibernate 是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。对sql语句进行优化、修改比较困难的。 应用场景：适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa。。 mybatis 专注是sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。mybatis是一个不完全的ORM框架，虽然程序员自己写sql，mybatis也可以实现映射（输入映射、输出映射）。 应用场景：适用与需求变化较多的项目，比如：互联网项目。 企业进行技术选型，以低成本高回报作为技术选型的原则，根据项目组的技术力量进行选择。","tags":[{"name":"examples","slug":"examples","permalink":"https://brianway.github.io/tags/examples/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(3)-入门程序一","date":"2016-03-07T18:38:03.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-3-starting-1/","text":"mybatis入门程序 工程结构在IDEA中新建了一个普通的java项目，新建文件夹lib,加入jar包,工程结构如图。 mybatis_入门程序一-工程结构图 log4j.properties 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n SqlMapConfig.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 数据库连接池,由mybatis管理--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 映射文件 sqlmap/User.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace 命名空间，作用就是对sql进行分类化管理,理解为sql隔离 注意：使用mapper代理方法开发，namespace有特殊重要的作用 --&gt;&lt;mapper namespace=\"test\"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!--需求:通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id:标识映射文件中的sql，称为statement的id 将sql语句封装到mappedStatement对象中，所以将id称为statement的id parameterType:指定输入参数的类型 #&#123;&#125;标示一个占位符, #&#123;value&#125;其中value表示接收输入参数的名称，如果输入参数是简单类型，那么#&#123;&#125;中的值可以任意。 resultType：指定sql输出结果的映射的java对象类型，select指定resultType表示将单条记录映射成java对象 --&gt; &lt;select id=\"findUserById\" parameterType=\"int\" resultType=\"com.iot.mybatis.po.User\"&gt; SELECT * FROM user WHERE id=#&#123;value&#125; &lt;/select&gt; &lt;!-- 根据用户名称模糊查询用户信息，可能返回多条 resultType：指定就是单条记录所映射的java对象类型 $&#123;&#125;:表示拼接sql串，将接收到参数的内容不加任何修饰拼接在sql中。 使用$&#123;&#125;拼接sql，引起 sql注入 $&#123;value&#125;：接收输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value --&gt; &lt;select id=\"findUserByName\" parameterType=\"java.lang.String\" resultType=\"com.iot.mybatis.po.User\"&gt; SELECT * FROM user WHERE username LIKE '%$&#123;value&#125;%' &lt;/select&gt;&lt;/mapper&gt; 在sqlMapConfig.xml中加载User.xml 1234&lt;!-- 加载映射文件--&gt;&lt;mappers&gt; &lt;mapper resource=\"sqlmap/User.xml\"/&gt;&lt;/mappers&gt; 程序代码 po类User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.iot.mybatis.po;import java.util.Date;/** * Created by Administrator on 2016/2/21. */public class User &#123; //属性名要和数据库表的字段对应 private int id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"User [id=\" + id + \", username=\" + username + \", sex=\" + sex + \", birthday=\" + birthday + \", address=\" + address + \"]\"; &#125;&#125; 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.iot.mybatis.first;import com.iot.mybatis.po.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.List;/** * Created by Administrator on 2016/2/23. */public class MybatisFirst &#123; //根据id查询用户信息，得到一条记录结果 @Test public void findUserByIdTest() throws IOException&#123; // mybatis配置文件 String resource = \"SqlMapConfig.xml\"; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); //创建会话工厂，传入mybatis配置文件的信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 通过SqlSession操作数据库 // 第一个参数：映射文件中statement的id，等于=namespace+\".\"+statement的id // 第二个参数：指定和映射文件中所匹配的parameterType类型的参数 // sqlSession.selectOne结果 是与映射文件中所匹配的resultType类型的对象 // selectOne查询出一条记录 User user = sqlSession.selectOne(\"test.findUserById\", 1); System.out.println(user); // 释放资源 sqlSession.close(); &#125; // 根据用户名称模糊查询用户列表 @Test public void findUserByNameTest() throws IOException &#123; // mybatis配置文件 String resource = \"SqlMapConfig.xml\"; // 得到配置文件流 InputStream inputStream = Resources.getResourceAsStream(resource); // 创建会话工厂，传入mybatis的配置文件信息 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder() .build(inputStream); // 通过工厂得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // list中的user和映射文件中resultType所指定的类型一致 List&lt;User&gt; list = sqlSession.selectList(\"test.findUserByName\", \"小明\"); System.out.println(list); sqlSession.close(); &#125;&#125; 输出： findUserByIdTest() 123456789101112131415DEBUG [main] - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 1857815974.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6ebc05a6]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE id=?DEBUG [main] - ==&gt; Parameters: 1(Integer)DEBUG [main] - &lt;== Total: 1User [id=1, username=王五, sex=2, birthday=null, address=null]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@6ebc05a6]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@6ebc05a6]DEBUG [main] - Returned connection 1857815974 to pool. findUserByNameTest() 123456789101112131415DEBUG [main] - Logging initialized using &apos;class org.apache.ibatis.logging.slf4j.Slf4jImpl&apos; adapter.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - PooledDataSource forcefully closed/removed all connections.DEBUG [main] - Opening JDBC ConnectionDEBUG [main] - Created connection 1596467899.DEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5f282abb]DEBUG [main] - ==&gt; Preparing: SELECT * FROM user WHERE username LIKE &apos;%小明%&apos;DEBUG [main] - ==&gt; Parameters:DEBUG [main] - &lt;== Total: 3[User [id=16, username=张小明, sex=1, birthday=null, address=河南郑州], User [id=22, username=陈小明, sex=1, birthday=null, address=河南郑州], User [id=25, username=陈小明, sex=1, birthday=null, address=河南郑州]]DEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@5f282abb]DEBUG [main] - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@5f282abb]DEBUG [main] - Returned connection 1596467899 to pool. 总结 parameterType 在映射文件中通过parameterType指定输入参数的类型 resultType 在映射文件中通过resultType指定输出结果的类型 #{}和${} #{}表示一个占位符号; ${}表示一个拼接符号，会引起sql注入，所以不建议使用 selectOne和selectList selectOne表示查询一条记录进行映射，使用selectList也可以使用，只不过只有一个对象 selectList表示查询出一个列表(参数记录)进行映射，不能够使用selectOne查，不然会报下面的错: 1org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3","tags":[{"name":"examples","slug":"examples","permalink":"https://brianway.github.io/tags/examples/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(2)-mybatis概述","date":"2016-03-07T18:38:02.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-2-mybatis-summary/","text":"本文对mybatis做一个简单介绍，包括框架原理，执行过程，开发方法，输入输出映射以及动态sql,我会在后续的系列文章中一一详细说明 mybatis 介绍mybatis是一个持久层的框架，是apache下的顶级项目。 mybatis托管到goolecode下，再后来托管到github下(https://github.com/mybatis/mybatis-3/releases)。 mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。 mybatis可以将向 preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。（输出映射） 框架原理mybatis框架 mybatis框架图 mybatis框架执行过程1、配置mybatis的配置文件，SqlMapConfig.xml（名称不固定） 2、通过配置文件，加载mybatis运行环境，创建SqlSessionFactory会话工厂(SqlSessionFactory在实际使用时按单例方式) 3、通过SqlSessionFactory创建SqlSession。SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。 4、调用sqlSession的方法去操作数据。如果需要提交事务，需要执行SqlSession的commit()方法。 5、释放资源，关闭SqlSession mybatis开发dao的方法1.原始dao 的方法 需要程序员编写dao接口和实现类 需要在dao实现类中注入一个SqlSessionFactory工厂 2.mapper代理开发方法（建议使用） 只需要程序员编写mapper接口（就是dao接口）。程序员在编写mapper.xml(映射文件)和mapper.java需要遵循一个开发规范： mapper.xml中namespace就是mapper.java的类全路径。 mapper.xml中statement的id和mapper.java中方法名一致。 mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入参数类型一致 mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。 SqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载。 输入映射和输出映射 输入映射： parameterType：指定输入参数类型可以简单类型、pojo、hashmap。 对于综合查询，建议parameterType使用包装的pojo，有利于系统扩展。 输出映射： resultType：查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。 reusltMap：可以通过resultMap 完成一些高级映射。如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。 高级映射： 将关联查询的列映射到一个pojo属性中。（一对一） 将关联查询的列映射到一个List中。（一对多） 动态sql 动态sql：（重点） if判断（掌握） where foreach sql片段（掌握）","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"}]},{"title":"mybatis学习笔记(1)-对原生jdbc程序中的问题总结","date":"2016-03-07T18:38:01.000Z","path":"2016/03/08/2016-03-08-mybatis-learn-1-jdbc-summary/","text":"本文总结jdbc编程的一般步骤，总结这样编程存在的问题，并附上典型地jdbc示例demo jdbc编程步骤 加载数据库驱动 创建并获取数据库链接 创建jdbc statement对象 设置sql语句 设置sql语句中的参数(使用preparedStatement) 通过statement执行sql并获取结果 对sql执行结果进行解析处理 释放资源(resultSet、preparedstatement、connection) 问题总结1.数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。 设想：使用数据库连接池管理数据库连接。 2.将sql语句硬编码到java代码中，如果sql语句修改，需要重新编译java代码，不利于系统维护。 设想：将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译。 3.向preparedStatement中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。 设想：将sql语句及占位符号和参数全部配置在xml中。 4.从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统维护。 设想：将查询的结果集，自动映射成java对象。 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.iot.mybatis.jdbc;//import java.sql.*;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * Created by Administrator on 2016/2/21. */public class JdbcTest &#123; public static void main(String[] args) &#123; //数据库连接 Connection connection = null; //预编译的Statement，使用预编译的Statement提高数据库性能 PreparedStatement preparedStatement = null; //结果集 ResultSet resultSet = null; try &#123; //加载数据库驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //通过驱动管理类获取数据库链接 connection = DriverManager.getConnection(\"jdbc:mysql://120.25.162.238:3306/mybatis001?characterEncoding=utf-8\", \"root\", \"123\"); //定义sql语句 ?表示占位符 String sql = \"select * from user where username = ?\"; //获取预处理statement preparedStatement = connection.prepareStatement(sql); //设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值 preparedStatement.setString(1, \"王五\"); //向数据库发出sql执行查询，查询出结果集 resultSet = preparedStatement.executeQuery(); //遍历查询结果集 while(resultSet.next())&#123; System.out.println(resultSet.getString(\"id\")+\" \"+resultSet.getString(\"username\")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; //释放资源 if(resultSet!=null)&#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(preparedStatement!=null)&#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://brianway.github.io/tags/MyBatis/"},{"name":"JDBC","slug":"JDBC","permalink":"https://brianway.github.io/tags/JDBC/"}]},{"title":"java基础巩固笔记(6)-注解","date":"2016-02-20T01:45:12.000Z","path":"2016/02/20/2016-02-20-javase-learn-note-6-Annotation/","text":"注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 API Package java.lang.annotation 注解的应用结构图调用/结构关系：A&lt;–B&lt;–C A,B,C解释如下： A:注解类 12@interface A&#123;&#125; B:应用了“注解类”的类 123@AClass B&#123;&#125; C:对“应用了注解类的类”进行反射操作的类 123456Class C&#123; public void f()&#123; B.class.isAnnotationPresent(A.class); A a = B.class.getAnnotion(A.class); &#125;&#125; 元注解元注解的作用就是负责注解其他注解。四个元注解分别是：@Target,@Retention,@Documented,@Inherited @Retention 表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy中，包括RetentionPolicy.SOURCE,RetentionPolicy.CLASS(默认),RetentionPolicy.RUNTIME分别对应：java源文件–&gt;class文件–&gt;内存中的字节码 123RetentionPolicy.SOURCE 注解将被编译器丢弃RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 @Target 表示该注解用于什么地方，可能的值在枚举类ElemenetType中,包括 1234567ElemenetType.CONSTRUCTOR 构造器声明ElemenetType.FIELD 域声明（包括 enum 实例）ElemenetType.LOCAL_VARIABLE 局部变量声明ElemenetType.METHOD 方法声明ElemenetType.PACKAGE 包声明ElemenetType.PARAMETER 参数声明ElemenetType.TYPE 类，接口（包括注解类型）或enum声明 @Documented 将此注解包含在javadoc中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当于@see,@param等 @Inherited 允许子类继承父类中的注解 自定义注解使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 定义注解格式： public @interface 注解名 {定义体} 注解参数的可支持数据类型： 1.所有基本数据类型(int,float,boolean,byte,double,char,long,short)2.String类型3.Class类型4.enum类型5.Annotation类型6.以上所有类型的数组 示例代码参考文末的【参考资料】中《java 注解的几大作用及使用方法详解（完）》 下面的示例，是上文提到的A&lt;–B&lt;–C的扩充版本。自定义了一个注解@A，然后在B类中使用了注解@A,最后在类C中利用反射读取@A中的信息 A.java 1234567891011121314package com.iot.annotation;import java.lang.annotation.*;/** * Created by brian on 2016/2/20. */@Target(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD,ElementType.CONSTRUCTOR&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface A &#123; String name(); int id() default 0; Class&lt;Long&gt; gid();&#125; B.java 123456789101112131415161718192021222324252627282930313233343536package com.iot.annotation;import java.util.HashMap;import java.util.Map;/** * Created by brian on 2016/2/20. */@A(name=\"type\",gid=Long.class)//类注解public class B &#123; @A(name=\"param\",id=1,gid=Long.class) //类成员注解 private Integer age; @A(name=\"construct\",id=2,gid=Long.class) //构造方法注解 public B()&#123;&#125; @A(name=\"public method\",id=3,gid=Long.class) //类方法注解 public void a()&#123; &#125; @A(name=\"protected method\",id=4,gid=Long.class) //类方法注解 protected void b()&#123; Map&lt;String,String&gt; m = new HashMap&lt;String,String&gt;(0); &#125; @A(name=\"private method\",id=5,gid=Long.class) //类方法注解 private void c()&#123; Map&lt;String,String&gt; m = new HashMap&lt;String,String&gt;(0); &#125; public void b(Integer a)&#123; &#125;&#125; C.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.iot.annotation;import java.lang.annotation.Annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Method;/** * Created by brian on 2016/2/20. */public class C &#123; /** * 简单打印出B类中所使用到的类注解 * 该方法只打印了 Type 类型的注解 * @throws ClassNotFoundException */ public static void parseTypeAnnotation() throws ClassNotFoundException&#123; Class clazz = Class.forName(\"com.iot.annotation.B\"); Annotation[] annotations = clazz.getAnnotations(); for(Annotation annotation :annotations)&#123; A a = (A)annotation; System.out.println(\"id = \"+a.id()+\" ;name = \"+a.name()+\" ;gid = \"+a.gid()); &#125; &#125; /** * 简单打印出B类中所使用到的方法注解 * 该方法只打印了 Method 类型的注解 */ public static void parseMethodAnnotation() &#123; Method[] methods = B.class.getDeclaredMethods(); for (Method method : methods) &#123; /* * 判断方法中是否有指定注解类型的注解 */ boolean hasAnnotation = method.isAnnotationPresent(A.class); if (hasAnnotation) &#123; /* * 根据注解类型返回方法的指定类型注解 */ A annotation = method.getAnnotation(A.class); System.out.println(\"method = \" + method.getName() + \" ; id = \" + annotation.id() + \" ; description = \" + annotation.name() + \"; gid= \" + annotation.gid()); &#125; &#125; &#125; /** * 简单打印出B类中所使用到的方法注解 * 该方法只打印了 Method 类型的注解 */ public static void parseConstructAnnotation()&#123; Constructor[] constructors = B.class.getConstructors(); for (Constructor constructor : constructors) &#123; /* * 判断构造方法中是否有指定注解类型的注解 */ boolean hasAnnotation = constructor.isAnnotationPresent(A.class); if (hasAnnotation) &#123; /* * 根据注解类型返回方法的指定类型注解 */ A annotation =(A) constructor.getAnnotation(A.class); System.out.println(\"constructor = \" + constructor.getName() + \" ; id = \" + annotation.id() + \" ; description = \" + annotation.name() + \"; gid= \"+annotation.gid()); &#125; &#125; &#125; public static void main(String[] args) throws ClassNotFoundException &#123; parseTypeAnnotation(); parseMethodAnnotation(); parseConstructAnnotation(); &#125;&#125; 参考资料 java 注解的几大作用及使用方法详解（完） 另类的package-info.java文件探讨 深入理解Java：注解（Annotation）自定义注解入门","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"注解","slug":"注解","permalink":"https://brianway.github.io/tags/注解/"}]},{"title":"我的java&javaweb学习笔记(汇总)","date":"2016-02-08T23:00:00.000Z","path":"2016/02/09/2016-02-09-javase-note-TOC/","text":"笔记分为两大部分：javase和javaweb javase javaweb 笔记内容主要是对一些基础特性和编程细节进行总结整理，适合了解java基础语法，想进一步深入学习的人 github： java-learning git-clone:`git@github.com:brianway/java-learning.git` 如果觉得不错，请给star，这也是对我的鼓励，有什么意见欢迎留言反馈 目录 javase java基础巩固笔记(1)-反射 java基础巩固笔记(2)-泛型 java基础巩固笔记(3)-类加载器 java基础巩固笔记(4)-代理 java基础巩固笔记(4)-实现AOP功能的封装与配置的小框架 java基础巩固笔记(5)-多线程之传统多线程 java基础巩固笔记(5)-多线程之共享数据 java基础巩固笔记(5)-多线程之线程并发库 java基础巩固笔记(6)-注解 javaweb javaweb入门笔记(1)-Tomcat javaweb入门笔记(2)-http入门 javaweb入门笔记(3)-Servlet javaweb入门笔记(4)-request和response javaweb入门笔记(5)-cookie和session javaweb入门笔记(6)-JSP技术 all copyright reserved","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"总结","slug":"总结","permalink":"https://brianway.github.io/tags/总结/"}]},{"title":"javaweb入门笔记(6)-JSP技术","date":"2016-02-06T02:46:12.000Z","path":"2016/02/06/2016-02-06-javaweb-note-6-JSP/","text":"JSP：Java Server Pages，一种动态web资源的开发技术 API文档 JSP 2.3 API - Apache Tomcat 8.0.30 调用和运行原理JSP本质是一个servlet. 每个JSP页面在第一次被访问时，WEB容器会把请求交给JSP引擎(即一个JAVA程序)处理。JSP引擎先将JSP翻译成一个_jspServlet(实质也是一个servlet)，然后按照servlet的调用方式进行调用。 服务器会将jsp先翻译成servlet，这个servlet位于tomcat服务器work目录，这jsp类的父类是org.apache.jasper.runtime.HttpJspBase,这个HttpJspBase类继承自HttpServlet 向服务器发请求会调用servlet的service方法;同样地，访问jsp会调用这个JSP类的_jspService方法。 JSP中的标签语言会在_jspService方法中通过out.write()写出来；JSP中的Java代码会原封不动的搬到_jspService方法中。 在_jspService方法中提前准备好了一些对象供JSP调用，如：out,page,application,request,response等等。 由于第一次访问时会翻译成servlet，所以第一次访问较慢。 下面以demo1.jsp为例，展示对应的类%CATALINA_HOME%\\work\\Catalina\\localhost\\hello\\org\\apache\\jsp\\demo1_jsp.java中的部分代码 示例1:demo1.jsp 1234567891011121314151617181920&lt;%@ page import=\"java.util.Date\" %&gt;&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2016/1/27 Time: 16:45 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;demo1&lt;/title&gt;&lt;/head&gt;&lt;body&gt;当前时间时：&lt;% Date date = new Date(); out.write(date.toGMTString());%&gt;&lt;/body&gt;&lt;/html&gt; 示例2：_jspService方法中代码片段 123456789101112131415out.write(\"\\r\\n\");out.write(\"\\r\\n\");out.write(\"&lt;html&gt;\\r\\n\");out.write(\"&lt;head&gt;\\r\\n\");out.write(\" &lt;title&gt;demo1&lt;/title&gt;\\r\\n\");out.write(\"&lt;/head&gt;\\r\\n\");out.write(\"&lt;body&gt;\\r\\n\");out.write(\"当前时间时：\\r\\n\");Date date = new Date();out.write(date.toGMTString());out.write(\"\\r\\n\");out.write(\"&lt;/body&gt;\\r\\n\");out.write(\"&lt;/html&gt;\\r\\n\"); 示例3:_jspService方法中一些定义的对象 1234567final javax.servlet.jsp.PageContext pageContext;final javax.servlet.ServletContext application;final javax.servlet.ServletConfig config;javax.servlet.jsp.JspWriter out = null;final java.lang.Object page = this;javax.servlet.jsp.JspWriter _jspx_out = null;javax.servlet.jsp.PageContext _jspx_page_context = null; JSP语法 JSP模板元素:JSP页面中的HTML内容。定义了网页的基本骨架，即结构和外观。 JSP表达式:用于将程序数据输出到客户端。如，&lt;%=变量或表达式 %&gt;脚本表达式(无分号)，用于输出数据。 JSP脚本片段:用于在JSP页面中编写多行java代码,严格遵循java语法。一个JSP页面可有多个脚本片段，它们可以相互访问(和放在一对&lt;% %&gt;中一样),单个片段可不完整。 JSP声明:JSP中代码默认翻译到servlet的service方法中，而JSP声明中的代码被翻译到_jspService方法外。语法：&lt;%! java代码 %&gt;。 JSP注释:格式&lt;%-- 注释 --%&gt;，注释的内容不会发给浏览器。 JSP指令:是为JSP引擎设计的，定义了三个指令:page指令，include指令，taglib指令。语法:&lt;%@ 指令 属性名=&quot;值&quot; %&gt;。 page指令:定义各种属性，作用于整个JSP页面。 include指令:用于包含JSP文件(页头、页脚)。属于静态包含(编译时包含)，它包含的所有JSP会编译成一个servlet。 taglib指令:用于在JSP页面导入标签库。 JSP标签:也称为jsp Action元素，用于在jsp页面中提供业务逻辑功能，避免在jsp页面中直接写java代码而难以维护 JSP内置对象:九大隐式对象，request,response,session,application,config,page,exception,out,pageContext 关于上述语法的一些说明 page指令语法： 12345678910111213&lt;%@ page[ language=\"java\" ][ extends=\"package.class\" ][ import=\"&#123;package.class | package.*&#125;, ...\" ][ session=\"true | false\" ][ buffer=\"none | 8kb | sizekb\" ][ autoFlush=\"true | false\" ][ isThreadSafe=\"true | false\" ][ info=\"text\" ][ errorPage=\"relativeURL\" ][ contentType=\"mimeType [ ;charset=characterSet ]\" | \"text/html ; charset=ISO-8859-1\" ][ isErrorPage=\"true | false\" ]%&gt; errorPage:错误提示页面。也可在web.xml的&lt;error-page&gt;标签配置，异常处理页面。在page指令设置的优先级高于在web.xml配置。 pageEncoding:JSP引擎以何种码表翻译JSP,该值需和JSP文件的保存编码一致，且若要在浏览器正确显示，还要和contentType一致。 动态包含(运行时包含):request.getRequestDispatcher(&quot;/public/head.jsp&quot;).include(request,response),涉及到的jsp会生成单独的servlet，即有多个servlet，在浏览器访问时包含。静态包含性能优于动态包含 JSP常用标签 &lt;jsp:include&gt;:pageContext.include(),动态包含 &lt;jsp:forward&gt; &lt;jsp:param&gt; 九大隐式对象JSP引擎在调用JSP对应的_jspServlet时，会传递和创建9个web开发相关的对象供使用。后两者(out和pageContext)为JSP独有 request response session application config page exception out pageContext out隐式对象out隐式对象:用于向客户端发送文本数据。通过调用pageContext对象的getOut方法返回，类型为JspWriter，作用和ServletResponse.getWriter返回的PrintWriter对象相似。 JspWriter相当于自带缓存功能的PrintWriter,设置page指令的buffer属性课调整缓存大小。满足如下条件之一，out对象才调用ServletResponse.getWriter方法，并通过返回的PrintWriter对象将out对象的缓冲区的内容真正写入到servlet引擎提供的缓冲区中： 设置page指令的buffer属性关闭的out对象的缓存功能 out对象的缓冲区已满 整个JSP页面结束 例子： 1234&lt;% out.write(\"out.write&lt;br/&gt;\"); response.getWriter().write(\"response.getWriter.write&lt;br/&gt;\");%&gt; 浏览器显示： 12response.getWriter.writeout.write 可见，由于out有缓冲，所以后显示。 pageContext对象pageContext对象:是JSP技术中最重要的一个对象，它代表JSP页面的运行环境 封装了对其他8大隐式对象的引用(主要用于自定义标签开发) 自身是一个域对象，可用来保存数据(page域存的东西只能在页面范围内拿得出来) 封装了web开发中的一些常用操作(提供管理所有域的入口)，如：引入和跳转其他资源、检索其他域对象中的属性等 Class PageContext的API文档 javax.servlet.jsp:Class PageContext javaweb中的四个域: application域:应用程序范围,servletContext,对应的常量PageContext.APPLICATION_SCOPE session域:会话范围,session,对应的常量PageContext.SESSION_SCOPE resquet域:请求范围,request,对应的常量PageContext.REQUEST_SCOPE page域:页面范围,pageContext,对应的常量PageContext.PAGE_SCOPE findAttribute(java.lang.String name)查找各个域中的属性，是PageContext从父类javax.servlet.jsp.JspContext继承的，实现了父类的抽象方法。会依次从page,request,session,application域中寻找相应的属性，找到为止。 jsp映射和查错jsp映射 在webxml的&lt;servlet&gt;标签中加&lt;jsp-file&gt;标签，其他的和servlet映射一样 查找jsp页面中的错误 JSP页面中的语法格式有问题，导致不能翻译成servlet源文件，JSP引擎将提示这类错误在JSP页面中的位置以及相关信息 JSP页面中的语法格式没有问题，但翻译承德servlet源文件出现java语法问题导致源文件编译不通过，JSP引擎将提示这类错误在JSP页面中的位置以及相关信息 JSP页面翻译成的servlet程序运行时出现异常，这和普通java程序运行时错误完全一样，java虚拟机将提示错误在servlet源文件中的位置以及相关信息 jsp与JavaBeanJavaBean是一个遵循特定写法的java类，JavaBean常用于封装数据，具有如下热点： 该java类必须有一个无参的构造函数 属性必须私有化 私有化的属性必须通过public类型的方法暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。 JSP中提供了三个关于JavaBean的标签： &lt;jsp:useBean&gt;:用于在JSP页面中查找或实例化一个JavaBean组件 &lt;jsp:setProperty用于在JSP页面中设置一个JavaBean组件的属性 &lt;jsp:getProperty&gt;:用于在JSP页面中获取一个JavaBean组件的属性 一些细节 &lt;jsp:useBean&gt;标签的标签体只在实例化bean时才执行 &lt;jsp:setProperty&gt;可用请求参数给bean属性赋值，支持8种基本数据类型的转换(把客户机提交的字符串转成相应的8种基本类型赋到bean的属性上) 在标签中将property=&quot;*&quot;，用所有请求参数为bean赋值，请求参数名称和bean属性名称必须要一致 如果JavaBean实例对象的某个属性值为null,那么使用&lt;jsp:getProperty&gt;标签输出结果为“null”字符串","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://brianway.github.io/tags/JavaWeb/"}]},{"title":"javaweb入门笔记(5)-cookie和session","date":"2016-02-06T02:44:12.000Z","path":"2016/02/06/2016-02-06-javaweb-note-5-cookie-and-session/","text":"Cookie是客户端技术；Session是服务器端技术。 API: javax.servlet.http:Class Cookie javax.servlet.http:Interface HttpSession cookie一些细节： 一个cookie只能标识一种信息，至少含有标识该信息的名称和值 浏览器一般只允许存放300个cookie，每个站点最多存放20个，每个cookie大小限制为4KB 默认是会话级别cookie(存储于浏览器内存)，浏览器进程关闭则删除。有效期通过maxAge设置，存于硬盘，0表示删除 删除cookie时，path必须一致，否则不会删除 sessionsession对象由服务器创建,一个浏览器(会话)独占一个session对象 session对象由服务器创建生命周期 创建：调用request对象的getSession方法后才会创建session对象;getSession(false)只获取， 不创建 销毁：默认30分钟没人使用则自动销毁。失效时间可在web.xml的&lt;session-config&gt;标签中使用&lt;session-timeout&gt;，单位分钟；也可调用session对象的invalidate方法销毁 实现原理session基于cookie实现，将JSESSIONID写回浏览器，这个cookie(JSESSIONID)默认没设置有效期,关浏览器即销毁。可以自行回写JSESSIONID覆盖原cookie值 示例代码片段： 12345678protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; HttpSession session = req.getSession(); String sessionid = session.getId(); Cookie cookie = new Cookie(\"JSESSIONID\",sessionid); cookie.setPath(\"/s1\"); cookie.setMaxAge(30*60); resp.addCookie(cookie);&#125; 应用案例 用户登录 防止表单重复提交 一次性验证码的校验 小Tips 一般大型网站不用session,使用cookie,减小服务器压力 若浏览器禁用cookie,需使用url自带sessionid，相关方法:encodeURL和encodeRedirectURL 禁止表单重复提交：在javascript或者服务器实现。javascript防不死，用户可通过修改js、自建表单提交，刷新页面，后退等方法重复提交；服务器实现是给每个表单一个随机表单号 生成表单号使用“令牌发生器”，为保证唯一性(减小重复概率)，使用单例。 base64编码，三字节变四字节，每6位变8位(一字节)，高位补零，每字节最大值为63，故得名。 md5，常用于保存密码(可能为防止破解会加随机数)，校验数据完整性 防止表单重复提交之令牌例子： 12345678910111213141516171819202122232425262728293031323334353637383940package org.iot.data;import sun.misc.BASE64Encoder;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Random;/** * Created by brian on 2016/1/27. */public class TokenProcessor &#123;//令牌 /** * 1.构造方法私有 * 2.自己创建一个 * 3.对外暴露一个方法，允许获取上面创建的对象 */ private TokenProcessor()&#123;&#125; private static final TokenProcessor instance = new TokenProcessor(); public static TokenProcessor getInstance()&#123; return instance; &#125; public String genetateToken()&#123; String token = System.currentTimeMillis()+new Random().nextInt()+\"\"; try &#123; MessageDigest md = MessageDigest.getInstance(\"md5\"); byte [] md5 = md.digest(token.getBytes()); //base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(md5); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); throw new RuntimeException(e); &#125; &#125;&#125; 三个域对象 Session Request ServletContext 容器选用经验： 数据显示完了就没用了，则选用Request 数据除了显示外，稍后还会用，则选用Session 数据除了显示外，不仅稍后会用，还会给别人用，则选用ServletContext","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://brianway.github.io/tags/JavaWeb/"}]},{"title":"javaweb入门笔记(4)-request和response","date":"2016-02-06T02:30:12.000Z","path":"2016/02/06/2016-02-06-javaweb-note-4-request-and-response/","text":"API: Interface HttpServletResponse Interface HttpServletRequest response输出数据程序以什么码表输出，就一定要控制浏览器以什么码表打开。可有如下两种写法： response.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=UTF-8&quot;) response.setContentType(&quot;text/html;charset=UTF-8&quot;)(默认调用setHeader和setCharacterEncoding) 把分号;错写成逗号,，浏览器会提示下载 用html技术的&lt;meta&gt;标签可以模拟一个http响应头，&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; response可用setCharacterEncoding方法设置码表。字符流输出：PrintWritet-&gt;response-&gt;浏览器,response-&gt;浏览器默认使用iso-8859编码 文件下载使用ServerContext的getRealPath方法,再InputStream和OutputStream 如果下载文件是中文名为中文，则文件名需要经过url编码URLEncoder.encode 随机图片使用BufferedImage在内存生成图片，再使用ImageIO输出。 画图使用Graphics,旋转使用Graphics2D 汉字的区间：\\u4e00-\\u9fa5 刷新和缓存 刷新：一般不在servlet里加refresh头，而是在jsp加入&lt;meta&gt;头模拟。 缓存：加入expires头,当前时间+要缓存的时长 请求重定向重定向：设置状态码和location头即可，或者直接使用response的sendRedirect方法。向服务器两次请求。浏览器会改变地址栏，一般适用于登录、购物等场景。 转发:则是调用ServletContex对象的getRequestDispatcher方法，再调用forward方法。向服务器一次请求，浏览器地址栏不变。 一些细节： getOutputStream和getWriter方法跟别用于输出二进制数据、输出文本数据的ServletOutputStream、Printwriter对象，这两个方法相互排斥，只能调用其中一个，否则抛IllegalStateException异常。 response的输出流会自己关闭。Servlet的service方法结束后，Servlet引擎会检查并调用close方法关闭该输出流对象。 request URI:标识某个资源 URL:标识互联网上某个资源 一些方法 getRequestURI用于权限拦截，访问统计 getRemoteAddr用于得到客户机IP地址 getMethod得到客户机请求方式 requst对象获取数据的四种方式 getParameter getParameterNames getParameterValues getParameterMap(可结合JavaBean使用) (getInputStream用于文件上传) 中文乱码url后面如果有中文数据，需要编码后再提交 表单提交的数据使用的码表和该页面的码表一致，而getParameter方法默认使用ISO-8859码表。 解决： 对于post提交的数据，在获取数据前要使用request对象的setCharacterEncoding设置码表。 对于get提交的数据，只能手工解决。先对数据调用getBytes(&quot;ISO-8859-1&quot;)获取二进制字节，再用特定码表构建字符串。 超链提交的中文，解决办法同get提交的数据。 也可以通过改服务器配置来解决乱码问题，但一般不建议使用。 URIEncoding:改tomcat的配置文件conf/server.xml的连接器&lt;Connector&gt;中的URIEncoding属性 useBodyEncodingForURI:将conf/server.xml的连接器&lt;Connector&gt;中的useBodyEncodingForURI置为true 请求转发应用场景：MVC设计模式 model : javabean; view : jsp; controller : servlet 使用request域对象把数据带给转发资源。调用request对象的getRequestDispatcher方法，再调用forward方法。一次请求，浏览器地址栏不变。 forward一些细节 不能在关闭输出流后再调用转发，也不能调用两次，否则会抛出异常。 跳转之前会清空response中的数据。即数据只是写入到缓冲区而没真正输出到客户端，则可调用forward方法，原来写入到缓冲区的内容被清空，但响应头字段信息保持。 include方法可以用于包含一些公共页面(一般不在servlet中包含) 地址的写法以斜杠/开头。如果是给服务器用，则/代表当前web应用；如果给浏览器用，则/代表网站。 例子:目录结构如下 123456mail---------------------------Web应用所在目录 |----form1.html |----WEB-INF目录 |---------classes目录 |---------lib目录 |---------web.xml request.getRequestDispatcher(&quot;/form1.html&quot;) response.sendRedirect(&quot;mail/form1.html&quot;) this.getServletContext().getRealPath(&quot;/form1.html&quot;) this.getServletContext().getResourceAsStream(&quot;/form1.html&quot;) &lt;a href=&quot;/mail/form1.html&quot;&gt; &lt;form action=&quot;/mail/form1.html&quot;&gt; 其中，1,3,4是给服务器用;2,5,6是浏览器用 防盗链读取referer请求头，不合要求则重定向。","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://brianway.github.io/tags/JavaWeb/"}]},{"title":"javaweb入门笔记(3)-Servlet","date":"2016-02-06T02:29:12.000Z","path":"2016/02/06/2016-02-06-javaweb-note-3-servlet/","text":"servlet入门开发步骤： 编写一个java类，实现servlet接口 把开发好的java类部署到web服务器 API文档 Servlet API Documentation 生命周期相关方法(life-cycle methods) Servlet的生命周期通过java.servlet.Servlet接口中的init()、service()、和destroy()方法表示。Servlet的生命周期有四个阶段：加载并实例化、初始化、请求处理、销毁。（见文末【参考链接】） 手动编写第一个servlet1.在tomcat中新建一个web应用hello，在web应用中新建一个WEB-INF/classes目录 2.在classes目录新建一个FirstServlet 1234567891011package org.iot;import java.io.*;import javax.servlet.*;public class FirstServlet extends GenericServlet&#123; public void service(ServletRequest req,ServletResponse res)throws ServletException,java.io.IOException&#123; OutputStream out = res.getOutputStream(); out.write(\"hello servlet!!!\".getBytes()); &#125;&#125; 3.编译，javac -cp %CATALINA_HOME%/lib/servlet-api.jar -d . FirstServlet.java,命令行手动编译参考这里 4.在WEB-INF目录中新建一个web.xml文件，配置servlet的对外访问路径 5.启动tomcat访问 servlet的调用过程和生命周期时序图 servlet的调用过程和生命周期 servlet开发的一些细节 标签:&lt;servlet&gt;包含&lt;servlet-name&gt;和&lt;servlet-class&gt;；&lt;servlet-mapping&gt;包含&lt;servlet-name&gt;和&lt;url-pattern&gt; 映射:web.xml中一个&lt;servlet&gt;可对应多个&lt;servlet-mapping&gt; 通配符:&lt;servlet-mapping&gt;的&lt;url-pattern&gt;可以使用通配符，两种固定格式：*.扩展名；以/开头，以/*结尾 对象:servlet由servlet引擎调用，不能独立运行。客户端多次请求，服务器只创建一个servlet实例，之后驻留内存中继续服务直至web容器退出才销毁它。 请求:服务器针对客户端的每一次请求都会创建新的request和response对象(它们的生命周期很短)，传给service方法。 加载:servlet实例的创建和init方法的调用是在第一次请求时，而非服务器启动时，除非在&lt;servlet&gt;标签配置&lt;load-on-start-up&gt;,数字越小优先级越高 缺省:映射路径为正斜杠/，则为当前web应用的缺省servlet,不匹配的都交给缺省 线程安全:访问同一资源会引发线程安全问题; SingleThreadModel标记接口(已弃用) ServletConfig:在&lt;servlet&gt;标签配置&lt;init-param&gt;，通过getServletConfig方法获得配置。可配置输出字符集，读哪个配置文件等等。 ServletContext:代表当前web应用，含有一些web应用全局性方法，实现web资源共享、servlet转发等。通过ServletConfig.getServletContext方法获得，在&lt;context-param&gt;标签配置。 ServletContextAPI:Interface ServletContext 概念 一个web应用所有servlet共享同一个ServletContext对象，可实现数据共享。ServletContext被称为context域对象。 域：作用范围；context域：整个应用程序范围。 ServletContext域： 这是一个容器 说明了这个容器的作用范围，也就是应用程序范围 转发:客户机一次请求；重定向：客户机两次请求 作用 获取web应用的初始化参数 实现servlet转发 利用ServletContext对象读取资源文件 获得文件路径 读取资源文件的三种方式 .properties文件（属性文件） 配置文件：properties文件和xml文件；数据有关系使用xml文件，没有关系则使用properties文件。 1.通过ServletContext的getResourceAsStream方法，读取properties文件 模板代码(注意文件位置不同写路径会不同)： 123InputStream in = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/org/iot/servlet/db.properties\");Properties properties = new Properties();//mapproperties.load(in); 2.通过servletContext的getRealPath方法得到资源的绝对路径，再通过传统方式(FileInputStream)读取 3.通过类装载器去读，ClassLoader的getResourceAsStream(如果读取资源文件的程序不是servlet)，文件不能太大。只装载一次，所以如要读到更新后的数据，通过类装载的方式得到资源文件的位置，再通过传统方式读取资源文件的数据（用getResource得到path，再用FileInputStream） 参考链接 servlet和Jsp生命周期解读","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://brianway.github.io/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://brianway.github.io/tags/Servlet/"}]},{"title":"javaweb入门笔记(2)-http入门","date":"2016-02-06T02:04:12.000Z","path":"2016/02/06/2016-02-06-javaweb-note-2-http/","text":"对HTTP协议早有了解，最近在看javaweb，视频中讲到了这部分，就把视频的内容整理归纳下 请求(Request)一个完整的HTTP请求包括：一个请求行、若干请求头、以及实体内容 请求头字段 Accept:用于告诉服务器，客户机支持的数据类型 Accept-Charset:用于告诉服务器，客户机采用的编码 Accept-Encoding:用于告诉服务器，客户机支持数据压缩格式 Accept-Language:客户机的语言环境 Host:客户机通过这个头告诉服务器，想访问的主机名 If-Modified-Since:客户机通过这个头告诉服务器，资源的缓存时间 Refer:客户机通过这个头告诉服务器，它是从哪个资源访问服务器的(防盗链) User-Agent:客户机通过这个头告诉服务器，客户机的软件环境 Cookie:客户机通过这个头向服务器带数据 Connection:这个请求完了，是保持连接还是关闭 Range:断点下载 bytes=n1-n2,传输范围n1到n2字节 bytes=n-，传输web资源中第n个字节以后的所有内容 bytes=n,传输最后n个字节 响应(Response)一个HTTP响应代表服务器向客户端回送的数据，包括：一个状态行、若干消息头、以及实体内容 响应状态行 HTTP响应状态码简表 详情可参考 HTTP 状态消息 响应头字段 Location:这个头配合302状态码使用，用于告诉客户机找谁(location和302实现请求重定向) Server:服务器通过这个头，告诉浏览器服务器的类型 Content-Encoding:服务器通过这个头，数据的压缩格式(相关java知识:GZIPOutputStream,包装流/底层流) Content-Length:服务器通过这个头，告诉浏览器回送数据的长度 Content-Type:服务器通过这个头，告诉浏览器回送数据的类型 Last-Modified:服务器通过这个头，告诉浏览器当前资源的缓存时间 Refresh:服务器通过这个头，告诉浏览器隔多长时间刷新一次 Content-Disposition:服务器通过这个头，告诉浏览器以下载方式打开 Transfer-Encoding:服务器通过这个头，告诉浏览器数据的传送格式 Etag:缓存相关的头部，用于实时性要求高的系统 Expires:服务器通过这个头，告诉浏览器把回送的资源缓存多长时间，-1或0则不缓存 Cache-Control和Pragma:no-cache,服务器通过这两个头，也是控制浏览器不要缓存数据 Connection:断开连接/保持连接 Date:当前时间 Accept-Ranges:用来说明web服务器是否支持range。支持返回bytes;不支持返回none Content-Range:制定了返回web资源的字节范围，格式：n1-n2/n_total","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://brianway.github.io/tags/JavaWeb/"},{"name":"HTTP","slug":"HTTP","permalink":"https://brianway.github.io/tags/HTTP/"}]},{"title":"javaweb入门笔记(1)-Tomcat","date":"2016-02-06T01:55:12.000Z","path":"2016/02/06/2016-02-06-javaweb-note-1-Tomcat/","text":"下载链接 Apache Jakarta Project Tomcat官网 Tomcat目录层次结构 bin:存放启动和关闭Tomcat的脚本文件 conf:存放Tomcat服务器的配置文件 lib:存放Tomcat服务器的支撑jar包 logs:存放Tomcat的日志文件 temp:存放Tomcat运行时产生的临时文件 webapps:web应用所在的目录，即供外接访问的web资源的存放目录 work:Tomcat的工作目录 上面的内容直接可在Tomcat Doc-Directories and Files找到答案 启动Tomcat%CATALINA_HOME%/RUNNING.txt有详细步骤，简单来说，已经配置好JDK环境的话，windows下直接双击bin/startyp.bat就行了 默认端口是8080，改端口：tomcat的conf/server.xml的Connector标签 常见启动问题 JAVA_HOME环境变量 端口占用问题 Catalina_home环境变量的设置问题 官当配置文档多种配置方式 /META-INF/context.xml $CATALINA_BASE/conf/[enginename]/[hostname]/ conf/server.xml 具体参考Context配置 web应用1.web应用与web应用所在的目录一个web应用由多个静态web资源和动态web资源组成；组成web应用的这些文件会由一个目录组织起来，这个目录称为web应用所在目录 2.虚拟目录的映射把主机上的资源映射到服务器对外提供的访问路径上 3.例子 tomcat的conf/server.xml:&lt;Host&gt;元素-&gt;&lt;Context&gt;,一个&lt;Context&gt;对应一个web应用。 &lt;Context path=&quot;/virtual-path&quot; docBase=&quot;webapps-path&quot; /&gt;,重启web服务器 4.web应用的组成结构 1234567mail---------------------------Web应用所在目录 |----html、jsp、css、js等文件，根目录下的文件外界可以直接访问 |----WEB-INF目录 |---------classes目录(java类) |---------lib目录(java类运行所需的jar包) |---------web.xml(web应用的配置文件) WEB-INF 这个目录下的文件外界无法直接访问，由web服务器负责调用 Tomcat体系结构 Tomcat体系结构 tomcat的https连接器 keytool -genkey alias tomcat -keyalg RSA得到.keystore文件 Tomcat管理平台主页-&gt;Tomcat Manager 相关权限和用户配置在conf/tomcat-users.xml 相关小知识1.域名和主机名的区别 域名 sina.com 主机名 www.sina.com 2.url中主机名的作用： 用于访问DNS服务器获取IP 用于告诉代理服务器要访问哪个主机名 参考链接 Tomcat安装、配置、优化及负载均衡详解","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://brianway.github.io/tags/JavaWeb/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://brianway.github.io/tags/Tomcat/"}]},{"title":"java基础巩固笔记(5)-多线程之线程并发库","date":"2016-02-05T22:23:12.000Z","path":"2016/02/06/2016-02-06-javase-learn-note-5-ThreadPool/","text":"本文主要概述java.util.concurrent包下的相关类和使用方法 Package java.util.concurrent 原子性操作类java.util.concurrent.atomic包下的类: Package java.util.concurrent.atomic 线程池 java.util.concurrent:Class Executors 常用线程池几种常用的的生成线程池的方法： newCachedThreadPool newFixedThreadPool newScheduledThreadPool newSingleThreadExecutor newSingleThreadScheduledExecutor 例子：newFixedThreadPool 123456789ExecutorService threadPool = Executors.newFixedThreadPool(3);for(int i=0;i&lt;10;i++)&#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;);&#125; 单线程newSingleThreadExecutor可用于重启 用线程池启动定时器 例子：类似Timer的定时执行 12345678Executors.newScheduledThreadPool(3).scheduleAtFixedRate( new Runnable() &#123; @Override public void run() &#123; System.out.println(\"ScheduledThreadPool \"+Thread.currentThread().getName()); &#125; &#125;,3,1, TimeUnit.SECONDS ); Callable&amp;FutureExecutorService在Executor的基础上增加了一些方法，其中有两个核心的方法： Future&lt;?&gt; submit(Runnable task) &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) 这两个方法都是向线程池中提交任务，它们的区别在于Runnable在执行完毕后没有结果，Callable执行完毕后有一个结果。这在多个线程中传递状态和结果是非常有用的。另外他们的相同点在于都返回一个Future对象。Future对象可以阻塞线程直到运行完毕（获取结果，如果有的话），也可以取消任务执行，当然也能够检测任务是否被取消或者是否执行完毕。 Lock&amp;ConditionLockLock功能类似传统多线程技术里的synchronized，实现线程互斥，但更加面向对象。将需要互斥的代码片段放到lock.lock();和lock.unlock();之间。 例子 123456789101112class A&#123; private Lock lock = new ReentrantLock(); public void function()&#123; lock.lock(); try&#123; //功能代码 &#125;finally&#123; lock.unlock(); &#125; &#125;&#125; 读写锁 java.util.concurrent.locks:Class ReentrantReadWriteLock javaDoc文档读写锁例子,缓存: 1234567891011121314151617181920212223242526272829303132class CachedData &#123; Object data; volatile boolean cacheValid; final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() &#123; rwl.readLock().lock(); if (!cacheValid) &#123; // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); try &#123; // Recheck state because another thread might have // acquired write lock and changed state before we did. if (!cacheValid) &#123; data = ... cacheValid = true; &#125; // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); &#125; finally &#123; rwl.writeLock().unlock(); // Unlock write, still hold read &#125; &#125; try &#123; use(data); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125; &#125; 重点注意在释放写锁前加读锁那部分代码，注释为// Downgrade by acquiring read lock before releasing write lock。自己挂了写锁，再挂读锁是可以的，这面涉及的技巧以后再研究。 ConditionCondition类似于传统多线程技术中的Object.wait和Object.notify,实现线程间同步。 javaDoc文档例子，可阻塞队列 class BoundedBuffer例子 12345678910111213141516171819202122232425262728293031323334353637class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; 使用了两个condition 同步工具 Semaphore 类似占坑 CyclicBarrier 阶段性使进度一致 CountDownLatch 一人通知多人/多人通知一人 Exchanger 线程间数据交换，都到达则自然交换 参考资料 深入浅出 Java Concurrency (29): 线程池 part 2 Executor 以及Executors 《深入浅出 Java Concurrency》目录","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://brianway.github.io/tags/多线程/"}]},{"title":"java基础巩固笔记(5)-多线程之共享数据","date":"2016-02-05T22:20:12.000Z","path":"2016/02/06/2016-02-06-javase-learn-note-5-ShareData/","text":"本文主要总结线程共享数据的相关知识，主要包括两方面:一是某个线程内如何共享数据，保证各个线程的数据不交叉；一是多个线程间如何共享数据，保证数据的一致性。 线程范围内共享数据自己实现的话，是定义一个Map,线程为键，数据为值,表中的每一项即是为每个线程准备的数据,这样在一个线程中数据是一致的。 例子 1234567891011121314151617181920212223242526272829303132333435363738394041package com.iot.thread;import java.util.HashMap;import java.util.Map;import java.util.Random;/** * Created by brian on 2016/2/4. */public class ThreadScopeShareData &#123; //准备一个哈希表，为每个线程准备数据 private static Map&lt;Thread,Integer&gt; threadData = new HashMap&lt;&gt;(); public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++)&#123; new Thread( new Runnable() &#123; @Override public void run() &#123; int data = new Random().nextInt(); threadData.put(Thread.currentThread(),data); System.out.println(Thread.currentThread()+\" put data：\"+data); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; static class A&#123; public void get()&#123; int data = threadData.get(Thread.currentThread()); System.out.println(\"A from \"+Thread.currentThread()+\" get data \"+data); &#125; &#125; static class B&#123; public void get()&#123; int data = threadData.get(Thread.currentThread()); System.out.println(\"B from \"+Thread.currentThread()+\" get data \"+data); &#125; &#125;&#125; 上述代码偶尔会报异常： 1234Exception in thread &quot;Thread-0&quot; java.lang.NullPointerException at com.iot.thread.ThreadScopeShareData$A.get(ThreadScopeShareData.java:29) at com.iot.thread.ThreadScopeShareData$1.run(ThreadScopeShareData.java:21) at java.lang.Thread.run(Thread.java:745) 具体原因还不知道 ThreadLocal类API: java.lang:Class ThreadLocal&lt;T&gt; 单变量 使用ThreadLocal类型的对象代替上面的Map即可 多变量 定义一个对象来封装多个变量，然后在ThreadLocal中存储整个对象 多变量时，最好将ThreadLocal类放在数据类的内部，数据类采用单例模式，这样，新建对象和获取对象都会更方便，同时封装性更强。 示例代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.iot.thread;import java.util.Random;/** * Created by brian on 2016/2/4. */public class ThreadLocalTest &#123; private static ThreadLocal&lt;Integer&gt; threadInger = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; int data = new Random().nextInt(100); threadInger.set(data); System.out.println(Thread.currentThread()+\" put data：\"+data); MyThreadScopeData.getThreadInstance().setName(Thread.currentThread().toString()); MyThreadScopeData.getThreadInstance().setAge(data%10); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; static class A&#123; public void get()&#123; int data = threadInger.get(); System.out.println(\"A from \"+Thread.currentThread()+\" get data \"+data); MyThreadScopeData myThreadScopeData = MyThreadScopeData.getThreadInstance(); System.out.println(\"A from \"+myThreadScopeData); &#125; &#125; static class B&#123; public void get()&#123; int data = threadInger.get(); System.out.println(\"B from \"+Thread.currentThread()+\" get data \"+data); MyThreadScopeData myThreadScopeData = MyThreadScopeData.getThreadInstance(); System.out.println(\"B from \"+myThreadScopeData); &#125; &#125;&#125;/** * 将多变量封装起来的数据类 * 单例模式，内置ThreadLocal类型变量 */class MyThreadScopeData&#123; private MyThreadScopeData()&#123;&#125; private static ThreadLocal&lt;MyThreadScopeData&gt; data = new ThreadLocal&lt;&gt;(); public static MyThreadScopeData getThreadInstance()&#123; MyThreadScopeData instance = data.get(); if(instance == null)&#123; instance = new MyThreadScopeData(); data.set(instance); &#125; return instance; &#125; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; String reVal = super.toString()+\"-&#123;name,age&#125;\"+\":&#123;\"+getName()+\",\"+getAge()+\"&#125;\"; return reVal; &#125;&#125; 多线程访问共享数据几种方式 线程执行代码相同，使用同一Runnable对象，Runnable对象中有共享数据 线程执行代码不同，将共享数据封装在另一对象中（操作数据的方法也在该对象完成），将这个对象逐一传递给各个Runnable对象。[本质：共享数据的对象作为参数传入Runnable对象] 线程执行代码不同，将Runnable对象作为某一个类的内部类，共享数据作为这个外部类的成员变量（操作数据的方法放在外部类）。[本质:不同内部类共享外部类数据] 结合上两种方式，将共享数据封装在另一对象中（操作数据的方法也在该对象完成），该对象作为这个外部类的成员变量，将Runnable对象作为内部类 最后一种方式的示例: 设计5个线程，其中三个线程每次对j增加1，另外两个线程对j每次减少1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.iot.thread;/** * Created by brian on 2016/2/4. */public class MutiThreadShareData &#123; private static MutiShareData mutiShareData = new MutiShareData(); public static void main(String[] args) &#123; for(int i=0;i&lt;3;i++)&#123; new Thread( new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread()+\":&#123;j from \"+ mutiShareData.getJ()+\" + to: \"+mutiShareData.increment()+\"&#125;\"); &#125; &#125; ).start(); &#125; for(int i=0;i&lt;2;i++)&#123; new Thread( new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread()+\":&#123;j from \"+ mutiShareData.getJ()+\" - to: \"+mutiShareData.decrement()+\"&#125;\"); &#125; &#125; ).start(); &#125; &#125;&#125;/** * 将共享数据封装在另一对象中（操作数据的方法也在该对象完成） */class MutiShareData&#123; private int j = 0; public synchronized int increment()&#123; return ++j; &#125; public synchronized int decrement()&#123; return --j; &#125; public synchronized int getJ() &#123; return j; &#125; public synchronized void setJ(int j) &#123; this.j = j; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://brianway.github.io/tags/多线程/"}]},{"title":"java基础巩固笔记(5)-多线程之传统多线程","date":"2016-02-05T22:18:12.000Z","path":"2016/02/06/2016-02-06-javase-learn-note-5-TraditionalThread/","text":"传统线程技术 传统创建线程方式1.继承Thread类，覆盖run方法 12Thread t = new Thread();t.start(); 2.实现Runnable接口 Runnable不是线程，是线程要运行的代码的宿主。 1.看看Thread类源码，捋清Runnable，target,run,start关系 Runnable是一个接口 target是Thread类中类型为Runnable，名为target的属性 run是Thread类实现了Runnable的接口，重写的方法。 start是启动线程的方法 在Thread类中，调用关系为：start-&gt;start0-&gt;run-&gt;target.run Thread类的run方法源码 12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; Thread类的target属性 12/* What will be run. */private Runnable target; target属性由private void init(ThreadGroup g, Runnable target, String name,long stackSize, AccessControlContext acc)方法初始化。init方法在Thread类的构造方法里被调用 2.匿名内部类对象的构造方法如何调用父类的非默认构造方法 传统定时器技术API： java.util:Class Timer 例子：一个定时器实现交替2秒、3秒打印 1234567891011121314static int count = 0;public static void main(String[] args) &#123; class MyTimerTask extends TimerTask&#123; @Override public void run() &#123; System.out.println(Thread.currentThread()+\" bomb!\"); new Timer().schedule(new MyTimerTask(), 2000+1000*(count++%2)); &#125; &#125; //3s后开启定时器 new Timer().schedule(new MyTimerTask(),3000);&#125; 可以使用quarlz开源工具 互斥关键字:synchronized，检查锁对象 synchronized(this) synchronized void function(){} synchronized(A.class) 同步经验： 要用到共同数据(包括同步锁)或共同算法的若干个方法应该归在同一个类身上，这种设计体现了高聚类和程序的健壮性。 同步互斥不是在线程上实现，而是在线程访问的资源上实现，线程调用资源。 例子: 子线程循环5次，主线程循环10次，如此交替50次 设计： 使用一个Business类来包含子线程和主线程要运行的代码，从而，该类的对象成为加锁的对象。同步互斥在该类实现，由线程调用该类的方法，即调用了资源。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Created by brian on 2016/2/4. */public class TraditionalThreadCommunication &#123; public static void main(String[] args) &#123; Business business = new Business(); new Thread( new Runnable() &#123; @Override public void run() &#123; for(int i=1;i&lt;=50;i++)&#123; business.sub(i); &#125; &#125; &#125; ).start(); for(int i=1;i&lt;=50;i++)&#123; business.main(i); &#125; &#125;&#125;class Business&#123; private boolean bShouldSub = true; public synchronized void sub(int i)&#123; while(!bShouldSub)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=5;j++)&#123; System.out.println(\"sub thread count \"+j+\",\"+i+\"/50\"); &#125; bShouldSub = false; this.notify(); &#125; public synchronized void main(int i)&#123; while(bShouldSub)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=10;j++)&#123; System.out.println(\"main thread count \"+j+\",\"+i+\"/50\"); &#125; bShouldSub = true; this.notify(); &#125;&#125; 判断条件时，while与if的区别:while防止伪唤醒","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://brianway.github.io/tags/多线程/"}]},{"title":"java基础巩固笔记(4)-实现AOP功能的封装与配置的小框架","date":"2016-02-03T06:46:12.000Z","path":"2016/02/03/2016-02-03-javase-learn-note-4-AopFramework/","text":"本文通过是动态代理实现的AOP功能的封装与配置的小框架.加深对动态代理和AOP编程的理解 设计根据配置文件的键xxx对应的值(类全名)创建相应类的对象。 当且仅当xxx对应的值为com.iot.proxy.aopframework.ProxyFactoryBean时，则生成相应的动态代理类对象。代理对象的目标类和通知实现类分别由xxx.target和xxx.advice配置 配置文件 config.propertiest位于aopframework包下 xxx代表要加载的类 xxx.advice代表通知接口的某个实现类 xxx.target代表委托类 1234#xxx=java.util.ArrayListxxx=com.iot.proxy.aopframework.ProxyFactoryBeanxxx.advice=com.iot.proxy.MyAdvicexxx.target=java.util.ArrayList 包:com.iot.proxy.aopframework,有如下几个类/接口： BeanFactory,用于读取配置文件，根据配置创建相应的对象 ProxyFactoryBean,用于生成代理对象，含有两个私有属性:目标和通知 Advice,通知接口，用于把切面的代码以对象的形式传递给InvocationHandler的的invoke方法 MyAdvice,Advice接口的一个实现类，打印执行方法前的时间及执行耗时 AopFrameWorkTest，测试效果 代码Advice接口12345678910package com.iot.proxy.aopframework;import java.lang.reflect.Method;/** * Created by brian on 2016/2/2. */public interface Advice &#123; void beforeMethod(Method method); void aftereMethod(Method method);&#125; MyAdvice类123456789101112131415161718192021package com.iot.proxy.aopframework;import java.lang.reflect.Method;/** * Created by brian on 2016/2/2. */public class MyAdvice implements Advice&#123; long beginTime = 0 ; @Override public void beforeMethod(Method method) &#123; System.out.println(method.getName()+\" before at \"+beginTime); beginTime = System.currentTimeMillis(); &#125; @Override public void aftereMethod(Method method) &#123; long endTime = System.currentTimeMillis(); System.out.println(method.getName()+\" cost total \"+ (endTime-beginTime)); &#125;&#125; BeanFactory类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.iot.proxy.aopframework;import java.io.IOException;import java.io.InputStream;import java.util.Properties;/** * Created by brian on 2016/2/2. */public class BeanFactory &#123; Properties properties = new Properties(); public BeanFactory(InputStream inputStream)&#123; try &#123; properties.load(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public Object getBean(String name)&#123; String className = properties.getProperty(name); Object bean = null; try &#123; Class clazz = Class.forName(className); bean = clazz.newInstance(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; if (bean instanceof ProxyFactoryBean)&#123; ProxyFactoryBean proxyFactoryBean = (ProxyFactoryBean)bean; Advice advice = null; Object target = null; try &#123; advice = (Advice) Class.forName(properties.getProperty(name+\".advice\")).newInstance(); target = Class.forName(properties.getProperty(name+\".target\")).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; proxyFactoryBean.setAdvice(advice); proxyFactoryBean.setTarget(target); Object proxy = ((ProxyFactoryBean) bean).getProxy(); return proxy; &#125; return bean; &#125;&#125; ProxyFactoryBean类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.iot.proxy.aopframework;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * Created by brian on 2016/2/3. */public class ProxyFactoryBean &#123; private Object target; private Advice advice; public Object getProxy()&#123; Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; advice.beforeMethod(method); Object retVal = method.invoke(target,args); advice.aftereMethod(method); return retVal; &#125; &#125; ); return proxy; &#125; public Object getTarget() &#123; return target; &#125; public void setTarget(Object target) &#123; this.target = target; &#125; public Advice getAdvice() &#123; return advice; &#125; public void setAdvice(Advice advice) &#123; this.advice = advice; &#125;&#125; AopFrameWorkTest类12345678910111213141516package com.iot.proxy.aopframework;import java.io.InputStream;import java.util.Collection;/** * Created by brian on 2016/2/3. */public class AopFrameWorkTest &#123; public static void main(String[] args) &#123; InputStream inputStream = AopFrameWorkTest.class.getResourceAsStream(\"config.properties\"); Object bean = new BeanFactory(inputStream).getBean(\"xxx\"); System.out.println(bean.getClass().getName()); ((Collection) bean).clear(); &#125;&#125; 输出 配置xxx=com.iot.proxy.aopframework.ProxyFactoryBean 输出为： 123com.sun.proxy.$Proxy0clear before at 0clear cost total 0 配置xxx=java.util.ArrayList 输出为： 1java.util.ArrayList 可以看出，只改变配置文件，就可改变代码的运行结果，从而达到灵活的效果","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"代理","slug":"代理","permalink":"https://brianway.github.io/tags/代理/"},{"name":"AOP","slug":"AOP","permalink":"https://brianway.github.io/tags/AOP/"}]},{"title":"java基础巩固笔记(4)-代理","date":"2016-02-03T06:43:13.000Z","path":"2016/02/03/2016-02-03-javase-learn-note-4-Proxy/","text":"代理是实现AOP(Aspect oriented program，面向切面编程)的核心和关键技术。 概念代理是一种设计模式，其目的是为其他对象提供一个代理以控制对某个对象的访问，代理类负责为委托类预处理消息，过滤消息并转发消息以及进行消息被委托类执行后的后续处理。为了保持行为的一致性，代理类和委托类通常会实现相同的接口 静态代理：由程序员创建代理类或特定工具自动生成源代码再对其编译，也就是说在程序运行前代理类的.class文件就已经存在。 动态代理：在程序运行时运用反射机制动态创建生成。 代理架构图 紫色箭头代表类的继承关系，红色连线表示调用关系 动态代理 JVM可以在运行期动态生成类的字节码，该类往往被用作动态代理类。 JVM生成的动态类必须实现一个或多个接口，所以这种只能用作具有相同接口的目标类的代理。 CGLIB库可以动态生成一个类的子类，一个类的子类也可作为该类的代理，这个可用来为没有实现接口的类生成动态代理类。 代理类可在调用目标方法之前、之后、前后、以及处理目标方法异常的catch块中添加系统功能代码。 创建动态类API: java.lang.reflect:Class Proxyjava.lang.reflect:Interface InvocationHandler 查看代理类方法列表信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.iot.proxy;import java.lang.reflect.*;import java.util.ArrayList;import java.util.Collection;/** * Created by brian on 2015/12/27. */public class ProxyTest &#123; public static void main(String[] args) throws Exception &#123; Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class); System.out.println(clazzProxy1); printConstructors(clazzProxy1); printMethods(clazzProxy1); &#125; /** * 打印构造方法列表 * @param clazz */ public static void printConstructors(Class clazz)&#123; System.out.println(\"-------------constructors list-------------\"); Constructor[] constructors = clazz.getConstructors(); System.out.print(getExecutableList(constructors)); &#125; /** * 打印成员方法列表 * @param clazz */ public static void printMethods(Class clazz) &#123; System.out.println(\"-------------methods list-------------\"); Method[] methods = clazz.getMethods(); System.out.print(getExecutableList(methods)); &#125; /** * 获取要打印的列表数据 * 每行一个方法,按照func(arg1,arg2)的格式 * @param executables * @return */ public static String getExecutableList(Executable[] executables)&#123; StringBuilder stringBuilder = new StringBuilder(); for (Executable executable : executables) &#123; String name = executable.getName(); stringBuilder.append(name); stringBuilder.append(\"(\"); Class[] clazzParams = executable.getParameterTypes(); for (Class clazzParam : clazzParams) &#123; stringBuilder.append(clazzParam.getName()).append(\",\"); &#125; if (clazzParams != null &amp;&amp; clazzParams.length != 0) &#123; stringBuilder.deleteCharAt(stringBuilder.length() - 1); &#125; stringBuilder.append(\")\\n\"); &#125; return stringBuilder.toString(); &#125;&#125; 输出结果： 1234567891011121314151617181920212223242526272829303132333435class com.sun.proxy.$Proxy0-------------constructors list-------------com.sun.proxy.$Proxy0(java.lang.reflect.InvocationHandler)-------------methods list-------------add(java.lang.Object)remove(java.lang.Object)equals(java.lang.Object)toString()hashCode()clear()contains(java.lang.Object)isEmpty()iterator()size()toArray([Ljava.lang.Object;)toArray()spliterator()addAll(java.util.Collection)stream()forEach(java.util.function.Consumer)containsAll(java.util.Collection)removeAll(java.util.Collection)removeIf(java.util.function.Predicate)retainAll(java.util.Collection)parallelStream()isProxyClass(java.lang.Class)getInvocationHandler(java.lang.Object)getProxyClass(java.lang.ClassLoader,[Ljava.lang.Class;)newProxyInstance(java.lang.ClassLoader,[Ljava.lang.Class;,java.lang.reflect.InvocationHandler)wait()wait(long,int)wait(long)getClass()notify()notifyAll() 创建实例对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 测试创建实例对象 * @throws NoSuchMethodException * @throws IllegalAccessException * @throws InvocationTargetException * @throws InstantiationException */private static void createProxyInstance( ) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123; /** * 方法1：先创建代理类，再使用反射创建实例对象 */ Class clazzProxy1 = Proxy.getProxyClass(Collection.class.getClassLoader(), Collection.class); Constructor constructor = clazzProxy1.getConstructor(InvocationHandler.class); Collection proxy1 = (Collection) constructor.newInstance(new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return null; &#125; &#125;); /** * 方法2：直接使用newProxyInstance方法创建实例对象 */ Collection proxy2 = (Collection)Proxy.newProxyInstance( Collection.class.getClassLoader(), new Class[]&#123;Collection.class&#125;, new InvocationHandler() &#123; ArrayList target = new ArrayList(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //ArrayList targetTmp = new ArrayList(); System.out.println(\"before invoke method: \"+method.getName()); return method.invoke(target,args); &#125; &#125;); proxy2.add(\"aaa\"); proxy2.add(\"bbb\"); System.out.println(proxy2.size()); System.out.println(proxy2); System.out.println(proxy2.getClass().getName());&#125; 输出结果： 1234567before invoke method: addbefore invoke method: addbefore invoke method: size2before invoke method: toString[aaa, bbb]com.sun.proxy.$Proxy0 上述代码相关说明: 若将method.invoke(target,args);改为method.invoke(proxy,args);会出现死循环 从输出结果可知，每次调用代理类的方法，实际都是调用invoke方法 若将method.invoke(target,args);改为method.invoke(targetTmp,args);，则proxy2.size()为0。因为每次调用invoke方法时，targetTmp为新的局部变量 Object类只有的hashCode, equals, or toString方法会被交到InvocationHandler，其他方法自己有实现，不交给handler,所以最后打印结果为com.sun.proxy.$Proxy0而不是Collection InvocationHandler对象的运行原理 InvocationHandler接口只有一个invoke方法，每次调用代理类的方法，即调用了InvocationHandler对象的invoke方法 invoke方法涉及三个要素： 代理对象 代理对象调用的方法 方法接受的参数 注：Object类的hashCode,equals,toString方法交给invoke,其他的Object类的方法，Proxy有自己的实现。 If a proxy interface contains a method with the same name and parameter signature as the hashCode, equals, or toString methods of java.lang.Object, when such a method is invoked on a proxy instance, the Method object passed to the invocation handler will have java.lang.Object as its declaring class. In other words, the public, non-final methods of java.lang.Object logically precede all of the proxy interfaces for the determination of which Method object to pass to the invocation handler. 动态代理的工作原理代理类创建时需要传入一个InvocationHandler对象，client调用代理类，代理类的相应方法调用InvocationHandler的的invoke方法，InvocationHandler的的invoke方法(可在其中加入日志记录、时间统计等附加功能)再找目标类的相应方法。 动态代理的工作原理图 面向切面编程把切面的代码以对象的形式传递给InvocationHandler的的invoke方法，invoke方法中执行该对象的方法就执行了切面的代码。 所以需要传递两个参数： 1.目标(Object target)2.通知(自定义的adviser类) 定义Advice接口 1234public interface Advice &#123; void beforeMethod(Method method); void aftereMethod(Method method);&#125; 一个实现Advice接口的类MyAdvice,用于打印执行方法前和执行后的时间 12345678910111213141516import java.lang.reflect.Method;public class MyAdvice implements Advice&#123; long beginTime = 0 ; @Override public void beforeMethod(Method method) &#123; System.out.println(method.getName()+\" before at \"+beginTime); beginTime = System.currentTimeMillis(); &#125; @Override public void aftereMethod(Method method) &#123; long endTime = System.currentTimeMillis(); System.out.println(method.getName()+\" cost total \"+ (endTime-beginTime)); &#125;&#125; 定义一个getProxy方法创建实例对象,接收两个参数:目标和通知 12345678910111213141516private static Object getProxy(final Object target,final Advice advice)&#123; Object proxy = Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; advice.beforeMethod(method); Object retVal = method.invoke(target,args); advice.aftereMethod(method); return retVal; &#125; &#125; ); return proxy;&#125; 调用： 1234Collection proxy3 = (Collection) getProxy(new ArrayList(),new MyAdvice());proxy3.add(\"111\");proxy3.add(\"222\");System.out.println(proxy3.size()); 输出: 1234567add before at 0add cost total 0add before at 1454433980839add cost total 0size before at 1454433980839size cost total 02 参考资料 Java动态代理的实现机制 Java基础加强总结(三)——代理(Proxy)","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"},{"name":"代理","slug":"代理","permalink":"https://brianway.github.io/tags/代理/"}]},{"title":"java基础巩固笔记(3)-类加载器","date":"2016-02-03T06:38:12.000Z","path":"2016/02/03/2016-02-03-javase-learn-note-3-ClassLoader/","text":"java类加载器就是在运行时在JVM中动态地加载所需的类，java类加载器基于三个机制：委托，可见，单一。 把 classpath 下的那些 .class 文件加载进内存，处理后形成可以被虚拟机直接使用的 Java 类型，这些工作是类加载器做的。 委托机制：指的是将加载类的请求传递给父加载器，如果父加载器找不到或者不能加载这个类，那么再加载他。 可见性机制：指的是父加载器加载的类都能被子加载器看见，但是子加载器加载的类父加载器是看不见的。 单一性机制：指的是一个类只能被同一种加载器加载一次。 默认类加载器系统默认三个类加载器: BootStrap ExtClassLoader AppClassLoader 类加载器也是java类，而BootStrap不是。 验证代码： 12345public class ClassLoaderTest &#123; public static void main(String[] args) &#123; System.out.println(System.class.getClassLoader()); &#125;&#125; 输出：null 如果使用System.out.println(System.class.getClassLoader().toString);，则报空指针异常: 1234567Exception in thread &quot;main&quot; java.lang.NullPointerException at com.iot.classloader.ClassLoaderTest.main(ClassLoaderTest.java:10) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144) 可见，System类是由BootStrap类加载器加载。 类加载器的委托机制类加载器的树状图 类加载器 一般加载类的顺序： 首先当前线程的类加载器去加载线程中的第一个类 如果类A应用了类B，java虚拟机将使用加载类A的类加载器来加载类B 还可以直接调用ClassLoader.loadClass()方法来制定某个类加载器去加载某个类 自定义类加载器的编写原理API: Class ClassLoader 模板方法设计模式 父类: loadClass(类加载的流程，模板) findClass供子类覆盖的、被loadClass方法调用的类加载逻辑 defineClass得到class文件转换成字节码 子类:覆盖findClass方法 例子： loadClass方法的源码 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; API文档中的例子: 1234567891011121314class NetworkClassLoader extends ClassLoader &#123; String host; int port; public Class findClass(String name) &#123; byte[] b = loadClassData(name); return defineClass(name, b, 0, b.length); &#125; private byte[] loadClassData(String name) &#123; // load the class data from the connection . . . &#125; &#125; 参考资料 java类加载机制工作原理 Java类加载器总结 - 寂静大海 - 博客频道 - CSDN.NET","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"}]},{"title":"将nutch2.3的bin/crawl脚本改写为java类","date":"2016-01-19T05:01:11.000Z","path":"2016/01/19/2016-01-19-nutch-translate-bin-crawl-shell-to-java/","text":"nutch1.8以后，以前的主控代码org.apache.nutch.crawl.Crawl类没了，只剩下对应的控制脚本bin/crawl，感觉在IDEA里面调试不方便，所以我了解了下shell脚本,根据nutch2.3的bin/crawl和bin/nutch脚本，把bin/crawl翻译成了java的Crawl类以便在IDEA里面调试 代码设计说明我参考了nutch1.7的crawl类，nutch2.3的bin/crawl和bin/nutch,尽量按照shell脚本的原组织结构和逻辑进行翻译，有些地方不能直接使用的，就稍作了修改。 主要的业务逻辑在public int run(String[] args)方法里 程序主入口是main，调用ToolRunner.run(NutchConfiguration.create(), new Crawl(), args);执行上面的run方法 public void binNutch4j(String jobName,String commandLine,String options)相当于bin/crawl脚本里函数__bin_nutch的功能 public int runJob(String jobName,String commandLine,String options)相当于脚本bin/nutch的功能，这里没有像脚本中那样用if-else，也没有使用switch-case,而是采用反射创建相应的job public void preConfig(Configuration conf,String options)用于根据带-D参数 commonOptions等指令设置每个Job的配置项 CLASS_MAP是静态(static)属性，一个记录JobName和对应的类名的映射关系的哈希表(HashMap) gora BUG说明我之前是在每个job是按照脚本使用batchId参数的，遇到了下面这个问题: Gora MongoDb Exception, can’t serialize Utf8 貌似是序列化问题，好像gora-0.6版本解决了这个BUG,但我的nutch代码是gora-0.5的，不会升级，所以就简单的把-batchId参数去掉，使用-all参数就行了，这点在代码里可以看到。 关于升级到gora-0.6,有空再研究好了。 通过这个脚本的改写，我了解了脚本的基本使用，同时对之前看的java反射等知识进行了实践，并对nutch的完整爬取流程、主要控制逻辑有了深刻的印象。主要是前面那个gora的BUG卡了我几天，我还以为自己翻译的有问题，看来调试能力还需要加强。 java代码这段代码是翻译nutch2.3的bin/crawl和bin/nutch脚本 Crawl类加到在org.apache.nutch.crawl包下，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306package org.apache.nutch.crawl;/** * Created by brianway on 2016/1/19. * @author brianway * @site brianway.github.io * org.apache.nutch.crawl.Crawl; */import org.apache.commons.lang.StringUtils;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.util.Tool;import org.apache.hadoop.util.ToolRunner;import org.apache.nutch.fetcher.FetcherJob;import org.apache.nutch.util.NutchConfiguration;import org.apache.nutch.util.NutchTool;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;import java.util.Random;// Commons Logging imports//import org.apache.hadoop.fs.*;//import org.apache.hadoop.mapred.*;//import org.apache.nutch.util.HadoopFSUtil;//import org.apache.nutch.util.NutchJob;//import org.apache.nutch.crawl.InjectorJob;//import org.apache.nutch.crawl.GeneratorJob;//import org.apache.nutch.fetcher.FetcherJob;//import org.apache.nutch.parse.ParserJob;//import org.apache.nutch.crawl.DbUpdaterJob;//import org.apache.nutch.indexer.IndexingJob;//import org.apache.nutch.indexer.solr.SolrDeleteDuplicates;public class Crawl extends NutchTool implements Tool&#123; public static final Logger LOG = LoggerFactory.getLogger(Crawl.class); /* Perform complete crawling and indexing (to Solr) given a set of root urls and the -solr parameter respectively. More information and Usage parameters can be found below. */ public static void main(String args[]) throws Exception &#123; int res = ToolRunner.run(NutchConfiguration.create(), new Crawl(), args); System.exit(res); &#125; //为了编译过 @Override public Map&lt;String, Object&gt; run(Map&lt;String, Object&gt; args) throws Exception &#123; return null; &#125; @Override public int run(String[] args) throws Exception &#123; if (args.length &lt; 1) &#123; System.out.println (\"Usage: Crawl -urls &lt;urlDir&gt; -crawlId &lt;crawlID&gt; -solr &lt;solrURL&gt; [-threads n] [-depth i] [-topN N]\"); // (\"Usage: crawl &lt;seedDir&gt; &lt;crawlID&gt; [&lt;solrUrl&gt;] &lt;numberOfRounds&gt;\"); return -1; &#125; // ------------check args---------/* //！！由脚本直译的，感觉少参数,所以注释掉，换下面的方式 String seedDir = args[1]; String crawlID = args[2]; String solrUrl=null; int limit=1; if(args.length-1 == 3)&#123; limit = Integer.parseInt(args[3]); &#125;else if(args.length-1 == 4)&#123; solrUrl = args[3]; limit = Integer.parseInt(args[4]); &#125;else&#123; System.out.println(\"Unknown # of arguments \"+(args.length-1)); System.out.println (\"Usage: crawl &lt;seedDir&gt; &lt;crawlID&gt; [&lt;solrUrl&gt;] &lt;numberOfRounds&gt;\"); return -1; //\"Usage: Crawl &lt;urlDir&gt; -solr &lt;solrURL&gt; [-dir d] [-threads n] [-depth i] [-topN N]\" //\"Usage: crawl &lt;seedDir&gt; &lt;crawlID&gt; [&lt;solrUrl&gt;] &lt;numberOfRounds&gt;\"; &#125;*/ String seedDir = null; String crawlID = null; String solrUrl=null; int limit = 0; long topN = Long.MAX_VALUE; int threads = getConf().getInt(\"fetcher.threads.fetch\", 10); //parameter-format in crawl class is // like nutch1.7 \"Usage: Crawl &lt;urlDir&gt; -solr &lt;solrURL&gt; [-dir d] [-threads n] [-depth i] [-topN N]\" //not like nutch2.3 \"Usage: crawl &lt;seedDir&gt; &lt;crawlID&gt; [&lt;solrUrl&gt;] &lt;numberOfRounds&gt;\"; for (int i = 0; i &lt; args.length; i++) &#123; if (\"-urls\".equals(args[i])) &#123; seedDir = args[++i]; &#125; else if (\"-crawlId\".equals(args[i])) &#123; crawlID = args[++i]; &#125; else if (\"-threads\".equals(args[i])) &#123; threads = Integer.parseInt(args[++i]); &#125; else if (\"-depth\".equals(args[i])) &#123; limit = Integer.parseInt(args[++i]); &#125; else if (\"-topN\".equals(args[i])) &#123; topN = Long.parseLong(args[++i]); &#125; else if (\"-solr\".equals(args[i])) &#123; solrUrl = args[++i]; i++; &#125; else &#123; System.err.println(\"Unrecognized arg \" + args[i]); return -1; &#125; &#125; if(StringUtils.isEmpty(seedDir))&#123; System.out.println(\"Missing seedDir : crawl &lt;seedDir&gt; &lt;crawlID&gt; [&lt;solrURL&gt;] &lt;numberOfRounds&gt;\"); return -1; &#125; if(StringUtils.isEmpty(crawlID))&#123; System.out.println(\"Missing crawlID : crawl &lt;seedDir&gt; &lt;crawlID&gt; [&lt;solrURL&gt;] &lt;numberOfRounds&gt;\"); return -1; &#125; if(StringUtils.isEmpty(solrUrl))&#123; System.out.println(\"No SOLRURL specified. Skipping indexing.\"); &#125; if(limit == 0) &#123; System.out.println(\"Missing numberOfRounds : crawl &lt;seedDir&gt; &lt;crawlID&gt; [&lt;solrURL&gt;] &lt;numberOfRounds&gt;\"); return -1; &#125; /** * MODIFY THE PARAMETERS BELOW TO YOUR NEEDS */ //set the number of slaves nodes int numSlaves = 1; //and the total number of available tasks // sets Hadoop parameter \"mapred.reduce.tasks\" int numTasks = numSlaves&lt;&lt;1; // number of urls to fetch in one iteration // 250K per task? //!!这里使用topN long sizeFetchlist = topN;//numSlaves *5; // time limit for feching int timeLimitFetch=180; //Adds &lt;days&gt; to the current time to facilitate //crawling urls already fetched sooner then //db.default.fetch.interval. int addDays=0; // note that some of the options listed here could be set in the // corresponding hadoop site xml param file String commonOptions=\"-D mapred.reduce.tasks=\"+numTasks+\" -D mapred.child.java.opts=-Xmx1000m -D mapred.reduce.tasks.speculative.execution=false -D mapred.map.tasks.speculative.execution=false -D mapred.compress.map.output=true \"; preConfig(getConf(),commonOptions); //initial injection System.out.println(\"Injecting seed URLs\"); String inject_args = seedDir+\" -crawlId \"+crawlID; binNutch4j(\"inject\",inject_args,commonOptions); for(int a=1;a&lt;=limit;a++)&#123; //-----------generating------------- System.out.println(\"Generating batchId\"); String batchId = System.currentTimeMillis()+\"-\"+new Random().nextInt(32767); System.out.println(\"Generating a new fetchlist\"); String generate_args = \"-topN \"+ sizeFetchlist +\" -noNorm -noFilter -adddays \"+addDays+\" -crawlId \"+crawlID+\" -batchId \"+batchId; //String generate_options = commonOptions; int res = runJob(\"generate\",generate_args,commonOptions); System.out.println(\"binNutch4j generate \"+generate_args); if(res==0)&#123; &#125;else if(res == 1)&#123; System.out.println(\"Generate returned 1 (no new segments created)\"); System.out.println(\"Escaping loop: no more URLs to fetch now\"); break; &#125;else&#123; System.out.println(\"Error running:\"); System.out.println(\"binNutch4j generate \"+generate_args); System.out.println(\"Failed with exit value \"+res); return res; &#125; //--------fetching----------- System.out.println(\"Fetching : \"); //String fetch_args = batchId+\" -crawlId \"+crawlID+\" -threads \"+threads; String fetch_args = \"-all\"+\" -crawlId \"+crawlID+\" -threads \"+threads; String fetch_options = commonOptions+\" -D fetcher.timelimit.mins=\"+timeLimitFetch; //10 threads binNutch4j(\"fetch\",fetch_args,fetch_options); //----------parsing-------------- // parsing the batch // if(!getConf().getBoolean(FetcherJob.PARSE_KEY, false))&#123; System.out.println(\"Parsing : \"); //enable the skipping of records for the parsing so that a dodgy document // so that it does not fail the full task //String parse_args = batchId+\" -crawlId \"+crawlID; String parse_args = \"-all\"+\" -crawlId \"+crawlID; String skipRecordsOptions=\" -D mapred.skip.attempts.to.start.skipping=2 -D mapred.skip.map.max.skip.records=1\"; binNutch4j(\"parse\",parse_args,commonOptions+skipRecordsOptions); &#125; //----------updatedb------------ // updatedb with this batch System.out.println(\"CrawlDB update for \"+crawlID); // String updatedb_args = batchId+\" -crawlId \"+crawlID; String updatedb_args = \"-all\"+\" -crawlId \"+crawlID; binNutch4j(\"updatedb\",updatedb_args,commonOptions); if(!StringUtils.isEmpty(solrUrl))&#123; System.out.println(\"Indexing \"+ crawlID+ \" on SOLR index -&gt; \" +solrUrl); String index_args = batchId+\" -all -crawlId \"+crawlID; String index_options = commonOptions+\" -D solr.server.url=\"+solrUrl; binNutch4j(\"index\",index_args,index_options); System.out.println(\"SOLR dedup -&gt; \"+solrUrl); binNutch4j(\"solrdedup\",solrUrl,commonOptions); &#125;else&#123; System.out.println(\"Skipping indexing tasks: no SOLR url provided.\"); &#125; &#125; return 0; &#125; /** * 相当于bin/crawl的函数__bin_nutch的功能 * @param jobName job * @param commandLine */ public void binNutch4j(String jobName,String commandLine,String options)throws Exception&#123; int res = runJob(jobName,commandLine,options); if(res!=0) &#123; System.out.println(\"Error running:\"); System.out.println(jobName + \" \" + commandLine); System.out.println(\"Error running:\"); System.exit(res); &#125; &#125; /** * 相当于脚本bin/nutch的功能 * * @param jobName * @param commandLine * @return */ public int runJob(String jobName,String commandLine,String options)throws Exception&#123; //这里为了方便，没有像脚本那样用多个if-elif语句，也没有用switch-case,直接用了反射来完成 Configuration conf = NutchConfiguration.create(); if(!StringUtils.isEmpty(options))&#123; preConfig(conf,options); &#125; String[] args = commandLine.split(\"\\\\s+\"); String className = CLASS_MAP.get(jobName); Class&lt;?&gt; jobClass = Class.forName(className); Constructor c = jobClass.getConstructor(); Tool job =(Tool) c.newInstance(); System.out.println(\"---------------runJob: \"+jobClass.getName()+\"----------------------\"); return ToolRunner.run(conf, job, args); &#125; /** * 设置每个job的配置 * @param conf * @param options */ public void preConfig(Configuration conf,String options)&#123; String [] equations = options.split(\"\\\\s*-D\\\\s+\"); System.out.println(\"options:\"+options); // i start from 1 not 0, skip the empty string \"\" for (int i=1;i&lt;equations.length;i++) &#123; String equation = equations[i]; String [] pair = equation.split(\"=\"); //System.out.println(pair[0]+\":\"+pair[1]); conf.set(pair[0],pair[1]); //System.out.println(\"conf print: \"+pair[0]+\" \"+conf.get(pair[0])); &#125; &#125; /** * the map to store the mapping relations jobName-&gt;ClassName */ public static HashMap&lt;String,String&gt; CLASS_MAP = new HashMap&lt;String,String&gt;(); /** * init the CLASS_MAP，refer to \"bin/nutch\" */ static &#123; CLASS_MAP.put(\"inject\",\"org.apache.nutch.crawl.InjectorJob\"); CLASS_MAP.put(\"generate\",\"org.apache.nutch.crawl.GeneratorJob\"); CLASS_MAP.put(\"fetch\",\"org.apache.nutch.fetcher.FetcherJob\"); CLASS_MAP.put(\"parse\",\"org.apache.nutch.parse.ParserJob\"); CLASS_MAP.put(\"updatedb\",\"org.apache.nutch.crawl.DbUpdaterJob\"); CLASS_MAP.put(\"readdb\",\"org.apache.nutch.crawl.WebTableReader\"); CLASS_MAP.put(\"elasticindex\",\"org.apache.nutch.indexer.elastic.ElasticIndexerJob\"); CLASS_MAP.put(\"index\",\"org.apache.nutch.indexer.IndexingJob\"); CLASS_MAP.put(\"solrdedup\",\"org.apache.nutch.indexer.solr.SolrDeleteDuplicates\"); &#125;&#125; 参考资料 Nutch流程控制源码详解（bin/crawl中文注释版） Nutch教程——导入Nutch工程，执行完整爬取","tags":[{"name":"Nutch","slug":"Nutch","permalink":"https://brianway.github.io/tags/Nutch/"},{"name":"shell","slug":"shell","permalink":"https://brianway.github.io/tags/shell/"}]},{"title":"光盘和U盘安装win7和ubuntu14.04全步骤","date":"2016-01-18T02:36:10.000Z","path":"2016/01/18/2016-01-18-linux-win7-ubuntu-setup-by-USBandCD/","text":"说来惭愧，作为一个学IT的，居然自己没重装过系统。一直想自己安装一次双系统，正好这个周日抽空研究了下，折腾了一天，总算如愿以偿。 写在前面 本文是先安装windows再安装linux，并通过windows引导linux的启动项。这样方便linux的反复重装、折腾等。 光盘安装和U盘安装基本差不多，只是U盘安装多了把镜像文件写到U盘制成启动盘的过程，启动时对应选择从USB启动/从CD-ROM启动即可 由于我有win7的光盘，就没研究怎么刻录win7到U盘 关于每一步的截图，文末的【参考资料】里别人已经截的很完善了，我就没重复造轮子(知乎那个李彬的答案关于EasyBCD使用有问题，那是硬盘启动，而非U盘，U盘没那么麻烦) 该文只是综合各个参考资料，按照安装顺序、更全面的把每一步需要注意的关键点用文字整理记录 关于原理部分，可以看《鸟叔私房菜-基础学习篇》(第三版)第3、4章相关内容，里面对MBR、分区表、引导加载程序的工作执行等有深入浅出的讲解 需要的工具 驱动精灵–用于安装win7的各种驱动，建议下载万能网卡版，把网络解决了才方便后面在线下载其他驱动 WIN7 Activation(Win7激活工具) 1.8 绿色免费版–用于激活win7 EasyBCD （Community Edition / 中文版下载）–用于设置由windows引导ubuntu的启动加载程序, Universal-USB-Installer–用于制作ubuntu的U盘启动盘 Ubuntu Desktop (附kylin(优麒麟)版)–Ubuntu的ISO镜像文件,用于制作U盘启动盘 步骤概述 win7安装 插入光盘，重启电脑，狂按F12 选择从CD-ROM启动 点安装，按提示进行就行了 用驱动精灵安装各种驱动 下载其他普通软件 ubuntu 14.04安装 刻录驱动盘,刻好后插入 重启电脑，狂按F12，选择USB启动 按照提示选择语言、分区、键盘布局等 重启电脑，在win7下添加启动菜单 重启电脑，选ubuntu，安装ubuntu的一些软件 详细说明这里对上面【步骤概述】相应步骤中需要注意的地方进行说明 win7安装第1，2两步 没什么好说的。我是戴尔的电脑，不同电脑进入启动界面的按键可能不同，戴尔的是F12,其他电脑的可能是Delete、F2、F10等 在BIOS里面，硬盘有时候不是 Hard Deice，有时候是HDD等，光驱不一定是CDROM，有时候是DVD-; 第3步 提示”进行何种类型的安装”-&gt;选择“自定义(高级)”； 分区时，如果不想影响其他盘的话，直接点系统盘(C盘)然后下一步即可，这时其他盘数据不会被影响；如果想重新分区，这里可以分区、格式化。点完就直接开始安装了。 需要注意的是，我不知道为什么，点分区只能分主分区，不能分逻辑分区。所以如果要安装双系统的话，需要留一个分区给linux，分区时主分区最多3个。 记得给linux留点硬盘空间，我这里留了100G 期间系统会自动重启，等进入到设置用户名密码、产品密钥等就说明好了，设置完就OK了。这里密钥能填正确最好，填失败了的话，后面还可以通过激活工具激活。 关于分区，其实可以在重装系统前进行，”开始-&gt;计算机-&gt;右键-&gt;管理-&gt;存储-&gt;磁盘管理” 第4步 把驱动精灵用U盘拷到电脑上，安装驱动精灵，然后先安装网卡驱动，能连网了再安装别的驱动。期间可能会多次询问重启，选择稍后重启，都安完了一次性重启 第5步 安装其他的软件，比如浏览器啊，上面提到的EasyBCD啊等 ubuntu安装第1步 下载ubuntu镜像，用上面提到的工具刻录U盘(格式化成FAT32的格式)，详情见文末的【参考链接4】 依次选择ubuntu版本，镜像文件，要写入的U盘。最后那个可选项可以不管，默认0MB 第2步 没什么特别的 第3步 选择第二项，安装ubuntu 选择语言，中文往下拉，在后面 选择“安装这个第三方软件”，其他不管 联网可选，有wifi这时可以先连 重要：选择最后一个”其他选项” 重要：分区。这里每个人不一样,我分配的大小都比较富裕，顺序是按表中由上到下分配的。关于分区，可以参考Linux系统安装时分区的选择 挂载点 大小 类型 新分区位置 用于 /boot 200M 逻辑分区 空间起始位置 EXT4日志文件系统 / 20G 主分区 空间起始位置 EXT4日志文件系统 不设置 2G 逻辑分区 空间起始位置 交换空间 /home 60G 逻辑分区 空间起始位置 EXT4日志文件系统 重要：上一步中，要记住/boot的设备号，比如我的是/dev/sda6,下面的”安装启动引导器的设备”-&gt;选择/boot所在的分区。这里不要选错，不然就是linux引导windows 后面无非就是一些用户设置了，没什么难的，键盘布局就选英文(美国)就行 第4步 安装好后ubuntu，重启电脑，进入win7设置启动菜单 打开EasyBCD，”添加新条目-&gt;linux/BSD-&gt;类型:GRUN(Legacy),设备/驱动器:刚才/boot对应的分区-&gt;点添加” /boot的分区是以linux开头的，不记得就看大小，比如我的是200M 可以在工具栏的”编辑引导菜单”查看启动菜单 第5步 首先需要更新一下依赖： 12sudo apt-get updatesudo apt-get upgrade 校园网认证使用mentohust,可以在linux公社下载，mentohust下载地址,用户和密码都是www.linuxidc.com 下载地址位于http://linux.linuxidc.com/的”/2013年资料/1月/20日/Ubuntu下使用MentoHUST代替锐捷认证上网”，或者”pub/ubuntu/Ubuntu 11.04校园网锐捷认证上网”下 可参考Ubuntu下使用MentoHUST搞定 锐捷校园网认证网络和Ubuntu下Mentohust的配置这两篇文章 参考资料 知乎：怎样安装 Windows 7 与 Linux 的双系统？ linux公社：Ubuntu 12.04和Windows 7双系统安装图解 Win7下安装CentOS 6.5双系统 win7下制作ubuntu系统安装启动盘和U盘安装ubuntu全过程 重装Win7 系统(用光盘重装Win7系统)_百度经验","tags":[{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"},{"name":"Linux","slug":"Linux","permalink":"https://brianway.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://brianway.github.io/tags/Ubuntu/"}]},{"title":"一个例子记住C++对象的生存周期","date":"2016-01-11T06:41:10.000Z","path":"2016/01/11/2016-01-11-cpp-memory-allocation-lifetime/","text":"最近要考C++，复习过程中遇到一些问题，总结记录一下。文中代码均在ideone在线编译器中运行的。 代码代码说明： 类A，含构造函数和析构函数 普通函数fun，函数体里新建了类A的局部自动对象FunObj和局部静态对象InStaObj main方法新建了类A的局部自动对象MainObj,调用fun方法 外面新建了A的的外部静态对象ExStaObj和外部对象GblObj 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class A &#123; char string[50];public : A(char * st); ~A( );&#125;;A::A(char * st)&#123; strcpy(string, st); cout &lt;&lt; string &lt;&lt; \"被创建时调用构造函数 ! \" &lt;&lt; endl;&#125;A::~A( )&#123; cout &lt;&lt; string &lt;&lt; \"被撤消时调用析构函数 ! \" &lt;&lt; endl;&#125;void fun( )&#123; cout &lt;&lt; \"在fun( )函数体内 : \\n\" &lt;&lt; endl; A FunObj(\"fun( )函数体内的自动对象FunObj\"); static A InStaObj(\"内部静态对象InStaObj\");&#125;int main( )&#123; A MainObj(\"主函数体内的自动对象MainObj\"); cout&lt;&lt;\"主函数体内，调用fun()函数前: \\n\"; fun( ); cout &lt;&lt; \"\\n主函数体内，调用fun()函数后:\\n\"; return 0;&#125;static A ExStaObj(\"外部静态对象ExStaObj\");A GblObj(\"外部对象GblObj\"); 输出： 123456789101112131415外部静态对象ExStaObj被创建时调用构造函数 ! 外部对象GblObj被创建时调用构造函数 ! 主函数体内的自动对象MainObj被创建时调用构造函数 ! 主函数体内，调用fun()函数前: 在fun( )函数体内 : fun( )函数体内的自动对象FunObj被创建时调用构造函数 ! 内部静态对象InStaObj被创建时调用构造函数 ! fun( )函数体内的自动对象FunObj被撤消时调用析构函数 ! 主函数体内，调用fun()函数后:主函数体内的自动对象MainObj被撤消时调用析构函数 ! 内部静态对象InStaObj被撤消时调用析构函数 ! 外部对象GblObj被撤消时调用析构函数 ! 外部静态对象ExStaObj被撤消时调用析构函数 ! 若将A GblObj(&quot;外部对象GblObj&quot;);写在static A ExStaObj(&quot;外部静态对象ExStaObj&quot;);前面，则输出时两者顺序也颠倒。 分析 创建顺序 外部静态对象or外部对象优先于main函数 销毁顺序 和创建顺序相反，注意静态对象会在main函数执行完才会销毁 内存的三种分配方式 从静态存储区分配：此时的内存在程序编译的时候已经分配好，并且在程序的整个运行期间都存在。全局变量，static变量等在此存储 在栈区分配：相关代码执行时创建，执行结束时被自动释放。局部变量在此存储。栈内存分配运算内置于处理器的指令集中，效率高，但容量有限 在堆区分配：动态分配内存。用new/malloc时开辟，delete/free时释放。生存期由用户指定，灵活。但有内存泄露等问题","tags":[{"name":"cpp","slug":"cpp","permalink":"https://brianway.github.io/tags/cpp/"},{"name":"examples","slug":"examples","permalink":"https://brianway.github.io/tags/examples/"}]},{"title":"简单谈谈C++中的函数形参与浅拷贝","date":"2016-01-11T05:35:10.000Z","path":"2016/01/11/2016-01-11-cpp-formal-param-copy/","text":"最近要考C++，复习过程中遇到一些问题，总结记录一下。文中代码均在ideone在线编译器中运行的 字面上都知道，函数传递参数有值传递和引用传递，但具体区别是什么呢？除了一个传对象拷贝，一个传对象本身之外，还有哪些影响？ 这里定义一个str类，只有一个private char*st变量；有几个基本的函数，重载了=和==运算符，str &amp; operator=(str const &amp; a)和str &amp; operator==(str a),用于用不同方式实现赋值。代码如下： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; class str &#123;private: char *st; public: str(char *a) &#123; set(a); cout&lt;&lt;\"构造函数：str addr \"&lt;&lt;this&lt;&lt;\" st addr \"&lt;&lt;&amp;st&lt;&lt;\" st point to \"&lt;&lt;(void *)st&lt;&lt;\" st \"&lt;&lt;st&lt;&lt;endl; &#125; str &amp; operator==(str a) &#123;//二元操作符“==”，参数类型和后者一致 cout&lt;&lt;\"op:形参 str a addr \"&lt;&lt;&amp;a&lt;&lt;\" a.st addr \"&lt;&lt;&amp;(a.st)&lt;&lt;\" a.st point to \"&lt;&lt;(void *)(a.st)&lt;&lt;\" a.st content \"&lt;&lt;(a.st)&lt;&lt;endl; delete st; set(a.st); return *this; &#125; str &amp; operator=(str const &amp; a) &#123;//二元操作符“=”，参数类型和后者一致 //str &amp; operator=(str &amp; a) &#123;//二元操作符“=”，参数类型和后者一致 cout&lt;&lt;\"op:形参 str const &amp; a addr \"&lt;&lt;&amp;a&lt;&lt;\" a.st addr \"&lt;&lt;&amp;(a.st)&lt;&lt;\" a.st point to \"&lt;&lt;(void *)(a.st)&lt;&lt;\" a.st content \"&lt;&lt;(a.st)&lt;&lt;endl; delete st; set(a.st); return *this; &#125; void show()&#123;cout&lt;&lt;\"show func: \"&lt;&lt;st&lt;&lt;endl;&#125; ~str()&#123; cout&lt;&lt;\"~str:before str addr \"&lt;&lt;this&lt;&lt;\" st addr \"&lt;&lt;&amp;st&lt;&lt;\" st point to \"&lt;&lt;(void *)(st)&lt;&lt;\" st content \"&lt;&lt;st&lt;&lt;endl; delete st; //cout&lt;&lt;\"~str:after str addr \"&lt;&lt;this&lt;&lt;\" st addr \"&lt;&lt;&amp;st&lt;&lt;\" st point to \"&lt;&lt;(void *)(st)&lt;&lt;\" st content \"&lt;&lt;st&lt;&lt;endl; &#125; void set(char *s)//初始化st &#123; cout&lt;&lt;\"set:before new st addr \"&lt;&lt;&amp;st&lt;&lt;\" st point to \"&lt;&lt;(void *)(st)&lt;&lt;endl; st = new char[strlen(s)+1];//先分配空间，否则野指针,+1存\"\\0\" cout&lt;&lt;\"set:after new st addr \"&lt;&lt;&amp;st&lt;&lt;\" st point to \"&lt;&lt;(void *)(st)&lt;&lt;endl; if(st) strcpy(st,s); &#125; &#125;; int main() &#123; str s1(\"he\"), s2(\"she\"); s1.show(), s2.show(); //s2=s1; s2==s1; s1.show(), s2.show(); return 0;&#125; 使用str &amp; operator==(str a)重载的输出： 12345678910111213141516set:before new st addr 0xbfce5374 st point to 0xb785c680set:after new st addr 0xbfce5374 st point to 0x9bffa10构造函数：str addr 0xbfce5374 st addr 0xbfce5374 st point to 0x9bffa10 st heset:before new st addr 0xbfce5378 st point to 0x804abc4set:after new st addr 0xbfce5378 st point to 0x9bffa20构造函数：str addr 0xbfce5378 st addr 0xbfce5378 st point to 0x9bffa20 st sheshow func: heshow func: sheop:形参 str a addr 0xbfce537c a.st addr 0xbfce537c a.st point to 0x9bffa10 a.st content heset:before new st addr 0xbfce5378 st point to 0x9bffa20set:after new st addr 0xbfce5378 st point to 0x9bffa20~str:before str addr 0xbfce537c st addr 0xbfce537c st point to 0x9bffa10 st content heshow func: show func: he~str:before str addr 0xbfce5378 st addr 0xbfce5378 st point to 0x9bffa20 st content he~str:before str addr 0xbfce5374 st addr 0xbfce5374 st point to 0x9bffa10 st content 注意第二次两行show之前的那句~str:before str addr 0xbfce537c st addr 0xbfce537c st point to 0x9bffa10 st content he 使用str &amp; operator=(str const &amp; a)重载,将main中s2==s1;注释掉，使用s2=s1;, 输出： 123456789101112131415set:before new st addr 0xbff47b38 st point to 0x804aba0set:after new st addr 0xbff47b38 st point to 0x9693a10构造函数：str addr 0xbff47b38 st addr 0xbff47b38 st point to 0x9693a10 st heset:before new st addr 0xbff47b3c st point to 0x8049302set:after new st addr 0xbff47b3c st point to 0x9693a20构造函数：str addr 0xbff47b3c st addr 0xbff47b3c st point to 0x9693a20 st sheshow func: heshow func: sheop:形参 str const &amp; a addr 0xbff47b38 a.st addr 0xbff47b38 a.st point to 0x9693a10 a.st content heset:before new st addr 0xbff47b3c st point to 0x9693a20set:after new st addr 0xbff47b3c st point to 0x9693a20show func: heshow func: he~str:before str addr 0xbff47b3c st addr 0xbff47b3c st point to 0x9693a20 st content he~str:before str addr 0xbff47b38 st addr 0xbff47b38 st point to 0x9693a10 st content he 分析 使用str &amp; operator==(str a)重载时，s1的地址为0xbfce5374，a的地址为0xbfce537c,确实是另外创建了新变量a，但是，两者的st均指向同一个地址0x9bffa10 使用str &amp; operator=(str const &amp; a)重载时，s1和a的地址均为0xbff47b38 两次输出的区别在于使用值传递时，即第一个输出结果多了一句输出：~str:before str addr 0xbfce537c st addr 0xbfce537c st point to 0x9bffa10 st content he 可以看出，主要区别在于,参数类型不是引用时，形参为值传递，默认的复制构造函数就是简单的把成员变量依次赋值，所以str a的st和s1的st指向的同一段内存，函数str &amp; operator==(str a)执行完，自动变量a会销毁，调用析构函数，释放st所指向的内存并设指针为空，所以为null。而使用函数str &amp; operator=(str const &amp; a)，则不会代用析构函数。由于这里未对变量a做修改，所以去掉const不影响，不过最好保留。 关于拷贝 对象间赋值(=)是一个拷贝过程 浅拷贝 实现对象间数据元素的一一对应复制。 深拷贝 当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指的对象进行复制。系统提供的拷贝(如默认拷贝构造函数等)只能实现浅拷贝，深拷贝必须自定义","tags":[{"name":"cpp","slug":"cpp","permalink":"https://brianway.github.io/tags/cpp/"},{"name":"examples","slug":"examples","permalink":"https://brianway.github.io/tags/examples/"}]},{"title":"java基础巩固笔记(2)-泛型","date":"2016-01-07T22:14:12.000Z","path":"2016/01/08/2016-01-08-javase-learn-note-2-Generics/","text":"本文对泛型的基本知识进行较为全面的总结，并附上简短的代码实例，加深记忆。 泛型将集合中的元素限定为一个特定的类型。 术语 ArrayList&lt;E&gt; – 泛型类型 ArrayList – 原始类型 E – 类型参数 &lt;&gt; – 读作”typeof” ArrayList&lt;Integer&gt; – 参数化的类型 Integer – 实际类型参数 几点注意： 参数化类型和原始类型相互兼容 12ArrayList collection1 = new ArrayList&lt;Integer&gt;();//通过,无warningArrayList&lt;Integer&gt; collection2 = new ArrayList();//通过,有warning 参数化类型不考虑类型参数的继承关系 12ArrayList&lt;String&gt; collection3 = new ArrayList&lt;Object&gt;();//编译不通过ArrayList&lt;Object&gt; collection4 = new ArrayList&lt;String&gt;();//编译不通过 但是 12ArrayList collection5 = new ArrayList&lt;Integer&gt;();ArrayList&lt;String&gt; collection6 = collection5;//编译通过 “?”通配符“?”表示任意类型，使用”?”通配符可以引用各种参数化的类型，可以调用与参数化无关的方法(如size()方法)，不能调用与参数化有关的方法(如add()方法) 通配符的扩展 限定通配符的上边界 12ArrayList&lt;? extends Number &gt; collection1= new ArrayList&lt;Integer &gt;();//编译通过ArrayList&lt;? extends Number &gt; collection2= new ArrayList&lt;String&gt;();//编译不通过 限定通配符的下边界 12ArrayList&lt;? super Integer &gt; collection3= new ArrayList&lt;Number &gt;();//编译通过ArrayList&lt;? super Integer &gt; collection4= new ArrayList&lt;String&gt;();//编译不通过 自定义泛型方法C++模板函数 123template &lt;class T&gt; T add(T x, T y)&#123; return (T)(x+y);&#125; 而java的泛型基本上完全在编译器中实现，用于编译器执行类型检查和类型判断，然后生成普通的非泛型的字节码，这种实现技术为“擦除”(erasure)。 “擦除”实例泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。 12345678910111213141516public class GenericTest &#123; public static void main(String[] args) &#123; new GenericTest().testType(); &#125; public void testType()&#123; ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;(); ArrayList&lt;String&gt; collection2= new ArrayList&lt;String&gt;(); System.out.println(collection1.getClass()==collection2.getClass()); //两者class类型一样,即字节码一致 System.out.println(collection2.getClass().getName()); //class均为java.util.ArrayList,并无实际类型参数信息 &#125;&#125; 输出 12truejava.util.ArrayList 使用反射可跳过编译器，往某个泛型集合加入其它类型数据。 只有引用类型才能作为泛型方法的实际参数。例子： 1234567891011121314151617public class GenericTest &#123; public static void main(String[] args) &#123; swap(new String[]&#123;\"111\",\"222\"&#125;,0,1);//编译通过 //swap(new int[]&#123;1,2&#125;,0,1); //编译不通过,因为int不是引用类型 swap(new Integer[]&#123;1,2&#125;,0,1);//编译通过 &#125; /*交换数组a 的第i个和第j个元素*/ public static &lt;T&gt; void swap(T[]a,int i,int j)&#123; T temp = a[i]; a[i] = a[j]; a[j] = temp; &#125;&#125; 但注意基本类型有时可以作为实参，因为有自动装箱和拆箱。例子(编译通过了)： 1234567891011121314public class GenericTest &#123; public static void main(String[] args) &#123; new GenericTest().testType(); int a = biggerOne(3,5); //int 和 double,取交为Number Number b = biggerOne(3,5.5); //String和int 取交为Object Object c = biggerOne(\"1\",2); &#125; //从x,y中返回y public static &lt;T&gt; T biggerOne(T x,T y)&#123; return y; &#125;&#125; 同时，该例还表明，当实参不一致时，T取交集，即第一个共同的父类。另外，如果用Number b = biggerOne(3,5.5);改为String c = biggerOne(3,5.5);则编译报错: 123Error:(17, 29) java: 不兼容的类型: 推断类型不符合上限 推断: java.lang.Number&amp;java.lang.Comparable&lt;? extends java.lang.Number&amp;java.lang.Comparable&lt;?&gt;&gt; 上限: java.lang.String,java.lang.Object 但是有一点没搞清楚，我在IDEA里面单步调试，发现结果如下图： 泛型调试截图-1 不知道b为什么是Double类型的（但直接Double b接收返回值会编译报错）。不知道跟IDE有没有关系，是不是IDE在debug时会显示这个对象最精确的类型？ 类型参数的类型推断编译器判断泛型方法的实际类型参数的过程称为类型推断。 当某个类型变量只在整个参数列表的所有参数和返回值中的一处被应用了，那么根据调用方法时该处的实际应用类型来确定。即直接根据调用方法时传递的参数类型或返回值来决定泛型参数的类型。例如： swap(new String[3],1,2) -&gt; static &lt;E&gt; void swap(E[]a,int i,int j) 当某个类型变量在整个参数列表的所有参数和返回值中的多处被应用了，如果调用方法时这么多处的实际应用类型都 对应同一种类型，则泛型参数的类型就是该类型。例如： add(3,5) -&gt; static &lt;T&gt; T add(T a,T b) 当某个类型变量在整个参数列表的所有参数和返回值中的*多处被应用了，如果调用方法时这么多处的实际应用类型 对应不同的类型,且没有返回值，则取多个参数中的最大交集类型，即第一个公共父类。例如： fill(new Integer[3],3.5) -&gt; static &lt;T&gt; void fill(T a[],T v) 该例子实际对应的类型就是Number,编译通过，运行出问题。 当某个类型变量在整个参数列表的所有参数和返回值中的多处被应用了，如果调用方法时这么多处的实际应用类型对应不同的类型,且使用有返回值，则优先考虑返回值的类型 例如： int x = add(3,3.5) -&gt; static &lt;T&gt; T add(T a,T b) 上例编译报错,x类型改为float也报错，改为Number成功。 参数类型的类型推断具有传递性 例子： copy(new Integer[5],new String[5]) -&gt; static &lt;T&gt; void copy(T []a,T []b) 该例推断实际参数类型为Object,编译通过. copy(new ArrayList&lt;String&gt;,new Integer[5]) -&gt; static &lt;T&gt; void copy(Collection&lt;T&gt;a,T[]b) 该例则根据参数化的ArrayList类实例将类型变量直接确定为String类型，编译报错。 自定义泛型类例子 1234567891011121314151617181920212223242526public class GenericDao&lt;T&gt;&#123; public void add(T x)&#123; &#125; public T findById(int id)&#123; return null; &#125; public void delete(T obj)&#123; &#125; public void delete(int id)&#123; &#125; public void update(T obj)&#123; &#125; public T findByUserName(String name)&#123; return null; &#125; public &lt;T&gt; Set&lt;T&gt; findByConditions(String where)&#123; return null; &#125;&#125; 注意：当一个变量被声明为泛型时，只能被实例变量和方法调用(还有内嵌类型)，而不能被静态变量和静态方法调用。因为静态成员是被所参数化的类所共享的，所以静态成员不应该有类级别的类型参数。 泛型方法和泛型类的比较例子： 1234567891011121314151617public class A&lt;T&gt;()&#123; //泛型类的成员方法，该T受A后面的T的限制 public T memberFunc()&#123; return null; &#125; //泛型方法，这里的T和和类A的T是不同的 public static &lt;T&gt; T genericFunc(T a)&#123; return null; &#125; public static void main(String[] args) &#123; //编译不通过 //Integer i = A&lt;String&gt;().findByUserName(\"s\"); //编译通过 Set&lt;Integer&gt; set= A&lt;String&gt;().findByConditions(\"s\"); &#125;&#125; 这里Integer i = A&lt;String&gt;().findByUserName(&quot;s&quot;);会编译报错： Error:(35, 61) java: 不兼容的类型: java.lang.String无法转换为java.lang.Integer 由这个例子可知，泛型方法的T和和类A的T是不同的。 泛型和反射通过反射获得泛型的实际类型参数把泛型变量当成方法的参数，利用Method类的getGenericParameterTypes方法来获取泛型的实际类型参数例子： 1234567891011121314151617181920212223242526public class GenericTest &#123; public static void main(String[] args) throws Exception &#123; getParamType(); &#125; /*利用反射获取方法参数的实际参数类型*/ public static void getParamType() throws NoSuchMethodException&#123; Method method = GenericTest.class.getMethod(\"applyMap\",Map.class); //获取方法的泛型参数的类型 Type[] types = method.getGenericParameterTypes(); System.out.println(types[0]); //参数化的类型 ParameterizedType pType = (ParameterizedType)types[0]; //原始类型 System.out.println(pType.getRawType()); //实际类型参数 System.out.println(pType.getActualTypeArguments()[0]); System.out.println(pType.getActualTypeArguments()[1]); &#125; /*供测试参数类型的方法*/ public static void applyMap(Map&lt;Integer,String&gt; map)&#123; &#125;&#125; 输出结果： 1234java.util.Map&lt;java.lang.Integer, java.lang.String&gt;interface java.util.Mapclass java.lang.Integerclass java.lang.String","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"}]},{"title":"java基础巩固笔记(1)-反射","date":"2016-01-07T20:39:11.000Z","path":"2016/01/08/2016-01-08-javase-learn-note-1-Reflect/","text":"反射：将类的属性和方法映射成相应的类。 反射基本使用获取Class类的三种方法: 类名.class 对象名.getClass() Class.forName(“要加载的类名”) 根据API写就行了，大致流程就是: 用上述三种方式之一获取特定类的Class类，即该类对应的字节码 调用Class对象的getConstructor(Class&lt;?&gt;... parameterTypes)获取构造方法对象 调用是构造方法类Constructor的newInstance(Object... initargs)方法新建对象 调用Class对象的getMethod(String name, Class&lt;?&gt;... parameterTypes)获取方法对象 调用方法对象类Method的invoke(Object obj, Object... args)方法，调用对象上相应方法 用方法的参数类型唯一标识一个方法,依据：方法的重载 数组的反射下面这个例子主要说明几点： 对于元素同类型的数组，同维数组，class一样 不同维，class不同 不同维的，父类都是Object,一样 基本类型一维数组不能直接转换为Object[] java.util.Arrays的asList方法API看看 1234567891011121314151617181920212223public class ReflectTest &#123; public static void main(String[] args) &#123; int [] a1 = new int[]&#123;1,2,3&#125;; int [] a2 = new int[5]; int [][] a3 = new int[2][3]; System.out.println(a1.getClass() == a2.getClass());//true System.out.println(a1.getClass());//class [I System.out.println(a3.getClass());//class [[I System.out.println(a1.getClass().getSuperclass() == a3.getClass().getSuperclass());//true System.out.println(a2.getClass().getSuperclass());//class java.lang.Object //下句编译不通过：Error:(15, 42) java: 不可比较的类型: java.lang.Class&lt;capture#1, 共 ? extends int[]&gt;和java.lang.Class&lt;capture#2, 共 ? extends int[][]&gt; //System.out.println(a1.getClass() == a3.getClass()); Object []b3 = a3;//通过 //下句编译不通过 Error:(17, 24) java: 不兼容的类型: int[]无法转换为java.lang.Object[] //Object [] b1 = a1; String s1 = \"abc\"; System.out.println(Arrays.asList(a1));//[[I@1540e19d] System.out.println(Arrays.asList(s1));//[abc] &#125;&#125; 输出： 1234567trueclass [Iclass [[Itrueclass java.lang.Object[[I@1540e19d][abc] 乱入：hashcode与内存泄露问题参考java api： hashcode一旦生成，不要变 对象equals方法返回true,则hascode要一致 反之，equals方法返回false,hascode不一定互异 如果参与hascode计算的成员变量中途发生变化，则后面remove时失败，造成内存泄露 配置文件加载 类加载器加载只读配置文件 类名.class.getClassLoader().getResourceAsStream(str); 类名.class.getResourceAsStream(str),实质还是调用类加载器。源码截取(java.lang包下的Class.java)： 123456789 public InputStream getResourceAsStream(String name) &#123; name = resolveName(name); ClassLoader cl = getClassLoader0(); if (cl==null) &#123; // A system class. return ClassLoader.getSystemResourceAsStream(name); &#125; return cl.getResourceAsStream(name);&#125; 关于路径str，写法有点讲究。 不加斜杠，相对路径:str = &quot;config.properties&quot;; 加斜杠，从classpath的根路径找:str = &quot;/org/iot/ui/config.properties&quot;; 以前编译java代码时，有些conf/文件夹还要添加进依赖或者标记成source文件夹，里面明明都是xml文件，没Java源码。从这里，我现在知道了，是使用反射加载配置文件的缘故 内省(Instropector) &amp; JavaBeanJavaBean读取属性x的值的流程：变大写、补前缀、获取方法。 1&quot;x&quot;--&gt;&quot;X&quot;--&gt;&quot;getX&quot;--&gt;&quot;MethodGetX&quot; 自己用内省操作 我目前没用上，所以不贴代码了，只附上核心类 简单实现：使用java.beans.PropertyDescriptor类 麻烦实现:使用java.beans.Introspector类,遍历getBeanInfo方法的返回值 JavaBean必须有一个不带参数的构造函数 使用BeanUtils工具包 字符串和整数转换(对比(PropertyUtils) 属性级联操作 操作map","tags":[{"name":"Java","slug":"Java","permalink":"https://brianway.github.io/tags/Java/"}]},{"title":"在github搭建个人网站","date":"2016-01-07T06:35:11.000Z","path":"2016/01/07/2016-01-07-build-blog-with-jekyll-and-github/","text":"先搜篇中文博客了解下流程，再根据下面的官方文档按顺序看一遍就差不多了。 这里不得不吐槽windows太垃圾了，linux下三行指令解决的问题，windows还要一个个安装、改配置文件。 参考教程 GitHub Help GitHub Pages Jekyll（附上中文版) Run Jekyll on Windows 流程首先默认你已经拥有了自己github账号，并会基本的git操作。 新建一个和github用户名(username)同名的仓库，username.github.io 在本地电脑安装 Ruby和devkit jekyll python 找一个好的模板 修改模板，导入自己的文章 具体步骤懒得写了，不定期完善。 Mac下安装 1.安装ruby 由于我之前安装过Xcode还有Xcode command line tools,所以直接就有ruby了，Terminal里输入ge+Tab键能看到有gem指令 2.安装jekyll和bundle 参考：Setting up your GitHub Pages site locally with Jekyll 感想主要是我完全不懂ruby和python,前端也只有少的可怜的一点常识。搭建环境不复杂，基本安装好了后jekyll new myblog就有个基础模板了，不过很难看。所以我主要花了一整天时间去找主题、P图、了解jekyll的目录结构和用法、测试显示效果。总算搞定了，不过markdown的语法高亮我还是不满意，比较喜欢SegmentFault的高亮。有空再说这部分。 遇到的问题1.windows下安装ruby的devkit遇到问题 12Invalid configuration or no Rubies listed. Please fix &apos;config.yml&apos;and rerun &apos;ruby dk.rb install&apos; 解决：How do I configure config.yml so that I can install devkit? 2.kunka主题jekyll build问题 1Deprecation: You appear to have pagination turned on, but you haven&apos;t included the `jekyll-paginate` gem. Ensure you have `gems: [jekyll-paginate]` in your configuration fil e. 解决：jekyll-paginate gem 3.markdown显示问题 这里很蛋疼，我写markdown的习惯是代码都是前后各三个反单引号包起来的。使用kramdown解析markdown不能对含三个反单引号的代码块进行识别，默认按单行代码处理，缩进都没了；使用redcarpet能识别代码块，但没高亮，rouge又提示什么要下1.3版本，反正神烦。 参考： Syntax highlighting markdown code blocks in Jekyll (without using liquid tags) Jekyll kramdown配置 4.jekyll build失败报错(多版本冲突) 解决：Jekyll/Ruby Kramdown Missing Dependency 5.bundle install SSL接连不上(其实是网速不好，多试几次。下载前gem update --system) 查阅：SSL Error When installing rubygems, Unable to pull data from ‘https://rubygems.org/ 6.jekyll升级到3.0 GitHub Pages now faster and simpler with Jekyll 3.0 Upgrading from 2.x to 3.x 7.gem install出现error，伟大的防火墙问题 123brian@brianway:~$ gem install jekyllERROR: While executing gem ... (Gem::RemoteFetcher::FetchError)Errno::ECONNRESET: Connection reset by peer - SSL_connect (https://api.rubygems.org/quick/Marshal.4.8/jekyll-3.1.6.gemspec.rz) 解决：换成淘宝的镜像 https://ruby.taobao.org/ 8.MAC下gem install jekyll失败 12ERROR: While executing gem ... (Gem::FilePermissionError)You don&apos;t have write permissions for the /Library/Ruby/Gems/2.0.0 directory. 好像不建议使用sudo,需要另外弄一套包管理rbenv或者RVM，图省事的话，可以直接安装在本地用户目录,指令格式：gem install *** --user-install，***是要安装的包名，具体可以输入gem help install查看参数意义 参考： Installing gem or updating RubyGems fails with permissions error Can’t install gems on OS X “El Capitan” 9.mac下bundle执行失败 123456789brian@brianway:~/mygit/brianway.github.io (master)$ bundle exec jekyll serveConfiguration file: /Users/brian/mygit/brianway.github.io/_config.ymlSource: /Users/brian/mygit/brianway.github.ioDestination: /Users/brian/mygit/brianway.github.io/_siteIncremental build: disabled. Enable with --incrementalGenerating...ERROR: YOUR SITE COULD NOT BE BUILT:------------------------------------Invalid date &apos;&lt;%= Time.now.strftime(&apos;%Y-%m-%d %H:%M:%S %z&apos;) %&gt;&apos;: Document &apos;vendor/bundle/ruby/2.0.0/gems/jekyll-3.1.6/lib/site_template/_posts/0000-00-00-welcome-to-jekyll.markdown.erb&apos; does not have a valid date in the YAML front matter. 解决：在_config.yml文件添加exclude: [&quot;vendor&quot;] 参考： How to set up a Jekyll blog on Heroku Error building site: Post 0000-00-00… does not have a valid date (hurtstotouchfire 的回答) Fix Travis issue due to –deployment flag during bundle 主题好多主题太闪，我跑不通，或者怕不好改，挑了几个简单的，我跑通的主题(不要吐槽我的审美) so-simple-theme hpstr-jekyll-theme 陈俊的网：浮生志 kunka","tags":[{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"},{"name":"GitHub","slug":"GitHub","permalink":"https://brianway.github.io/tags/GitHub/"}]},{"title":"hadoop完全分布式模式的安装和配置步骤","date":"2015-12-17T06:35:11.000Z","path":"2015/12/17/2015-12-17-hadoop-Fully-distributed-setup/","text":"本文是入门教程，以hadoop-1.2.1为例，介绍hadoop完全分布式的部署和配置步骤 实验条件： 三台阿里云云服务器(已经配置好Java环境) 一台PC机用于远程登录服务器 前排提示： JAVA环境需每个服务器单独配置(注意路径一致) hadoop相关配置只需配置一个master即可，其他的机子直接scp复制 配置步骤0.下载解压 下载解压Hadoop安装包 国内镜像hadoop-1.2.1.tar.gz 官网hadoop-1.2.1.tar.gz 下载：wget https://dist.apache.org/repos/dist/release/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz 解压：tar xzvf hadoop-1.2.1.tar.gz 1.配置hosts文件和hadoop-env.sh文件 修改/etc/host，使彼此能解析主机名 123456789101112root@RfidLabMaster:/etc# cat hosts127.0.0.1 localhost127.0.1.1 localhost.localdomain localhost# The following lines are desirable for IPv6 capable hosts::1 localhost ip6-localhost ip6-loopbackff02::1 ip6-allnodesff02::2 ip6-allrouters#10.116.155.242 iZ945z9p7yxZ#10.116.155.242 RfidLabMaster120.25.162.238 RfidLabMaster120.27.138.14 RfidLabSlave1120.27.137.211 RfidLabSlave2 进入hadoop的解压目录，编辑conf/hadoop-env.sh(版本不同，配置文件位置有所变化) 查看本机的JAVA_HOME：env |grep JAVA_HOME 显示：JAVA_HOME=/usr/lib/jvm/jdk1.8.0_60 编辑hadoop-env.sh：vim hadoop-env.sh 找到export JAVA_HOME，去掉#注释改为本机的export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_60 2.ssh配置2.1.以brian用户登录，在brian主目录下进行操作进入root目录：cd /root生成密钥: ssh-keygen -t rsacd .sshcp id_rsa.pub authorized_keys 2.2分发ssh公钥把各个节点的authorized_keys的内容相互拷贝到对方的此文件中，即可免密码彼此ssh连入把所有节点的authorized_keys的内容拷贝到一起形成一个大文件，再用这个新的大authorized_keys覆盖所有节点的原来的该文件。 3.编辑conf目录下core-site.xml,hdfs-site.xml,mapred-site.xml三个核心配置文件 修改core-site.xml文件在&lt;configuration&gt;&lt;/configuration&gt;标签中添加： 12345678&lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://RfidLabMaster:9000&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&lt;value&gt;/home/brian/hadoopdir/tmp&lt;/value&gt;&lt;/property&gt; 修改hdfs-site.xml文件在&lt;configuration&gt;&lt;/configuration&gt;标签中添加： 123456789101112131415&lt;property&gt;&lt;name&gt;dfs.name.dir&lt;/name&gt;&lt;value&gt;/home/brian/hadoopdir/name&lt;/value&gt; #hadoop的name目录路径&lt;description&gt; &lt;/description&gt;&lt;/property&gt;&lt;property&gt;&lt;name&gt;dfs.data.dir&lt;/name&gt;&lt;value&gt;/home/brian/hadoopdir/data&lt;/value&gt;&lt;description&gt; &lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;!-- 我们的集群有两个结点，所以rep两份 --&gt; &lt;value&gt;2&lt;/value&gt;&lt;/property&gt; 修改mapred-site.xml文件在&lt;configuration&gt;&lt;/configuration&gt;标签中添加： 12345678&lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;hdfs://RfidLabMaster:9001&lt;/value&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;mapred.local.dir&lt;/name&gt; &lt;value&gt;/home/brian/hadoopdir/local&lt;/value&gt;&lt;/property&gt; 4.修改masters和slaves文件conf/masters 1RfidLabMaster conf/slaves 12RfidLabSlave1RfidLabSlave2 5.向各个节点复制hadoopscp -r ./hadoop-1.2.1 RfidLabSlave1:/home/brian 6.格式化分布式文件系统在hadoop目录下输入bin/hadoop namenode -format 7.启动守护进程在hadoop目录下输入bin/start-all.sh 结果主节点 12345brian@RfidLabMaster:~/hadoop-1.2.1/logs$ jps26721 JobTracker26449 NameNode26889 Jps26633 SecondaryNameNode 从节点 1234brian@RfidLabSlave1:~$ jps20402 Jps20204 DataNode20302 TaskTracker 查看日志文件，均无ERROR和异常 遇到的问题1.[mater日志异常]:hadoop/hdfs/name is in an inconsistent state: storage directory(hadoop/hdfs/data/) does not exist or is not accessible stack overflow question 1.1 2.[slave日志异常]:Hadoop : java.io.IOException: Call to failed on local exception: java.io.EOFException stack overflow question 2.1 问题1和2:好像是忘记先格式化分布式文件系统了，[问题2]好像是[问题1]的连带问题，参看[6.格式化分布式文件系统] 3.[slave日志异常]：ERROR org.apache.hadoop.hdfs.server.datanode.DataNode: java.io.IOException: Incompatible namespaceIDs in stack overflow question 3.1 stack overflow question 3.2 问题3：好像是重复格式化后ID冲突的问题，上面的两个链接有各种解决办法，什么在版本文件里改ID之类的，最简单的好像是直接删掉在文件[3.编辑conf目录下core-site.xml,hdfs-site.xml,mapred-site.xml三个核心配置文件]中涉及到的文件夹 4.[master日志]：ERROR org.apache.hadoop.security.UserGroupInformation: PriviledgedActionException as:brian cause:java.io.IOException: File/home/brian/hadoop_dir/tmp/mapred/system/jobtracker.info could only be replicated to 0 nodes, instead of 1 stack overflow question 4.1 stack overflow question 4.2 问题4：可能我之前的配置有问题，重新配置了一遍，然后按照[问题3]里删文件解决的 补充参考hadoop 可能遇到的错误","tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"https://brianway.github.io/tags/Hadoop/"},{"name":"安装部署","slug":"安装部署","permalink":"https://brianway.github.io/tags/安装部署/"}]}]