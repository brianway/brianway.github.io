<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    
<!-- Google Analytics -->
<!--
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-77782495-1', 'auto');
ga('send', 'pageview');
</script>
 <script async src='https://www.google-analytics.com/analytics.js'></script>
-->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-77782495-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-77782495-1');
</script>

<!-- End Google Analytics -->


    

    
<!-- Baidu Tongji -->
<!--
<script>var _hmt = _hmt || [];</script>
<script async src="//hm.baidu.com/hm.js?01ead8d132fad393952a3d004d92453e"></script>
-->
<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?01ead8d132fad393952a3d004d92453e";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    
    <title>几种常见排序算法 | Brian&#39;s Homepage | 猥琐发育，别浪！</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="算法">
    <meta name="description" content="本文介绍几种常见排序算法（选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序），对算法的思路、性质、特点、具体步骤、java实现以及trace图解进行了全面的说明。最后对几种排序算法进行了比较和总结。">
<meta name="keywords" content="算法">
<meta property="og:type" content="article">
<meta property="og:title" content="几种常见排序算法">
<meta property="og:url" content="https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/index.html">
<meta property="og:site_name" content="Brian&#39;s Homepage">
<meta property="og:description" content="本文介绍几种常见排序算法（选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序），对算法的思路、性质、特点、具体步骤、java实现以及trace图解进行了全面的说明。最后对几种排序算法进行了比较和总结。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_selectionsort-1.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_selectionsort-2.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_insertionsort-1.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_insertionsort-2.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_shellsort-1.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_mergesort-1.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_mergesort-2.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_quicksort-1.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_quicksort-3way-1.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_heapsort-1.png">
<meta property="og:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_sort-summary.png">
<meta property="og:updated_time" content="2019-04-03T17:13:21.130Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="几种常见排序算法">
<meta name="twitter:description" content="本文介绍几种常见排序算法（选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序），对算法的思路、性质、特点、具体步骤、java实现以及trace图解进行了全面的说明。最后对几种排序算法进行了比较和总结。">
<meta name="twitter:image" content="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_selectionsort-1.png">
    
        <link rel="alternate" type="application/atom+xml" title="Brian&#39;s Homepage" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/me_640.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Brian Way</h5>
          <a href="mailto:weichuyang(at)163.com" title="weichuyang(at)163.com" class="mail">weichuyang(at)163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/brianway" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about">
                <i class="icon icon-lg icon-link"></i>
                关于
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">几种常见排序算法</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">几种常见排序算法</h1>
        <h5 class="subtitle">
            
                <time datetime="2016-05-07T22:19:00.000Z" itemprop="datePublished" class="page-time">
  2016-05-08
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法和数据结构/">算法和数据结构</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#写在前面"><span class="post-toc-number">1.</span> <span class="post-toc-text">写在前面</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#基础介绍"><span class="post-toc-number">2.</span> <span class="post-toc-text">基础介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#初级排序算法"><span class="post-toc-number">3.</span> <span class="post-toc-text">初级排序算法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#selection-sort-选择排序"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">selection sort(选择排序)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#insertion-sort-插入排序"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">insertion sort(插入排序)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ShellSort-希尔排序"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">ShellSort(希尔排序)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#shuffing-不是排序算法"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">shuffing(不是排序算法)</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#merge-sort-归并排序"><span class="post-toc-number">4.</span> <span class="post-toc-text">merge sort(归并排序)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Abstract-in-place-merge-原地归并的抽象方法"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Abstract in-place merge(原地归并的抽象方法)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Top-down-mergesort-自顶向下的归并排序"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Top-down mergesort(自顶向下的归并排序)</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Bottom-up-mergesort-自底向上的归并排序"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">Bottom-up mergesort(自底向上的归并排序)</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#quicksort"><span class="post-toc-number">5.</span> <span class="post-toc-text">quicksort</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三向切分的快速排序"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">三向切分的快速排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Heapsort-堆排序"><span class="post-toc-number">6.</span> <span class="post-toc-text">Heapsort(堆排序)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结和比较"><span class="post-toc-number">7.</span> <span class="post-toc-text">总结和比较</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#命题"><span class="post-toc-number">8.</span> <span class="post-toc-text">命题</span></a></li></ol>
        </nav>
    </aside>


<article id="post-2016-05-08-algorithms-several-sort-algorithms" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">几种常见排序算法</h1>
        <div class="post-meta">
            <time class="post-time" title="2016-05-08 06:19:00" datetime="2016-05-07T22:19:00.000Z" itemprop="datePublished">2016-05-08</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/算法和数据结构/">算法和数据结构</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>本文介绍几种常见排序算法（选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序），对算法的思路、性质、特点、具体步骤、java实现以及trace图解进行了全面的说明。最后对几种排序算法进行了比较和总结。</p>
<a id="more"></a>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul>
<li>本文所有图片均截图自coursera上普林斯顿的课程<a href="https://class.coursera.org/algs4partI-010/" target="_blank" rel="noopener">《Algorithms, Part I》</a>中的Slides</li>
<li>相关命题的证明可参考<a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">《算法（第4版）》</a></li>
<li>源码可在<a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="noopener">官网</a>下载,也可以在我的github仓库 <a href="https://github.com/brianway/algorithms-learning" target="_blank" rel="noopener">algorithms-learning</a>下载，已经使用maven构建</li>
<li>仓库下载：<code>git clone git@github.com:brianway/algorithms-learning.git</code></li>
</ul>
<h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><blockquote>
<p>java: <a href="https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/Comparable.html" target="_blank" rel="noopener"><code>Interface Comparable&lt;T&gt;</code></a></p>
</blockquote>
<p>Java中很多类已经实现了<code>Comparable&lt;T&gt;</code>接口，用户也可自定义类型实现该接口</p>
<p>total order:</p>
<ul>
<li>Antisymmetry(反对称性): if v ≤ w and w ≤ v, then v = w.</li>
<li>Transitivity(传递性): if v ≤ w and w ≤ x, then v ≤ x.</li>
<li>Totality: either v ≤ w or w ≤ v or both.</li>
</ul>
<p><em>注意： The <code>&lt;=</code> operator for double is not a total order</em>，violates totality: (Double.NaN <code>&lt;=</code> Double.NaN) is false</p>
<p>通用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Less. Is item v less than w ?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exchange. Swap item in array a[] at index i with the one at index j</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a,, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Comparable swap = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = swap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初级排序算法"><a href="#初级排序算法" class="headerlink" title="初级排序算法"></a>初级排序算法</h2><h3 id="selection-sort-选择排序"><a href="#selection-sort-选择排序" class="headerlink" title="selection sort(选择排序)"></a>selection sort(选择排序)</h3><p>思路：</p>
<blockquote>
<ul>
<li>在第i次迭代中，在剩下的(即未排序的)元素中找到最小的元素</li>
<li>将第i个元素与最小的元素交换位置</li>
</ul>
</blockquote>
<p>现象：</p>
<ul>
<li>设已排序的和未排序的交界处为 ↑，则每次循环， ↑ 从左往右移动一个位置</li>
<li>↑ 左边的元素（包括↑）固定了，且升序</li>
<li>↑ 右边的任一元素全部比左边的所有元素都大</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_selectionsort-1.png" alt="选择排序" title>
                </div>
                <div class="image-caption">选择排序</div>
            </figure>
<p>步骤：</p>
<ul>
<li>move the pointer to the right</li>
<li>indentify index of minimun entry on right</li>
<li>exchange into positon</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_selectionsort-2.png" alt="选择排序" title>
                </div>
                <div class="image-caption">选择排序</div>
            </figure>
<p>java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[min])) min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ul>
<li>运行时间和输入无关，无论输入是已排序，时间复杂度都是O(n^2)</li>
<li>数据移动最少，交换的次数和数组大小是线性关系</li>
</ul>
<h3 id="insertion-sort-插入排序"><a href="#insertion-sort-插入排序" class="headerlink" title="insertion sort(插入排序)"></a>insertion sort(插入排序)</h3><p>思路：</p>
<blockquote>
<ul>
<li>在第i次迭代中，将第i个元素与每一个它左边且比它大的的元素交换位置</li>
</ul>
</blockquote>
<p>现象：</p>
<ul>
<li>设已排序的和未排序的交界处为 ↑，则每次循环， ↑ 从左往右移动一个位置</li>
<li>↑ 左边的元素（包括↑）且升序，但位置不固定(因为后续可能会因插入而移动)</li>
<li>↑ 右边的元素还不可见</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_insertionsort-1.png" alt="插入排序" title>
                </div>
                <div class="image-caption">插入排序</div>
            </figure>
<p>步骤：</p>
<ul>
<li>Move the pointer to the right.</li>
<li>Moving from right to left, exchange <code>a[i]</code> with each larger entry to its left.</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_insertionsort-2.png" alt="插入排序" title>
                </div>
                <div class="image-caption">插入排序</div>
            </figure>
<p>java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j-<span class="number">1</span>]); j--) &#123;</span><br><span class="line">            exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inversion（倒置）：An inversion is a pair of keys that are out of order</p>
<p>部分有序：An array is partially sorted if the number of inversions is ≤ c N.</p>
<p>特点：</p>
<ul>
<li>运行时间和输入有关，当输入已排序时，时间复杂度是O(n);</li>
<li>For partially-sorted arrays, insertion sort runs in linear time.(交换的次数等于输入中倒置(inversion)的个数)</li>
<li>插入排序适合部分有序数组，也适合小规模数组</li>
</ul>
<h3 id="ShellSort-希尔排序"><a href="#ShellSort-希尔排序" class="headerlink" title="ShellSort(希尔排序)"></a>ShellSort(希尔排序)</h3><p>希尔排序是基于插入排序的。</p>
<p>思路：</p>
<blockquote>
<ul>
<li>Move entries more than one position at a time by h-sorting the array</li>
<li>按照h的步长进行插入排序</li>
</ul>
</blockquote>
<p>现象：</p>
<ul>
<li>数组中任意间隔为h的元素都是有序的</li>
<li>A g-sorted array remains g-sorted after h-sorting it.</li>
</ul>
<p><img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_shellsort-1.png" alt="希尔排序"></p>
<p>性质：</p>
<blockquote>
<ul>
<li>递增数列一般采用3x+1：1,4,13,40,121,364…..，使用这种递增数列的希尔排序所需的比较次数不会超过N的若干倍乘以递增数列的长度。</li>
<li>最坏情况下，使用3x+1递增数列的希尔排序的比较次数是O(N^(3/2))</li>
</ul>
</blockquote>
<p>java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3x+1 increment sequence:  1, 4, 13, 40, 121, 364, 1093, ...</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// h-sort the array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h) &#123;</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shuffing-不是排序算法"><a href="#shuffing-不是排序算法" class="headerlink" title="shuffing(不是排序算法)"></a>shuffing(不是排序算法)</h3><blockquote>
<p>目标：Rearrange array so that result is a uniformly random permutation</p>
</blockquote>
<p>shuffle sort思路</p>
<blockquote>
<ul>
<li>为数组的每一个位置生成一个随机实数</li>
<li>排序这个生成的数组</li>
</ul>
</blockquote>
<p>Knuth shuffle demo</p>
<blockquote>
<ul>
<li>In iteration i, pick integer r between 0 and i uniformly at random.</li>
<li>Swap <code>a[i]</code> and <code>a[r]</code>.</li>
</ul>
</blockquote>
<p>correct variant: between i and N – 1</p>
<hr>
<ul>
<li>Mergesort–Java sort for objects.</li>
<li>Quicksort–Java sort for primitive types.</li>
</ul>
<p>下面看看这两种排序算法</p>
<h2 id="merge-sort-归并排序"><a href="#merge-sort-归并排序" class="headerlink" title="merge sort(归并排序)"></a>merge sort(归并排序)</h2><p>思路：</p>
<blockquote>
<ul>
<li>Divide array into two halves.</li>
<li><strong>Recursively</strong> sort each half.</li>
<li>Merge two halves.</li>
</ul>
</blockquote>
<h3 id="Abstract-in-place-merge-原地归并的抽象方法"><a href="#Abstract-in-place-merge-原地归并的抽象方法" class="headerlink" title="Abstract in-place merge(原地归并的抽象方法)"></a>Abstract in-place merge(原地归并的抽象方法)</h3><blockquote>
<p>Given two sorted subarrays a[lo] to a[mid] and a[mid+1] to a[hi],replace with sorted subarray a[lo] to a[hi]</p>
</blockquote>
<p>步骤：</p>
<ul>
<li>先将所有元素复制到<code>aux[]</code>中，再归并回<code>a[]</code>中。</li>
<li>归并时的四个判断：<ul>
<li>左半边用尽(取右半边元素)</li>
<li>右半边用尽(取左半边元素)</li>
<li>右半边的当前元素<strong>小于</strong>左半边的当前元素(取右半边的元素)</li>
<li>右半边的当前元素<strong>大于/等于</strong>左半边的当前元素(取左半边的元素)</li>
</ul>
</li>
</ul>
<p>merging java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// precondition: a[lo .. mid] and a[mid+1 .. hi] are sorted subarrays</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy to aux[]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge back to a[]</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>      (i &gt; mid)              a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)               a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span>                           a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Top-down-mergesort-自顶向下的归并排序"><a href="#Top-down-mergesort-自顶向下的归并排序" class="headerlink" title="Top-down mergesort(自顶向下的归并排序)"></a>Top-down mergesort(自顶向下的归并排序)</h3><p>mergesort java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mergesort a[lo..hi] using auxiliary array aux[lo..hi]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    sort(a, aux, lo, mid);  <span class="comment">//将左边排序</span></span><br><span class="line">    sort(a, aux, mid + <span class="number">1</span>, hi);  <span class="comment">//将右边排序</span></span><br><span class="line">    merge(a, aux, lo, mid, hi); <span class="comment">//归并结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自顶向下的归并排序的轨迹图</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_mergesort-1.png" alt="归并排序" title>
                </div>
                <div class="image-caption">归并排序</div>
            </figure>
<p>由图可知，原地归并排序的大致趋势是，先局部排序，再扩大规模；先左边排序，再右边排序；每次都是左边一半局部排完且merge了，右边一半才开始从最局部的地方开始排序。</p>
<p>改进</p>
<ul>
<li>对小规模子数组使用插入排序</li>
<li>测试数组是否已经有序（左边最大&lt;右边最小时，直接返回）</li>
<li>不将元素复制到辅助数组(节省时间而非空间)</li>
</ul>
<h3 id="Bottom-up-mergesort-自底向上的归并排序"><a href="#Bottom-up-mergesort-自底向上的归并排序" class="headerlink" title="Bottom-up mergesort(自底向上的归并排序)"></a>Bottom-up mergesort(自底向上的归并排序)</h3><p>思路：</p>
<blockquote>
<ul>
<li>先归并微型数组，从两两归并开始(每个元素理解为大小为1的数组)</li>
<li>重复上述步骤，逐步扩大归并的规模，2,4,8…..</li>
</ul>
</blockquote>
<p>java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(...)</span></span>&#123; <span class="comment">/* as before */</span> &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> N = a.length;</span><br><span class="line">     Comparable[] aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz+sz)</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz; lo += sz+sz)</span><br><span class="line">     merge(a, aux, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, N-<span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自底向上的归并排序的轨迹图</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_mergesort-2.png" alt="归并排序" title>
                </div>
                <div class="image-caption">归并排序</div>
            </figure>
<p>由图可知，自底向上归并排序的大致趋势是，先局部排序，逐步扩大到全局排序；步调均匀，稳步扩大</p>
<hr>
<h2 id="quicksort"><a href="#quicksort" class="headerlink" title="quicksort"></a>quicksort</h2><p>思路：</p>
<blockquote>
<ul>
<li><strong>Shuffle</strong> the array.</li>
<li><strong>Partition(切分)</strong> so that, for some j<ul>
<li>entry a[j] is in place</li>
<li>no larger entry to the left of j</li>
<li>no smaller entry to the right of j</li>
</ul>
</li>
<li><strong>Sort</strong> each piece recursively.</li>
</ul>
</blockquote>
<p>其中很重要的一步就是<strong>Partition(切分)</strong>，这个过程使得满足以下三个条件:</p>
<ul>
<li>对于某个j,a[j]已经排定;</li>
<li>a[lo]到a[j-1]中的所有元素都不大于a[j];</li>
<li>a[j+1]到a[hi]中的所有元素都不小于a[j];</li>
</ul>
<p>partition java实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// partition the subarray a[lo..hi] so that a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]</span></span><br><span class="line"><span class="comment">// and return the index j.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = hi + <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find item on lo to swap</span></span><br><span class="line">        <span class="keyword">while</span> (less(a[++i], v))</span><br><span class="line">            <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find item on hi to swap</span></span><br><span class="line">        <span class="keyword">while</span> (less(v, a[--j]))</span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;      <span class="comment">// redundant since a[lo] acts as sentinel</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check if pointers cross</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put partitioning item v at a[j]</span></span><br><span class="line">    exch(a, lo, j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now, a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快排java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    StdRandom.shuffle(a);</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// quicksort the subarray from a[lo] to a[hi]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">    sort(a, lo, j-<span class="number">1</span>);</span><br><span class="line">    sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, hi)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快排的轨迹图</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_quicksort-1.png" alt="快速排序" title>
                </div>
                <div class="image-caption">快速排序</div>
            </figure>
<p>由图可知，和归并排序不同，快排的大致趋势是，先全局大体有个走势——左边比右边小，逐步细化到局部；也是先左后右；局部完成时全部排序也就完成了。</p>
<p>一些实现的细节：</p>
<ul>
<li>原地切分：不使用辅助数组</li>
<li>别越界：测试条件(j == lo)是冗余的(a[lo]不可能比自己小)；</li>
<li>保持随机性：初始时的随机打乱跟重要</li>
<li>终止循环</li>
<li>处理切分元素值有重复的情况：这里可能出问题</li>
</ul>
<p>性质：</p>
<ul>
<li>快排是in-place的</li>
<li>快排不稳定</li>
</ul>
<p>改进</p>
<ul>
<li>对小规模子数组使用插入排序</li>
<li>三取样切分</li>
</ul>
<h3 id="三向切分的快速排序"><a href="#三向切分的快速排序" class="headerlink" title="三向切分的快速排序"></a>三向切分的快速排序</h3><p>思路：</p>
<blockquote>
<ul>
<li>Let v be partitioning item a[lo].</li>
<li>Scan i from left to right.<ul>
<li>(a[i] &lt; v): exchange a[lt] with a[i]; increment both lt and i</li>
<li>(a[i] &gt; v): exchange a[gt] with a[i]; decrement gt</li>
<li>(a[i] == v): increment i</li>
</ul>
</li>
</ul>
</blockquote>
<p>主要是通过增加一个指针来实现的。普通的快拍只有lo和high两个指针，故只能记录<code>大于</code>(high右边)和<code>小于</code>(lo左边)两个区间，<code>等于</code>只能并入其中一个；这里增加了使用了lt,i,gt三个指针，从而达到记录<code>大于</code>(gt右边)、<code>小于</code>(lt左边)和<code>等于</code>(lt和i之间)三个区间。</p>
<p>三切分的示意图</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_quicksort-3way-1.png" alt="三向切分" title>
                </div>
                <div class="image-caption">三向切分</div>
            </figure>
<p>三向切分的java实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quicksort the subarray a[lo .. hi] using 3-way partitioning</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo, gt = hi;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">        <span class="keyword">if</span>      (cmp &lt; <span class="number">0</span>) exch(a, lt++, i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) exch(a, i, gt--);</span><br><span class="line">        <span class="keyword">else</span>              i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi].</span></span><br><span class="line">    sort(a, lo, lt-<span class="number">1</span>);</span><br><span class="line">    sort(a, gt+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Heapsort-堆排序"><a href="#Heapsort-堆排序" class="headerlink" title="Heapsort(堆排序)"></a>Heapsort(堆排序)</h2><p>思路：</p>
<blockquote>
<ul>
<li>Create max-heap with all N keys.</li>
<li>Repeatedly remove the maximum key.</li>
</ul>
</blockquote>
<ul>
<li>swim:由下至上的堆有序化</li>
<li>sink:由上至下的对有序化</li>
</ul>
<p>堆排序主要分为两个阶段：</p>
<ol>
<li>堆的构造</li>
<li>下沉排序</li>
</ol>
<p>java实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] pq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = pq.length;</span><br><span class="line">    <span class="comment">//堆的构造</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">        sink(pq, k, N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下沉排序</span></span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        exch(pq, <span class="number">1</span>, N--);</span><br><span class="line">        sink(pq, <span class="number">1</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆排序的轨迹图</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_heapsort-1.png" alt="堆排序" title>
                </div>
                <div class="image-caption">堆排序</div>
            </figure>
<p>由图看出，堆排序的趋势是，堆构造阶段，大致是降序的走势，到了下沉阶段，从右到左（或者说从后往前）逐步有序</p>
<p>Significance： In-place sorting algorithm with N log N worst-case.</p>
<ul>
<li>Mergesort: no, linear extra space.</li>
<li>Quicksort: no, quadratic time in worst case</li>
</ul>
<p>缺点</p>
<ul>
<li>Inner loop longer than quicksort’s.</li>
<li>Makes poor use of cache memory.</li>
<li>Not stable(不稳定)</li>
</ul>
<h2 id="总结和比较"><a href="#总结和比较" class="headerlink" title="总结和比较"></a>总结和比较</h2><p>排序算法总结表</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xph6d.com1.z0.glb.clouddn.com/algorithms_sort-summary.png" alt="总结" title>
                </div>
                <div class="image-caption">总结</div>
            </figure>
<p>最好情况和最坏情况：参见上面的表格</p>
<p>关于稳定性：</p>
<ul>
<li>稳定性，插入排序，归并排序</li>
<li>不稳定：选择排序，快排，希尔排序，堆排序</li>
<li>原因： Long-distance exchange</li>
</ul>
<p>关于额外空间：除了归并排序需要线性的额外空间，其他都是in-place的</p>
<h2 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h2><ul>
<li>对于长度为N的数组，选择排序需要N^2/2次比较和N次交换(pf见P156)</li>
<li>对于随机排列的长度为N的且主键不重复的数组（pf见P157）<ul>
<li>平均情况下插入排序需要~N^2/4次比较和~N^2/4次交换</li>
<li>最坏情况下需要~N^2/2次比较和~N^2/2次交换，</li>
<li>最好情况下需要N-1次比较和0次交换。</li>
</ul>
</li>
<li>Mergesort uses at most N lg N compares and 6 N lg N array accesses to sort any array of size N.  (pf见P173)</li>
<li>Mergesort uses extra space proportional to N.(The array <code>aux[]</code> needs to be of size N for the last merge.)</li>
<li>Any compare-based sorting algorithm must use at least lg ( N ! ) ~ N lg N compares in the worst-case.(pf见P177)</li>
<li>长度为N的无重复数组排序，快速排序平均需要~2N ln N 次比较（以及1/6即1/3 N ln N的交换）<ul>
<li>最多需要约N^2/2次比较</li>
<li>最少需要~N lg N 次比较</li>
</ul>
</li>
<li>用下沉操作由N个元素构造堆只需少于2N次比较以及少于N次交换(pf见P206)</li>
<li>将N个元素排序，堆排序只需少于（2NlgN+2N）次比较以及一半次数的交换(pf见P208)</li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-04-03T17:13:21.130Z" itemprop="dateUpdated">2019-04-04 01:13:21</time>
</span><br>


        
        本文链接：<a href="/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/" target="_blank" rel="external">https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/</a>
        
    </div>
    
    <footer>
        <a href="https://brianway.github.io">
            <img src="/img/me_640.jpg" alt="Brian Way">
            Brian Way
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/&title=《几种常见排序算法》 — Brian's Homepage&pic=https://brianway.github.io/img/me_640.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/&title=《几种常见排序算法》 — Brian's Homepage&source=本文介绍几种常见排序算法（选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序），对算法的思路、性质、特点、具体步骤、java实现以及trace图解进..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《几种常见排序算法》 — Brian's Homepage&url=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/&via=https://brianway.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2016/05/16/2016-05-16-3D-Rigid-Object-Tracking/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">3D Rigid Object Tracking</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2016/04/18/2016-04-18-javase-multithread-programming-reading-note/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">java多线程核心技术梳理(附源码)</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        欢迎请我喝杯豆浆~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechatpay_small.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechatpay_small.png" data-alipay="/img/alipay_small.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Brian Way &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/&title=《几种常见排序算法》 — Brian's Homepage&pic=https://brianway.github.io/img/me_640.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/&title=《几种常见排序算法》 — Brian's Homepage&source=本文介绍几种常见排序算法（选择排序，插入排序，希尔排序，归并排序，快速排序，堆排序），对算法的思路、性质、特点、具体步骤、java实现以及trace图解进..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《几种常见排序算法》 — Brian's Homepage&url=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/&via=https://brianway.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://brianway.github.io/2016/05/08/2016-05-08-algorithms-several-sort-algorithms/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuklEQVR42u3aQW7CUAwEUO5/abqtBAljO6ap9LKqAgn/USnfjP14xMfz13F+/vXv16uSV4/u9tg48PDw8AZLfz2O3nN+bfLq+Rd09M58zXh4eHjbvPyhfP7BOez8/b1NAg8PD+/OvMk2kJTISbGOh4eH9194yZaQXNUr0PHw8PDuw6veOlliXjRXz6xkLXh4eHgxL+8i3efvlf4eHh4e3rirPnng9u6WbyrR/fHw8PAWePkDNymdJ4V4shX11omHh4d3LS8PUvOl5JFuHjckZ958Fh4eHt4Cr/fjv7roSfibww7/AXh4eHiX8uaNq14xXS2gm0EGHh4e3gIvgfUaUdXgoBfslhNlPDw8vDEviRjyEKE6mJWX4MkWcpi14OHh4V3KSwriSUssL53ns2OFkhoPDw9vzJu3+ect/3nbDA8PD+87vN7DPd9OkmA3zw3KQQkeHh7eGq+3SeQNs95AQLUx9mb9eHh4eH/Eyx/T1SGt6sZQ/q2Ah4eH90Ve/oh/xkcv6s3X82GmDA8PD+8iXi9cyMvrfIlXRb2jLh8eHh5ewJs8aqtlbh4iJOuJBrnw8PDw1nh5hNpr8+eDVpPY4sMvBjw8PLyLeL1hprzxnxfNyeO+FyLj4eHhXcvLG2AT5CSEnWxIeHh4eBu8HNYce4r7+NXAIhkOw8PDw9vj9Vr71cI6WVA+plAY28LDw8Nb4+VFc36+GvVWC+tCJIGHh4e3zKs2/qvBxAZsNOeFh4eHF/OexaP3BVXD2V477c2reHh4eAu8/Mg3jF7TqzpuVY4k8PDw8C7lVUvqHqxXjlcjj8MGGB4eHt4CrzrYlBfBefTQO6KsBQ8PD+8GvGobrBdGTOJdPDw8vHvyksX1iux5noCHh4e3zetFrtX4ILl2PryFh4eHt83r1aW95n21BO+NMuDh4eGt8X4AOlbkKYRL30MAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
